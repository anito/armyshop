
/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

/*!
 * jQuery Templates Plugin
 * http://github.com/jquery/jquery-tmpl
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function( jQuery, undefined ){
    var oldManip = jQuery.fn.domManip, tmplItmAtt = "_tmplitem", htmlExpr = /^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,
        newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];

    function newTmplItem( options, parentItem, fn, data ) {
        // Returns a template item data structure for a new rendered instance of a template (a 'template item').
        // The content field is a hierarchical array of strings and nested items (to be
        // removed and replaced by nodes field of dom elements, once inserted in DOM).
        var newItem = {
            data: data || (parentItem ? parentItem.data : {}),
            _wrap: parentItem ? parentItem._wrap : null,
            tmpl: null,
            parent: parentItem || null,
            nodes: [],
            calls: tiCalls,
            nest: tiNest,
            wrap: tiWrap,
            html: tiHtml,
            update: tiUpdate
        };
        if ( options ) {
            jQuery.extend( newItem, options, { nodes: [], parent: parentItem } );
        }
        if ( fn ) {
            // Build the hierarchical content to be used during insertion into DOM
            newItem.tmpl = fn;
            newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );
            newItem.key = ++itemKey;
            // Keep track of new template item, until it is stored as jQuery Data on DOM element
            (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;
        }
        return newItem;
    }

    // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,
                parent = this.length === 1 && this[0].parentNode;

            appendToTmplItems = newTmplItems || {};
            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
                insert[ original ]( this[0] );
                ret = this;
            } else {
                for ( i = 0, l = insert.length; i < l; i++ ) {
                    cloneIndex = i;
                    elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery.fn[ original ].apply( jQuery(insert[i]), elems );
                    ret = ret.concat( elems );
                }
                cloneIndex = 0;
                ret = this.pushStack( ret, name, insert.selector );
            }
            tmplItems = appendToTmplItems;
            appendToTmplItems = null;
            jQuery.tmpl.complete( tmplItems );
            return ret;
        };
    });

    jQuery.fn.extend({
        // Use first wrapped element as template markup.
        // Return wrapped set of template items, obtained by rendering template against data.
        tmpl: function( data, options, parentItem ) {
            return jQuery.tmpl( this[0], data, options, parentItem );
        },

        // Find which rendered template item the first wrapped DOM element belongs to
        tmplItem: function() {
            return jQuery.tmplItem( this[0] );
        },
        
        tmplElement: function() {
            return jQuery.tmplElement( this[0] );
        },

        // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.
        template: function( name ) {
            return jQuery.template( name, this[0] );
        },

        domManip: function( args, table, callback, options ) {
            // This appears to be a bug in the appendTo, etc. implementation
            // it should be doing .call() instead of .apply(). See #6227
            if ( args[0] && args[0].nodeType ) {
                var dmArgs = jQuery.makeArray( arguments ), argsLength = args.length, i = 0, tmplItem;
                while ( i < argsLength && !(tmplItem = jQuery.data( args[i++], "tmplItem" ))) {}
                if ( argsLength > 1 ) {
                    dmArgs[0] = [jQuery.makeArray( args )];
                }
                if ( tmplItem && cloneIndex ) {
                    dmArgs[2] = function( fragClone ) {
                        // Handler called by oldManip when rendered template has been inserted into DOM.
                        jQuery.tmpl.afterManip( this, fragClone, callback );
                    };
                }
                oldManip.apply( this, dmArgs );
            } else {
                oldManip.apply( this, arguments );
            }
            cloneIndex = 0;
            if ( !appendToTmplItems ) {
                jQuery.tmpl.complete( newTmplItems );
            }
            return this;
        }
    });

    jQuery.extend({
        // Return wrapped set of template items, obtained by rendering template against data.
        tmpl: function( tmpl, data, options, parentItem ) {
            var ret, topLevel = !parentItem;
            if ( topLevel ) {
                // This is a top-level tmpl call (not from a nested template using {{tmpl}})
                parentItem = topTmplItem;
                if ( typeof tmpl != "function" )
                tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );
                wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level
            } else if ( !tmpl ) {
                // The template item is already associated with DOM - this is a refresh.
                // Re-evaluate rendered template for the parentItem
                tmpl = parentItem.tmpl;
                newTmplItems[parentItem.key] = parentItem;
                parentItem.nodes = [];
                if ( parentItem.wrapped ) {
                    updateWrapped( parentItem, parentItem.wrapped );
                }
                // Rebuild, without creating a new template item
                return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));
            }
            if ( !tmpl ) {
                return []; // Could throw...
            }
            if ( typeof data === "function" ) {
                data = data.call( parentItem || {} );
            }
            if ( options && options.wrapped ) {
                updateWrapped( options, options.wrapped );
            }
            ret = jQuery.isArray( data ) ? 
                jQuery.map( data, function( dataItem ) {
                    return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;
                }) :
                [ newTmplItem( options, parentItem, tmpl, data ) ];
            return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;
        },

        // Return rendered template item for an element.
        tmplItem: function( elem ) {
            var tmplItem;
            if ( elem instanceof jQuery ) {
                elem = elem[0];
            }
            while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, "tmplItem" )) && (elem = elem.parentNode) ) {}
            return tmplItem || topTmplItem;
        },
        
        tmplElement: function( elem ) {
            var tmplItem;
            if ( elem instanceof jQuery ) {
                elem = elem[0];
            }
            while ( elem && elem.nodeType === 1 && !jQuery.data( elem, "tmplItem" ) && (elem = elem.parentNode) ) {}
            return elem;
        },

        // Set:
        // Use $.template( name, tmpl ) to cache a named template,
        // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.
        // Use $( "selector" ).template( name ) to provide access by name to a script block template declaration.

        // Get:
        // Use $.template( name ) to access a cached template.
        // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )
        // will return the compiled template, without adding a name reference.
        // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent
        // to $.template( null, templateString )
        template: function( name, tmpl ) {
            if (tmpl) {
                // Compile template and associate with name
                if ( typeof tmpl === "string" ) {
                    // This is an HTML string being passed directly in.
                    tmpl = buildTmplFn( tmpl )
                } else if ( tmpl instanceof jQuery ) {
                    tmpl = tmpl[0] || {};
                }
                if ( tmpl.nodeType ) {
                    // If this is a template block, use cached copy, or generate tmpl function and cache.
                    tmpl = jQuery.data( tmpl, "tmpl" ) || jQuery.data( tmpl, "tmpl", buildTmplFn( tmpl.innerHTML ));
                }
                return typeof name === "string" ? (jQuery.template[name] = tmpl) : tmpl;
            }
            // Return named compiled template
            return name ? (typeof name !== "string" ? jQuery.template( null, name ): 
                (jQuery.template[name] || 
                    // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec) 
                    jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null; 
        },

        encode: function( text ) {
            // Do HTML encoding replacing < > & and ' and " by corresponding entities.
            return ("" + text).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;");
        }
    });

    jQuery.extend( jQuery.tmpl, {
        tag: {
            "tmpl": {
                _default: { $2: "null" },
                open: "if($notnull_1){_=_.concat($item.nest($1,$2));}"
                // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)
                // This means that {{tmpl foo}} treats foo as a template (which IS a function). 
                // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.
            },
            "wrap": {
                _default: { $2: "null" },
                open: "$item.calls(_,$1,$2);_=[];",
                close: "call=$item.calls();_=call._.concat($item.wrap(call,_));"
            },
            "each": {
                _default: { $2: "$index, $value" },
                open: "if($notnull_1){$.each($1a,function($2){with(this){",
                close: "}});}"
            },
            "if": {
                open: "if(($notnull_1) && $1a){",
                close: "}"
            },
            "else": {
                _default: { $1: "true" },
                open: "}else if(($notnull_1) && $1a){"
            },
            "html": {
                // Unecoded expression evaluation. 
                open: "if($notnull_1){_.push($1a);}"
            },
            "=": {
                // Encoded expression evaluation. Abbreviated form is ${}.
                _default: { $1: "$data" },
                open: "if($notnull_1){_.push($.encode($1a));}"
            },
            "!": {
                // Comment tag. Skipped by parser
                open: ""
            }
        },

        // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events
        complete: function( items ) {
            newTmplItems = {};
        },

        // Call this from code which overrides domManip, or equivalent
        // Manage cloning/storing template items etc.
        afterManip: function afterManip( elem, fragClone, callback ) {
            // Provides cloned fragment ready for fixup prior to and after insertion into DOM
            var content = fragClone.nodeType === 11 ?
                jQuery.makeArray(fragClone.childNodes) :
                fragClone.nodeType === 1 ? [fragClone] : [];

            // Return fragment to original caller (e.g. append) for DOM insertion
            callback.call( elem, fragClone );

            // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.
            storeTmplItems( content );
            cloneIndex++;
        }
    });

    //========================== Private helper functions, used by code above ==========================

    function build( tmplItem, nested, content ) {
        // Convert hierarchical content into flat string array 
        // and finally return array of fragments ready for DOM insertion
        var frag, ret = content ? jQuery.map( content, function( item ) {
            return (typeof item === "string") ? 
                // Insert template item annotations, to be converted to jQuery.data( "tmplItem" ) when elems are inserted into DOM.
                (tmplItem.key ? item.replace( /(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g, "$1 " + tmplItmAtt + "=\"" + tmplItem.key + "\" $2" ) : item) :
                // This is a child template item. Build nested template.
                build( item, tmplItem, item._ctnt );
        }) : 
        // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}. 
        tmplItem;
        if ( nested ) {
            return ret;
        }

        // top-level template
        ret = ret.join("");

        // Support templates which have initial or final text nodes, or consist only of text
        // Also support HTML entities within the HTML markup.
        ret.replace( /^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/, function( all, before, middle, after) {
            frag = jQuery( middle ).get();

            storeTmplItems( frag );
            if ( before ) {
                frag = unencode( before ).concat(frag);
            }
            if ( after ) {
                frag = frag.concat(unencode( after ));
            }
        });
        return frag ? frag : unencode( ret );
    }

    function unencode( text ) {
        // Use createElement, since createTextNode will not render HTML entities correctly
        var el = document.createElement( "div" );
        el.innerHTML = text;
        return jQuery.makeArray(el.childNodes);
    }

    // Generate a reusable function that will serve to render a template against data
    function buildTmplFn( markup ) {
        return new Function("jQuery","$item",
            "var $=jQuery,call,_=[],$data=$item.data;" +

            // Introduce the data as local variables using with(){}
            "with($data){_.push('" +

            // Convert the template into pure JavaScript
            jQuery.trim(markup)
                .replace( /([\\'])/g, "\\$1" )
                .replace( /[\r\t\n]/g, " " )
                .replace( /\$\{([^\}]*)\}/g, "{{= $1}}" )
                .replace( /\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,
                function( all, slash, type, fnargs, target, parens, args ) {
                    var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;
                    if ( !tag ) {
                        throw "Template command not found: " + type;
                    }
                    def = tag._default || [];
                    if ( parens && !/\w$/.test(target)) {
                        target += parens;
                        parens = "";
                    }
                    if ( target ) {
                        target = unescape( target ); 
                        args = args ? ("," + unescape( args ) + ")") : (parens ? ")" : "");
                        // Support for target being things like a.toLowerCase();
                        // In that case don't call with template item as 'this' pointer. Just evaluate...
                        expr = parens ? (target.indexOf(".") > -1 ? target + parens : ("(" + target + ").call($data" + args)) : target;
                        exprAutoFnDetect = parens ? expr : "(typeof(" + target + ")==='function'?(" + target + ").call($item):(" + target + "))";
                    } else {
                        exprAutoFnDetect = expr = def.$1 || "null";
                    }
                    fnargs = unescape( fnargs );
                    return "');" + 
                        tag[ slash ? "close" : "open" ]
                            .split( "$notnull_1" ).join( target ? "typeof(" + target + ")!=='undefined' && (" + target + ")!=null" : "true" )
                            .split( "$1a" ).join( exprAutoFnDetect )
                            .split( "$1" ).join( expr )
                            .split( "$2" ).join( fnargs ?
                                fnargs.replace( /\s*([^\(]+)\s*(\((.*?)\))?/g, function( all, name, parens, params ) {
                                    params = params ? ("," + params + ")") : (parens ? ")" : "");
                                    return params ? ("(" + name + ").call($item" + params) : all;
                                })
                                : (def.$2||"")
                            ) +
                        "_.push('";
                }) +
            "');}return _;"
        );
    }
    function updateWrapped( options, wrapped ) {
        // Build the wrapped content. 
        options._wrap = build( options, true, 
            // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.
            jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]
        ).join("");
    }

    function unescape( args ) {
        return args ? args.replace( /\\'/g, "'").replace(/\\\\/g, "\\" ) : null;
    }
    function outerHtml( elem ) {
        var div = document.createElement("div");
        div.appendChild( elem.cloneNode(true) );
        return div.innerHTML;
    }

    // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.
    function storeTmplItems( content ) {
        var keySuffix = "_" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;
        for ( i = 0, l = content.length; i < l; i++ ) {
            if ( (elem = content[i]).nodeType !== 1 ) {
                continue;
            }
            elems = elem.getElementsByTagName("*");
            for ( m = elems.length - 1; m >= 0; m-- ) {
                processItemKey( elems[m] );
            }
            processItemKey( elem );
        }
        function processItemKey( el ) {
            var pntKey, pntNode = el, pntItem, tmplItem, key;
            // Ensure that each rendered template inserted into the DOM has its own template item,
            if ( (key = el.getAttribute( tmplItmAtt ))) {
                while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }
                if ( pntKey !== key ) {
                    // The next ancestor with a _tmplitem expando is on a different key than this one.
                    // So this is a top-level element within this template item
                    // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.
                    pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;
                    if ( !(tmplItem = newTmplItems[key]) ) {
                        // The item is for wrapped content, and was copied from the temporary parent wrappedItem.
                        tmplItem = wrappedItems[key];
                        tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode], null, true );
                        tmplItem.key = ++itemKey;
                        newTmplItems[itemKey] = tmplItem;
                    }
                    if ( cloneIndex ) {
                        cloneTmplItem( key );
                    }
                }
                el.removeAttribute( tmplItmAtt );
            } else if ( cloneIndex && (tmplItem = jQuery.data( el, "tmplItem" )) ) {
                // This was a rendered element, cloned during append or appendTo etc.
                // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.
                cloneTmplItem( tmplItem.key );
                newTmplItems[tmplItem.key] = tmplItem;
                pntNode = jQuery.data( el.parentNode, "tmplItem" );
                pntNode = pntNode ? pntNode.key : 0;
            }
            if ( tmplItem ) {
                pntItem = tmplItem;
                // Find the template item of the parent element. 
                // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)
                while ( pntItem && pntItem.key != pntNode ) { 
                    // Add this element as a top-level node for this rendered template item, as well as for any
                    // ancestor items between this item and the item of its parent element
                    pntItem.nodes.push( el );
                    pntItem = pntItem.parent;
                }
                // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...
                delete tmplItem._ctnt;
                delete tmplItem._wrap;
                // Store template item as jQuery data on the element
                jQuery.data( el, "tmplItem", tmplItem );
            }
            function cloneTmplItem( key ) {
                key = key + keySuffix;
                tmplItem = newClonedItems[key] = 
                    (newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true ));
            }
        }
    }

    //---- Helper functions for template item ----

    function tiCalls( content, tmpl, data, options ) {
        if ( !content ) {
            return stack.pop();
        }
        stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });
    }

    function tiNest( tmpl, data, options ) {
        // nested template, using {{tmpl}} tag
        return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );
    }

    function tiWrap( call, wrapped ) {
        // nested template, using {{wrap}} tag
        var options = call.options || {};
        options.wrapped = wrapped;
        // Apply the template, which may incorporate wrapped content, 
        return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );
    }

    function tiHtml( filter, textOnly ) {
        var wrapped = this._wrap;
        return jQuery.map(
            jQuery( jQuery.isArray( wrapped ) ? wrapped.join("") : wrapped ).filter( filter || "*" ),
            function(e) {
                return textOnly ?
                    e.innerText || e.textContent :
                    e.outerHTML || outerHtml(e);
            });
    }

    function tiUpdate() {
        var coll = this.nodes;
        jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );
        jQuery( coll ).remove();
    }
})( jQuery );
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jade = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * Merge two attribute objects giving precedence
 * to values in object `b`. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  if (arguments.length === 1) {
    var attrs = a[0];
    for (var i = 1; i < a.length; i++) {
      attrs = merge(attrs, a[i]);
    }
    return attrs;
  }
  var ac = a['class'];
  var bc = b['class'];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    a['class'] = ac.concat(bc).filter(nulls);
  }

  for (var key in b) {
    if (key != 'class') {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null `val`s.
 *
 * @param {*} val
 * @return {Boolean}
 * @api private
 */

function nulls(val) {
  return val != null && val !== '';
}

/**
 * join array as classes.
 *
 * @param {*} val
 * @return {String}
 */
exports.joinClasses = joinClasses;
function joinClasses(val) {
  return (Array.isArray(val) ? val.map(joinClasses) :
    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
    [val]).filter(nulls).join(' ');
}

/**
 * Render the given classes.
 *
 * @param {Array} classes
 * @param {Array.<Boolean>} escaped
 * @return {String}
 */
exports.cls = function cls(classes, escaped) {
  var buf = [];
  for (var i = 0; i < classes.length; i++) {
    if (escaped && escaped[i]) {
      buf.push(exports.escape(joinClasses([classes[i]])));
    } else {
      buf.push(joinClasses(classes[i]));
    }
  }
  var text = joinClasses(buf);
  if (text.length) {
    return ' class="' + text + '"';
  } else {
    return '';
  }
};


exports.style = function (val) {
  if (val && typeof val === 'object') {
    return Object.keys(val).map(function (style) {
      return style + ':' + val[style];
    }).join(';');
  } else {
    return val;
  }
};
/**
 * Render the given attribute.
 *
 * @param {String} key
 * @param {String} val
 * @param {Boolean} escaped
 * @param {Boolean} terse
 * @return {String}
 */
exports.attr = function attr(key, val, escaped, terse) {
  if (key === 'style') {
    val = exports.style(val);
  }
  if ('boolean' == typeof val || null == val) {
    if (val) {
      return ' ' + (terse ? key : key + '="' + key + '"');
    } else {
      return '';
    }
  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
    if (JSON.stringify(val).indexOf('&') !== -1) {
      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
                   'will be escaped to `&amp;`');
    };
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will eliminate the double quotes around dates in ' +
                   'ISO form after 2.0.0');
    }
    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
  } else if (escaped) {
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + exports.escape(val) + '"';
  } else {
    if (val && typeof val.toISOString === 'function') {
      console.warn('Jade will stringify dates in ISO form after 2.0.0');
    }
    return ' ' + key + '="' + val + '"';
  }
};

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 */
exports.attrs = function attrs(obj, terse){
  var buf = [];

  var keys = Object.keys(obj);

  if (keys.length) {
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i]
        , val = obj[key];

      if ('class' == key) {
        if (val = joinClasses(val)) {
          buf.push(' ' + key + '="' + val + '"');
        }
      } else {
        buf.push(exports.attr(key, val, false, terse));
      }
    }
  }

  return buf.join('');
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

var jade_encode_html_rules = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};
var jade_match_html = /[&<>"]/g;

function jade_encode_char(c) {
  return jade_encode_html_rules[c] || c;
}

exports.escape = jade_escape;
function jade_escape(html){
  var result = String(html).replace(jade_match_html, jade_encode_char);
  if (result === '' + html) return html;
  else return result;
};

/**
 * Re-throw the given `err` in context to the
 * the jade in `filename` at the given `lineno`.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno, str){
  if (!(err instanceof Error)) throw err;
  if ((typeof window != 'undefined' || !filename) && !str) {
    err.message += ' on line ' + lineno;
    throw err;
  }
  try {
    str = str || require('fs').readFileSync(filename, 'utf8')
  } catch (ex) {
    rethrow(err, null, lineno)
  }
  var context = 3
    , lines = str.split('\n')
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? '  > ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'Jade') + ':' + lineno
    + '\n' + context + '\n\n' + err.message;
  throw err;
};

exports.DebugItem = function DebugItem(lineno, filename) {
  this.lineno = lineno;
  this.filename = filename;
}

},{"fs":2}],2:[function(require,module,exports){

},{}]},{},[1])(1)
});

/*! jQuery UI - v1.10.3 - 2013-07-04
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.sortable.js, jquery.ui.button.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.effect.js, jquery.ui.effect-slide.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.3",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.3",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.3",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);
(function( $, undefined ) {

function isOverAxis( x, reference, size ) {
	return ( x > reference ) && ( x < ( reference + size ) );
}

$.widget("ui.droppable", {
	version: "1.10.3",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var i = 0,
			drop = $.ui.ddmanager.droppables[this.options.scope];

		for ( ; i < drop.length; i++ ) {
			if ( drop[i] === this ) {
				drop.splice(i, 1);
			}
		}

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key === "accept") {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.addClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger("activate", event, this.ui(draggable));
		}
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) {
			this.element.removeClass(this.options.activeClass);
		}
		if(draggable){
			this._trigger("deactivate", event, this.ui(draggable));
		}
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.addClass(this.options.hoverClass);
			}
			this._trigger("over", event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return;
		}

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger("out", event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
			return false;
		}

		this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, "ui-droppable");
			if(
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
				$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) {
			return false;
		}

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) {
				this.element.removeClass(this.options.activeClass);
			}
			if(this.options.hoverClass) {
				this.element.removeClass(this.options.hoverClass);
			}
			this._trigger("drop", event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) {
		return false;
	}

	var draggableLeft, draggableTop,
		x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
		l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case "fit":
			return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
		case "intersect":
			return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
				x2 - (draggable.helperProportions.width / 2) < r && // Left Half
				t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
				y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
		case "pointer":
			draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
			draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
			return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );
		case "touch":
			return (
				(y1 >= t && y1 <= b) ||	// Top edge touching
				(y2 >= t && y2 <= b) ||	// Bottom edge touching
				(y1 < t && y2 > b)		// Surrounded vertically
			) && (
				(x1 >= l && x1 <= r) ||	// Left edge touching
				(x2 >= l && x2 <= r) ||	// Right edge touching
				(x1 < l && x2 > r)		// Surrounded horizontally
			);
		default:
			return false;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function(t, event) {

		var i, j,
			m = $.ui.ddmanager.droppables[t.options.scope] || [],
			type = event ? event.type : null, // workaround for #2317
			list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

		droppablesLoop: for (i = 0; i < m.length; i++) {

			//No disabled and non-accepted
			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
				continue;
			}

			// Filter out elements in the current dragged item
			for (j=0; j < list.length; j++) {
				if(list[j] === m[i].element[0]) {
					m[i].proportions.height = 0;
					continue droppablesLoop;
				}
			}

			m[i].visible = m[i].element.css("display") !== "none";
			if(!m[i].visible) {
				continue;
			}

			//Activate the droppable if used directly from draggables
			if(type === "mousedown") {
				m[i]._activate.call(m[i], event);
			}

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

			if(!this.options) {
				return;
			}
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
				dropped = this._drop.call(this, event) || dropped;
			}

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) {
			$.ui.ddmanager.prepareOffsets(draggable, event);
		}

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect(draggable, this, this.options.tolerance),
				c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
			if(!c) {
				return;
			}

			if (this.options.greedy) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents(":data(ui-droppable)").filter(function () {
					return $.data(this, "ui-droppable").options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], "ui-droppable");
					parentInstance.greedyChild = (c === "isover");
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c === "isover") {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c === "isout") {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

})(jQuery);
(function( $, undefined ) {

/*jshint loopfunc: true */

function isOverAxis( x, reference, size ) {
	return ( x > reference ) && ( x < ( reference + size ) );
}

function isFloating(item) {
	return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
}

$.widget("ui.sortable", $.ui.mouse, {
	version: "1.10.3",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true;

	},

	_destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget().toggleClass( "ui-sortable-disabled", !!value );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
			}
			this.reverting = true;
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[0] )
							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
							.removeClass("ui-sortable-helper");

					if ( nodeName === "tr" ) {
						that.currentItem.children().each(function() {
							$( "<td>&#160;</td>", that.document[0] )
								.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
								.appendTo( element );
						});
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			if (!this.containers[innermostIndex].containerCache.over) {
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || isFloating(this.currentItem);
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}
				if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
					continue;
				}
				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			if(this.currentContainer === this.containers[innermostIndex]) {
				return;
			}

			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
			this.currentContainer = this.containers[innermostIndex];

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] !== this.currentItem[0]) {
			this.helper.remove();
		}
		this.helper = null;

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var form = $( this );
		setTimeout(function() {
			form.find( ":ui-button" ).button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /'/g, "\\'" );
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.10.3",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "",
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an "active" state
				.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.10.3",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	version: "1.10.3",
	options: {
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				role: "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}

		this._super( key, value );
	},

	_percentage: function() {
		return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
});

})( jQuery );
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.10.3",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			this.range = $([]);
		}
	},

	_setupEvents: function() {
		var elements = this.handles.add( this.range ).filter( "a" );
		this._off( elements );
		this._on( elements, this._handleEvents );
		this._hoverable( elements );
		this._focusable( elements );
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length-1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			/*jshint maxcomplexity:25*/
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		click: function( event ) {
			event.preventDefault();
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}

});

}(jQuery));
(function($, undefined) {

var dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.10.3",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery);
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

/*!
  * Bootstrap v4.0.0-beta.2 (https://getbootstrap.com)
  * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
var bootstrap = (function (exports,$) {
'use strict';

$ = $ && $.hasOwnProperty('default') ? $['default'] : $;

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): util.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Util = function () {
  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */
  var transition = false;
  var MAX_UID = 1000000;
  var TransitionEndEvent = {
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'transitionend',
    OTransition: 'oTransitionEnd otransitionend',
    transition: 'transitionend' // shoutout AngusCroll (https://goo.gl/pxwQGp)

  };

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: transition.end,
      delegateType: transition.end,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndTest() {
    if (window.QUnit) {
      return false;
    }

    var el = document.createElement('bootstrap');

    for (var name in TransitionEndEvent) {
      if (typeof el.style[name] !== 'undefined') {
        return {
          end: TransitionEndEvent[name]
        };
      }
    }

    return false;
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    transition = transitionEndTest();
    $.fn.emulateTransitionEnd = transitionEndEmulator;

    if (Util.supportsTransitionEnd()) {
      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        selector = element.getAttribute('href') || '';
      }

      try {
        var $selector = $(document).find(selector);
        return $selector.length > 0 ? selector : null;
      } catch (error) {
        return null;
      }
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(transition.end);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(transition);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    }
  };
  setTransitionEndSupport();
  return Util;
}($);

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var inheritsLoose = _inheritsLoose;

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Alert = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'alert';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var Selector = {
    DISMISS: '[data-dismiss="alert"]'
  };
  var Event = {
    CLOSE: "close" + EVENT_KEY,
    CLOSED: "closed" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    SHOW: 'show'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Alert =
  /*#__PURE__*/
  function () {
    function Alert(element) {
      this._element = element;
    } // getters


    var _proto = Alert.prototype;

    // public
    _proto.close = function close(element) {
      element = element || this._element;

      var rootElement = this._getRootElement(element);

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    }; // private


    _proto._getRootElement = function _getRootElement(element) {
      var selector = Util.getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = $(selector)[0];
      }

      if (!parent) {
        parent = $(element).closest("." + ClassName.ALERT)[0];
      }

      return parent;
    };

    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
      var closeEvent = $.Event(Event.CLOSE);
      $(element).trigger(closeEvent);
      return closeEvent;
    };

    _proto._removeElement = function _removeElement(element) {
      var _this = this;

      $(element).removeClass(ClassName.SHOW);

      if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);

        return;
      }

      $(element).one(Util.TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(TRANSITION_DURATION);
    };

    _proto._destroyElement = function _destroyElement(element) {
      $(element).detach().trigger(Event.CLOSED).remove();
    }; // static


    Alert._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    };

    Alert._handleDismiss = function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    };

    createClass(Alert, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);
    return Alert;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Alert._jQueryInterface;
  $.fn[NAME].Constructor = Alert;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Alert._jQueryInterface;
  };

  return Alert;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Button = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'button';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.button';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var ClassName = {
    ACTIVE: 'active',
    BUTTON: 'btn',
    FOCUS: 'focus'
  };
  var Selector = {
    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
    DATA_TOGGLE: '[data-toggle="buttons"]',
    INPUT: 'input',
    ACTIVE: '.active',
    BUTTON: '.btn'
  };
  var Event = {
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY + DATA_API_KEY + " " + ("blur" + EVENT_KEY + DATA_API_KEY)
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Button =
  /*#__PURE__*/
  function () {
    function Button(element) {
      this._element = element;
    } // getters


    var _proto = Button.prototype;

    // public
    _proto.toggle = function toggle() {
      var triggerChangeEvent = true;
      var addAriaPressed = true;
      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];

      if (rootElement) {
        var input = $(this._element).find(Selector.INPUT)[0];

        if (input) {
          if (input.type === 'radio') {
            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {
              triggerChangeEvent = false;
            } else {
              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];

              if (activeElement) {
                $(activeElement).removeClass(ClassName.ACTIVE);
              }
            }
          }

          if (triggerChangeEvent) {
            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
              return;
            }

            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);
            $(input).trigger('change');
          }

          input.focus();
          addAriaPressed = false;
        }
      }

      if (addAriaPressed) {
        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));
      }

      if (triggerChangeEvent) {
        $(this._element).toggleClass(ClassName.ACTIVE);
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    }; // static


    Button._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        if (!data) {
          data = new Button(this);
          $(this).data(DATA_KEY, data);
        }

        if (config === 'toggle') {
          data[config]();
        }
      });
    };

    createClass(Button, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);
    return Button;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
    event.preventDefault();
    var button = event.target;

    if (!$(button).hasClass(ClassName.BUTTON)) {
      button = $(button).closest(Selector.BUTTON);
    }

    Button._jQueryInterface.call($(button), 'toggle');
  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
    var button = $(event.target).closest(Selector.BUTTON)[0];
    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Button._jQueryInterface;
  $.fn[NAME].Constructor = Button;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Button._jQueryInterface;
  };

  return Button;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Carousel = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'carousel';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.carousel';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 600;
  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean'
  };
  var Direction = {
    NEXT: 'next',
    PREV: 'prev',
    LEFT: 'left',
    RIGHT: 'right'
  };
  var Event = {
    SLIDE: "slide" + EVENT_KEY,
    SLID: "slid" + EVENT_KEY,
    KEYDOWN: "keydown" + EVENT_KEY,
    MOUSEENTER: "mouseenter" + EVENT_KEY,
    MOUSELEAVE: "mouseleave" + EVENT_KEY,
    TOUCHEND: "touchend" + EVENT_KEY,
    LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    CAROUSEL: 'carousel',
    ACTIVE: 'active',
    SLIDE: 'slide',
    RIGHT: 'carousel-item-right',
    LEFT: 'carousel-item-left',
    NEXT: 'carousel-item-next',
    PREV: 'carousel-item-prev',
    ITEM: 'carousel-item'
  };
  var Selector = {
    ACTIVE: '.active',
    ACTIVE_ITEM: '.active.carousel-item',
    ITEM: '.carousel-item',
    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
    INDICATORS: '.carousel-indicators',
    DATA_SLIDE: '[data-slide], [data-slide-to]',
    DATA_RIDE: '[data-ride="carousel"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Carousel =
  /*#__PURE__*/
  function () {
    function Carousel(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this._config = this._getConfig(config);
      this._element = $(element)[0];
      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];

      this._addEventListeners();
    } // getters


    var _proto = Carousel.prototype;

    // public
    _proto.next = function next() {
      if (!this._isSliding) {
        this._slide(Direction.NEXT);
      }
    };

    _proto.nextWhenVisible = function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
        this.next();
      }
    };

    _proto.prev = function prev() {
      if (!this._isSliding) {
        this._slide(Direction.PREV);
      }
    };

    _proto.pause = function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {
        Util.triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    };

    _proto.cycle = function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    };

    _proto.to = function to(index) {
      var _this = this;

      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        $(this._element).one(Event.SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

      this._slide(direction, this._items[index]);
    };

    _proto.dispose = function dispose() {
      $(this._element).off(EVENT_KEY);
      $.removeData(this._element, DATA_KEY);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    }; // private


    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, Default, config);
      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._addEventListeners = function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        $(this._element).on(Event.KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        $(this._element).on(Event.MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(Event.MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });

        if ('ontouchstart' in document.documentElement) {
          // if it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          $(this._element).on(Event.TOUCHEND, function () {
            _this2.pause();

            if (_this2.touchTimeout) {
              clearTimeout(_this2.touchTimeout);
            }

            _this2.touchTimeout = setTimeout(function (event) {
              return _this2.cycle(event);
            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
          });
        }
      }
    };

    _proto._keydown = function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;

        default:
          return;
      }
    };

    _proto._getItemIndex = function _getItemIndex(element) {
      this._items = $.makeArray($(element).parent().find(Selector.ITEM));
      return this._items.indexOf(element);
    };

    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === Direction.NEXT;
      var isPrevDirection = direction === Direction.PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === Direction.PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    };

    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);

      var slideEvent = $.Event(Event.SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      $(this._element).trigger(slideEvent);
      return slideEvent;
    };

    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          $(nextIndicator).addClass(ClassName.ACTIVE);
        }
      }
    };

    _proto._slide = function _slide(direction, element) {
      var _this3 = this;

      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === Direction.NEXT) {
        directionalClassName = ClassName.LEFT;
        orderClassName = ClassName.NEXT;
        eventDirectionName = Direction.LEFT;
      } else {
        directionalClassName = ClassName.RIGHT;
        orderClassName = ClassName.PREV;
        eventDirectionName = Direction.RIGHT;
      }

      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      var slidEvent = $.Event(Event.SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {
        $(nextElement).addClass(orderClassName);
        Util.reflow(nextElement);
        $(activeElement).addClass(directionalClassName);
        $(nextElement).addClass(directionalClassName);
        $(activeElement).one(Util.TRANSITION_END, function () {
          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName.ACTIVE);
          $(activeElement).removeClass(ClassName.ACTIVE + " " + orderClassName + " " + directionalClassName);
          _this3._isSliding = false;
          setTimeout(function () {
            return $(_this3._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        $(activeElement).removeClass(ClassName.ACTIVE);
        $(nextElement).addClass(ClassName.ACTIVE);
        this._isSliding = false;
        $(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    }; // static


    Carousel._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = $.extend({}, Default, $(this).data());

        if (typeof config === 'object') {
          $.extend(_config, config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new Error("No method named \"" + action + "\"");
          }

          data[action]();
        } else if (_config.interval) {
          data.pause();
          data.cycle();
        }
      });
    };

    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
      var selector = Util.getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = $(selector)[0];

      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {
        return;
      }

      var config = $.extend({}, $(target).data(), $(this).data());
      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call($(target), config);

      if (slideIndex) {
        $(target).data(DATA_KEY).to(slideIndex);
      }

      event.preventDefault();
    };

    createClass(Carousel, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);
    return Carousel;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
  $(window).on(Event.LOAD_DATA_API, function () {
    $(Selector.DATA_RIDE).each(function () {
      var $carousel = $(this);

      Carousel._jQueryInterface.call($carousel, $carousel.data());
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Carousel._jQueryInterface;
  $.fn[NAME].Constructor = Carousel;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Carousel._jQueryInterface;
  };

  return Carousel;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Collapse = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'collapse';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.collapse';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 600;
  var Default = {
    toggle: true,
    parent: ''
  };
  var DefaultType = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event = {
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = $.makeArray($("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var tabToggles = $(Selector.DATA_TOGGLE);

      for (var i = 0; i < tabToggles.length; i++) {
        var elem = tabToggles[i];
        var selector = Util.getSelectorFromElement(elem);

        if (selector !== null && $(selector).filter(element).length > 0) {
          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // getters


    var _proto = Collapse.prototype;

    // public
    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = $.makeArray($(this._parent).children().children(Selector.ACTIVES));

        if (!actives.length) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).data(DATA_KEY);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event.SHOWN);
      };

      if (!Util.supportsTransitionEnd()) {
        complete();
        return;
      }

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

      if (this._triggerArray.length) {
        for (var i = 0; i < this._triggerArray.length; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $(selector);

            if (!$elem.hasClass(ClassName.SHOW)) {
              $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
      };

      this._element.style[dimension] = '';

      if (!Util.supportsTransitionEnd()) {
        complete();
        return;
      }

      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    }; // private


    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, Default, config);
      config.toggle = Boolean(config.toggle); // coerce string values

      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent = null;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // it's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = $(this._config.parent)[0];
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      $(parent).find(selector).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      if (element) {
        var isOpen = $(element).hasClass(ClassName.SHOW);

        if (triggerArray.length) {
          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
        }
      }
    }; // static


    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? $(selector)[0] : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY);

        var _config = $.extend({}, Default, $this.data(), typeof config === 'object' && config);

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);
    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    $(selector).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Collapse._jQueryInterface;
  $.fn[NAME].Constructor = Collapse;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Collapse._jQueryInterface;
  };

  return Collapse;
}($);

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.5
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var nativeHints = ['native code', '[object MutationObserverConstructor]'];

/**
 * Determine if a function is implemented natively (as opposed to a polyfill).
 * @method
 * @memberof Popper.Utils
 * @argument {Function | undefined} fn the function to check
 * @returns {Boolean}
 */
var isNative = (function (fn) {
  return nativeHints.some(function (hint) {
    return (fn || '').toString().indexOf(hint) > -1;
  });
});

var isBrowser = typeof window !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var scheduled = false;
  var i = 0;
  var elem = document.createElement('span');

  // MutationObserver provides a mechanism for scheduling microtasks, which
  // are scheduled *before* the next task. This gives us a way to debounce
  // a function but ensure it's called *before* the next paint.
  var observer = new MutationObserver(function () {
    fn();
    scheduled = false;
  });

  observer.observe(elem, { attributes: true });

  return function () {
    if (!scheduled) {
      scheduled = true;
      elem.setAttribute('x-index', i);
      i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
    }
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

// It's common for MutationObserver polyfills to be seen in the wild, however
// these rely on Mutation Events which only occur when an element is connected
// to the DOM. The algorithm used in this module does not use a connected element,
// and so we must ensure that a *native* MutationObserver is available.
var supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {
    return window.document.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return window.document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return window.document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = window.document.documentElement;
    var scrollingElement = window.document.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = window.document.body;
  var html = window.document.documentElement;
  var computedStyle = isIE10$1() && window.getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends$1 = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends$1({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = +styles.borderTopWidth.split('px')[0];
  var borderLeftWidth = +styles.borderLeftWidth.split('px')[0];

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = +styles.marginTop.split('px')[0];
    var marginLeft = +styles.marginLeft.split('px')[0];

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = window.document.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(popper));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = window.document.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = window.document.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends$1({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier.function) {
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier.function || modifier.fn;
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof window.document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? window : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  window.addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  window.removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    window.cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends$1({}, attributes, data.attributes);
  data.styles = _extends$1({}, styles, data.styles);
  data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var popperMarginSide = getStyleComputedProperty(data.instance.popper, 'margin' + sideCapitalized).replace('px', '');
  var sideValue = center - getClientRect(data.offsets.popper)[side] - popperMarginSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = {};
  data.offsets.arrow[side] = Math.round(sideValue);
  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends$1({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends$1({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference.jquery ? reference[0] : reference;
    this.popper = popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends$1({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass$1(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Dropdown = function () {
  /**
   * Check for Popper dependency
   * Popper - https://popper.js.org
   */
  if (typeof Popper === 'undefined') {
    throw new Error('Bootstrap dropdown require Popper.js (https://popper.js.org)');
  }
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'dropdown';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.dropdown';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    CLICK: "click" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
    KEYDOWN_DATA_API: "keydown" + EVENT_KEY + DATA_API_KEY,
    KEYUP_DATA_API: "keyup" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    DISABLED: 'disabled',
    SHOW: 'show',
    DROPUP: 'dropup',
    MENURIGHT: 'dropdown-menu-right',
    MENULEFT: 'dropdown-menu-left'
  };
  var Selector = {
    DATA_TOGGLE: '[data-toggle="dropdown"]',
    FORM_CHILD: '.dropdown form',
    MENU: '.dropdown-menu',
    NAVBAR_NAV: '.navbar-nav',
    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled)'
  };
  var AttachmentMap = {
    TOP: 'top-start',
    TOPEND: 'top-end',
    BOTTOM: 'bottom-start',
    BOTTOMEND: 'bottom-end'
  };
  var Default = {
    offset: 0,
    flip: true
  };
  var DefaultType = {
    offset: '(number|string|function)',
    flip: 'boolean'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Dropdown =
  /*#__PURE__*/
  function () {
    function Dropdown(element, config) {
      this._element = element;
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();

      this._addEventListeners();
    } // getters


    var _proto = Dropdown.prototype;

    // public
    _proto.toggle = function toggle() {
      if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this._element);

      var isActive = $(this._menu).hasClass(ClassName.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event.SHOW, relatedTarget);
      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      var element = this._element; // for dropup with alignment we use the parent as popper container

      if ($(parent).hasClass(ClassName.DROPUP)) {
        if ($(this._menu).hasClass(ClassName.MENULEFT) || $(this._menu).hasClass(ClassName.MENURIGHT)) {
          element = parent;
        }
      }

      this._popper = new Popper(element, this._menu, this._getPopperConfig()); // if this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

      if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {
        $('body').children().on('mouseover', null, $.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      $(this._menu).toggleClass(ClassName.SHOW);
      $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      $(this._element).off(EVENT_KEY);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();
      }

      this._popper = null;
    };

    _proto.update = function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    }; // private


    _proto._addEventListeners = function _addEventListeners() {
      var _this = this;

      $(this._element).on(Event.CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    };

    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, this.constructor.Default, $(this._element).data(), config);
      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getMenuElement = function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        this._menu = $(parent).find(Selector.MENU)[0];
      }

      return this._menu;
    };

    _proto._getPlacement = function _getPlacement() {
      var $parentDropdown = $(this._element).parent();
      var placement = AttachmentMap.BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(ClassName.DROPUP)) {
        placement = AttachmentMap.TOP;

        if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
          placement = AttachmentMap.TOPEND;
        }
      } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
        placement = AttachmentMap.BOTTOMEND;
      }

      return placement;
    };

    _proto._detectNavbar = function _detectNavbar() {
      return $(this._element).closest('.navbar').length > 0;
    };

    _proto._getPopperConfig = function _getPopperConfig() {
      var _this2 = this;

      var offsetConf = {};

      if (typeof this._config.offset === 'function') {
        offsetConf.fn = function (data) {
          data.offsets = $.extend({}, data.offsets, _this2._config.offset(data.offsets) || {});
          return data;
        };
      } else {
        offsetConf.offset = this._config.offset;
      }

      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: offsetConf,
          flip: {
            enabled: this._config.flip
          }
        } // Disable Popper.js for Dropdown in Navbar

      };

      if (this._inNavbar) {
        popperConfig.modifiers.applyStyle = {
          enabled: !this._inNavbar
        };
      }

      return popperConfig;
    }; // static


    Dropdown._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    Dropdown._clearMenus = function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = $.makeArray($(Selector.DATA_TOGGLE));

      for (var i = 0; i < toggles.length; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = $(toggles[i]).data(DATA_KEY);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!$(parent).hasClass(ClassName.SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = $.Event(Event.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // if this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          $('body').children().off('mouseover', null, $.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');
        $(dropdownMenu).removeClass(ClassName.SHOW);
        $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement(element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = $(selector)[0];
      }

      return parent || element.parentNode;
    };

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
      if (!REGEXP_KEYDOWN.test(event.which) || /button/i.test(event.target.tagName) && event.which === SPACE_KEYCODE || /input|textarea/i.test(event.target.tagName)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = $(parent).hasClass(ClassName.SHOW);

      if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
        if (event.which === ESCAPE_KEYCODE) {
          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return;
      }

      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();

      if (!items.length) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    createClass(Dropdown, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }]);
    return Dropdown;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + " " + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    event.preventDefault();
    event.stopPropagation();

    Dropdown._jQueryInterface.call($(this), 'toggle');
  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
    e.stopPropagation();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Dropdown._jQueryInterface;
  $.fn[NAME].Constructor = Dropdown;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Dropdown._jQueryInterface;
  };

  return Dropdown;
}($, Popper);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Modal = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'modal';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.modal';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 300;
  var BACKDROP_TRANSITION_DURATION = 150;
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    RESIZE: "resize" + EVENT_KEY,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    DIALOG: '.modal-dialog',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top',
    NAVBAR_TOGGLER: '.navbar-toggler'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = $(element).find(Selector.DIALOG)[0];
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._originalBodyPadding = 0;
      this._scrollbarWidth = 0;
    } // getters


    var _proto = Modal.prototype;

    // public
    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isTransitioning || this._isShown) {
        return;
      }

      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      $(document.body).addClass(ClassName.OPEN);

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (this._isTransitioning || !this._isShown) {
        return;
      }

      var hideEvent = $.Event(Event.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event.FOCUSIN);
      $(this._element).removeClass(ClassName.SHOW);
      $(this._element).off(Event.CLICK_DISMISS);
      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

      if (transition) {
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      $(window, document, this._element, this._backdrop).off(EVENT_KEY);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    }; // private


    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, Default, config);
      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this3 = this;

      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // don't move modals dom position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.scrollTop = 0;

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this3._config.focus) {
          _this3._element.focus();
        }

        _this3._isTransitioning = false;
        $(_this3._element).trigger(shownEvent);
      };

      if (transition) {
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this4 = this;

      $(document).off(Event.FOCUSIN) // guard against infinite focus loop
      .on(Event.FOCUSIN, function (event) {
        if (document !== event.target && _this4._element !== event.target && !$(_this4._element).has(event.target).length) {
          _this4._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this5 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE) {
            event.preventDefault();

            _this5.hide();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this6 = this;

      if (this._isShown) {
        $(window).on(Event.RESIZE, function (event) {
          return _this6.handleUpdate(event);
        });
      } else {
        $(window).off(Event.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this7 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName.OPEN);

        _this7._resetAdjustments();

        _this7._resetScrollbar();

        $(_this7._element).trigger(Event.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this8 = this;

      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

      if (this._isShown && this._config.backdrop) {
        var doAnimate = Util.supportsTransitionEnd() && animate;
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName.BACKDROP;

        if (animate) {
          $(this._backdrop).addClass(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event.CLICK_DISMISS, function (event) {
          if (_this8._ignoreBackdropClick) {
            _this8._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this8._config.backdrop === 'static') {
            _this8._element.focus();
          } else {
            _this8.hide();
          }
        });

        if (doAnimate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName.SHOW);

        if (!callback) {
          return;
        }

        if (!doAnimate) {
          callback();
          return;
        }

        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName.SHOW);

        var callbackRemove = function callbackRemove() {
          _this8._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    }; // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------


    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this9 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        // Adjust fixed content padding
        $(Selector.FIXED_CONTENT).each(function (index, element) {
          var actualPadding = $(element)[0].style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(Selector.STICKY_CONTENT).each(function (index, element) {
          var actualMargin = $(element)[0].style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
        }); // Adjust navbar-toggler margin

        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
          var actualMargin = $(element)[0].style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $('body').css('padding-right');
        $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      $(Selector.FIXED_CONTENT).each(function (index, element) {
        var padding = $(element).data('padding-right');

        if (typeof padding !== 'undefined') {
          $(element).css('padding-right', padding).removeData('padding-right');
        }
      }); // Restore sticky content and navbar-toggler margin

      $(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $('body').data('padding-right');

      if (typeof padding !== 'undefined') {
        $('body').css('padding-right', padding).removeData('padding-right');
      }
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    }; // static


    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = $.extend({}, Modal.Default, $(this).data(), typeof config === 'object' && config);

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);
    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    var _this10 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = $(selector)[0];
    }

    var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event.HIDDEN, function () {
        if ($(_this10).is(':visible')) {
          _this10.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Modal._jQueryInterface;
  $.fn[NAME].Constructor = Modal;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Modal._jQueryInterface;
  };

  return Modal;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Tooltip = function () {
  /**
   * Check for Popper dependency
   * Popper - https://popper.js.org
   */
  if (typeof Popper === 'undefined') {
    throw new Error('Bootstrap tooltips require Popper.js (https://popper.js.org)');
  }
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME = 'tooltip';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.tooltip';
  var EVENT_KEY = "." + DATA_KEY;
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DefaultType = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)'
  };
  var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip'
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    INSERTED: "inserted" + EVENT_KEY,
    CLICK: "click" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    FOCUSOUT: "focusout" + EVENT_KEY,
    MOUSEENTER: "mouseenter" + EVENT_KEY,
    MOUSELEAVE: "mouseleave" + EVENT_KEY
  };
  var ClassName = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      // private
      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // getters


    var _proto = Tooltip.prototype;

    // public
    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal');

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper !== null) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);
        var container = this.config.container === false ? document.body : $(this.config.container);
        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, {
          placement: attachment,
          modifiers: {
            offset: {
              offset: this.config.offset
            },
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Selector.ARROW
            }
          },
          onCreate: function onCreate(data) {
            if (data.originalPlacement !== data.placement) {
              _this._handlePopperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate(data) {
            _this._handlePopperPlacementChange(data);
          }
        });
        $(tip).addClass(ClassName.SHOW); // if this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $('body').children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName.SHOW); // if this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $('body').children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    }; // protected


    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement());
      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      var html = this.config.html;

      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
        // content is a DOM node or a jQuery
        if (html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }
      } else {
        $element[html ? 'html' : 'text'](content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    }; // private


    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this3 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
            return _this3.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {
            return _this3._enter(event);
          }).on(eventOut, _this3.config.selector, function (event) {
            return _this3._leave(event);
          });
        }

        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {
          return _this3.hide();
        });
      });

      if (this.config.selector) {
        this.config = $.extend({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = typeof this.element.getAttribute('data-original-title');

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, this.constructor.Default, $(this.element).data(), config);

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(data.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    }; // static


    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }]);
    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME] = Tooltip._jQueryInterface;
  $.fn[NAME].Constructor = Tooltip;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tooltip._jQueryInterface;
  };

  return Tooltip;
}($, Popper);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Popover = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'popover';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.popover';
  var EVENT_KEY = "." + DATA_KEY;
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var CLASS_PREFIX = 'bs-popover';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var Default = $.extend({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });
  var DefaultType = $.extend({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });
  var ClassName = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    INSERTED: "inserted" + EVENT_KEY,
    CLICK: "click" + EVENT_KEY,
    FOCUSIN: "focusin" + EVENT_KEY,
    FOCUSOUT: "focusout" + EVENT_KEY,
    MOUSEENTER: "mouseenter" + EVENT_KEY,
    MOUSELEAVE: "mouseleave" + EVENT_KEY
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype;

    // overrides
    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // we use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
      this.setElementContent($tip.find(Selector.CONTENT), this._getContent());
      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
    }; // private


    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    }; // static


    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' ? config : null;

        if (!data && /destroy|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    createClass(Popover, null, [{
      key: "VERSION",
      // getters
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType;
      }
    }]);
    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME] = Popover._jQueryInterface;
  $.fn[NAME].Constructor = Popover;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Popover._jQueryInterface;
  };

  return Popover;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var ScrollSpy = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'scrollspy';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.scrollspy';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var Default = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var Event = {
    ACTIVATE: "activate" + EVENT_KEY,
    SCROLL: "scroll" + EVENT_KEY,
    LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    DROPDOWN_ITEM: 'dropdown-item',
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active'
  };
  var Selector = {
    DATA_SPY: '[data-spy="scroll"]',
    ACTIVE: '.active',
    NAV_LIST_GROUP: '.nav, .list-group',
    NAV_LINKS: '.nav-link',
    NAV_ITEMS: '.nav-item',
    LIST_ITEMS: '.list-group-item',
    DROPDOWN: '.dropdown',
    DROPDOWN_ITEMS: '.dropdown-item',
    DROPDOWN_TOGGLE: '.dropdown-toggle'
  };
  var OffsetMethod = {
    OFFSET: 'offset',
    POSITION: 'position'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var ScrollSpy =
  /*#__PURE__*/
  function () {
    function ScrollSpy(element, config) {
      var _this = this;

      this._element = element;
      this._scrollElement = element.tagName === 'BODY' ? window : element;
      this._config = this._getConfig(config);
      this._selector = this._config.target + " " + Selector.NAV_LINKS + "," + (this._config.target + " " + Selector.LIST_ITEMS + ",") + (this._config.target + " " + Selector.DROPDOWN_ITEMS);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      $(this._scrollElement).on(Event.SCROLL, function (event) {
        return _this._process(event);
      });
      this.refresh();

      this._process();
    } // getters


    var _proto = ScrollSpy.prototype;

    // public
    _proto.refresh = function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = $.makeArray($(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = Util.getSelectorFromElement(element);

        if (targetSelector) {
          target = $(targetSelector)[0];
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // todo (fat): remove sketch reliance on jQuery position/offset
            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      $(this._scrollElement).off(EVENT_KEY);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    }; // private


    _proto._getConfig = function _getConfig(config) {
      config = $.extend({}, Default, config);

      if (typeof config.target !== 'string') {
        var id = $(config.target).attr('id');

        if (!id) {
          id = Util.getUID(NAME);
          $(config.target).attr('id', id);
        }

        config.target = "#" + id;
      }

      Util.typeCheckConfig(NAME, config, DefaultType);
      return config;
    };

    _proto._getScrollTop = function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    };

    _proto._getScrollHeight = function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    };

    _proto._getOffsetHeight = function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    };

    _proto._process = function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      for (var i = this._offsets.length; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    };

    _proto._activate = function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style


      queries = queries.map(function (selector) {
        return selector + "[data-target=\"" + target + "\"]," + (selector + "[href=\"" + target + "\"]");
      });
      var $link = $(queries.join(','));

      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
        $link.addClass(ClassName.ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ", " + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
      }

      $(this._scrollElement).trigger(Event.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
    }; // static


    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY);

        var _config = typeof config === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    createClass(ScrollSpy, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);
    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(window).on(Event.LOAD_DATA_API, function () {
    var scrollSpys = $.makeArray($(Selector.DATA_SPY));

    for (var i = scrollSpys.length; i--;) {
      var $spy = $(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = ScrollSpy._jQueryInterface;
  $.fn[NAME].Constructor = ScrollSpy;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return ScrollSpy._jQueryInterface;
  };

  return ScrollSpy;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta.2): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Tab = function () {
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */
  var NAME = 'tab';
  var VERSION = '4.0.0-beta.2';
  var DATA_KEY = 'bs.tab';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var Event = {
    HIDE: "hide" + EVENT_KEY,
    HIDDEN: "hidden" + EVENT_KEY,
    SHOW: "show" + EVENT_KEY,
    SHOWN: "shown" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // getters


    var _proto = Tab.prototype;

    // public
    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = $(selector)[0];
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    }; // private


    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements;

      if (container.nodeName === 'UL') {
        activeElements = $(container).find(Selector.ACTIVE_UL);
      } else {
        activeElements = $(container).children(Selector.ACTIVE);
      }

      var active = activeElements[0];
      var isTransitioning = callback && Util.supportsTransitionEnd() && active && $(active).hasClass(ClassName.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, isTransitioning, callback);
      };

      if (active && isTransitioning) {
        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
      } else {
        complete();
      }

      if (active) {
        $(active).removeClass(ClassName.SHOW);
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {
      if (active) {
        $(active).removeClass(ClassName.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      if (isTransitioning) {
        Util.reflow(element);
        $(element).addClass(ClassName.SHOW);
      } else {
        $(element).removeClass(ClassName.FADE);
      }

      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];

        if (dropdownElement) {
          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    }; // static


    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new Error("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);
    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Tab._jQueryInterface;
  $.fn[NAME].Constructor = Tab;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tab._jQueryInterface;
  };

  return Tab;
}($);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-alpha.6): index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

(function () {
  if (typeof $ === 'undefined') {
    throw new Error('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
  }

  var version = $.fn.jquery.split(' ')[0].split('.');
  var minMajor = 1;
  var ltMajor = 2;
  var minMinor = 9;
  var minPatch = 1;
  var maxMajor = 4;

  if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
    throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
  }
})($);

exports.Util = Util;
exports.Alert = Alert;
exports.Button = Button;
exports.Carousel = Carousel;
exports.Collapse = Collapse;
exports.Dropdown = Dropdown;
exports.Modal = Modal;
exports.Popover = Popover;
exports.Scrollspy = ScrollSpy;
exports.Tab = Tab;
exports.Tooltip = Tooltip;

return exports;

}({},$));
//# sourceMappingURL=bootstrap.bundle.js.map

/*
 * HTML5 Sortable jQuery Plugin
 * http://farhadi.ir/projects/html5sortable
 * 
 * Copyright 2012, Ali Farhadi
 * Released under the MIT license.
 */
(function($) {
  var dragging, placeholders = $();
  $.fn.sortable = function(options) {
    var method = String(options);
    options = $.extend({
      connectWith: false
    }, options);
    return this.each(function() {
      if (/^enable|disable|destroy$/.test(method)) {
        var items = $(this).children($(this).data('items')).attr('draggable', method == 'enable');
        if (method == 'destroy') {
          items.add(this).removeData('connectWith items')
          .off('dragstart.h5s dragend.h5s selectstart.h5s dragover.h5s dragenter.h5s drop.h5s');
        }
        return;
      }
      var isHandle, index, items = $(this).children(options.items);
      var placeholder = $('<' + (/^ul|ol$/i.test(this.tagName) ? 'li' : 'div') + ' class="sortable-placeholder">');
      items.find(options.handle).mousedown(function() {
        isHandle = true;
      }).mouseup(function() {
        isHandle = false;
      });
      $(this).data('items', options.items)
      placeholders = placeholders.add(placeholder);
      if (options.connectWith) {
        $(options.connectWith).add(this).data('connectWith', options.connectWith);
      }
      items.attr('draggable', 'true').on('dragstart.h5s', function(e) {
        if (options.handle && !isHandle) {
//          return false;
        }
        isHandle = false;
        var w = $(this).css('width');
        var h = $(this).css('height');
        var m = $(this).css('margin');
        var dt = e.originalEvent.dataTransfer;
        placeholder.css('width', w);
        placeholder.css('height', h);
        placeholder.css('margin', m);
        dt.effectAllowed = 'move';
        dt.setData('Text', 'localhost');
        index = (dragging = $(this)).addClass('sortable-dragging').index();
      }).on('dragend.h5s', function() {
        try {
          dragging.removeClass('sortable-dragging').show();
          placeholders.detach();
          if (index != dragging.index()) {
            items.parent().trigger('sortupdate', {
              item: dragging
            });
          }
          dragging = null;
        } catch(e) {}
      }).not('a[href], img').on('selectstart.h5s', function() {
        this.dragDrop && this.dragDrop();
//        return false;
      }).end().add([this, placeholder]).on('dragover.h5s dragenter.h5s drop.h5s', function(e) {
        if (!items.is(dragging) && options.connectWith !== $(dragging).parent().data('connectWith')) {
          return true;
        }
        if (e.type == 'drop') {
//          e.stopPropagation();
          placeholders.filter(':visible').after(dragging);
//          return false;
        }
        e.preventDefault();
        e.originalEvent.dataTransfer.dropEffect = 'move';
        if (items.is(this)) {
          if (options.forcePlaceholderSize) {
            placeholder.height(dragging.outerHeight());
          }
          dragging.hide();
          $(this)[placeholder.index() < $(this).index() ? 'after' : 'before'](placeholder);
          placeholders.not(placeholder).detach();
        } else if (!placeholders.is(this) && !$(this).children(options.items).length) {
          placeholders.detach();
          $(this).append(placeholder);
        }
//        return false;
      });
    });
  };
})(jQuery);

(function(e){"use strict";var t=function(e,i,a){var n,r,o=document.createElement("img");if(o.onerror=i,o.onload=function(){!r||a&&a.noRevoke||t.revokeObjectURL(r),i&&i(t.scale(o,a))},t.isInstanceOf("Blob",e)||t.isInstanceOf("File",e))n=r=t.createObjectURL(e),o._type=e.type;else{if("string"!=typeof e)return!1;n=e,a&&a.crossOrigin&&(o.crossOrigin=a.crossOrigin)}return n?(o.src=n,o):t.readFile(e,function(e){var t=e.target;t&&t.result?o.src=t.result:i&&i(e)})},i=window.createObjectURL&&window||window.URL&&URL.revokeObjectURL&&URL||window.webkitURL&&webkitURL;t.isInstanceOf=function(e,t){return Object.prototype.toString.call(t)==="[object "+e+"]"},t.transformCoordinates=function(e,t){var i=e.getContext("2d"),a=e.width,n=e.height;switch(t>4&&(e.width=n,e.height=a),t){case 2:i.translate(a,0),i.scale(-1,1);break;case 3:i.translate(a,n),i.rotate(Math.PI);break;case 4:i.translate(0,n),i.scale(1,-1);break;case 5:i.rotate(.5*Math.PI),i.scale(1,-1);break;case 6:i.rotate(.5*Math.PI),i.translate(0,-n);break;case 7:i.rotate(.5*Math.PI),i.translate(a,-n),i.scale(-1,1);break;case 8:i.rotate(-.5*Math.PI),i.translate(-a,0)}},t.renderImageToCanvas=function(e,t,i,a,n,r,o,s,d,l){return e.getContext("2d").drawImage(t,i,a,n,r,o,s,d,l),e},t.scale=function(e,i){i=i||{};var a,n,r,o,s,d,l=document.createElement("canvas"),c=e.getContext||(i.canvas||i.crop||i.orientation)&&l.getContext,u=e.width,g=e.height,f=u,h=g,m=0,p=0,S=0,x=0,y=function(){var e=Math.max((r||s)/s,(o||d)/d);e>1&&(s=Math.ceil(s*e),d=Math.ceil(d*e))},b=function(){var e=Math.min((a||s)/s,(n||d)/d);1>e&&(s=Math.ceil(s*e),d=Math.ceil(d*e))};return c&&i.orientation>4?(a=i.maxHeight,n=i.maxWidth,r=i.minHeight,o=i.minWidth):(a=i.maxWidth,n=i.maxHeight,r=i.minWidth,o=i.minHeight),c&&a&&n&&i.crop?(s=a,d=n,a/n>u/g?(h=n*u/a,p=(g-h)/2):(f=a*g/n,m=(u-f)/2)):((i.contain||i.cover)&&(r=a=a||r,o=n=n||o),s=u,d=g,i.cover?(b(),y()):(y(),b())),c?(l.width=s,l.height=d,t.transformCoordinates(l,i.orientation),t.renderImageToCanvas(l,e,m,p,f,h,S,x,s,d)):(e.width=s,e.height=d,e)},t.createObjectURL=function(e){return i?i.createObjectURL(e):!1},t.revokeObjectURL=function(e){return i?i.revokeObjectURL(e):!1},t.readFile=function(e,t,i){if(window.FileReader){var a=new FileReader;if(a.onload=a.onerror=t,i=i||"readAsDataURL",a[i])return a[i](e),a}return!1},"function"==typeof define&&define.amd?define(function(){return t}):e.loadImage=t})(this),function(e){"use strict";"function"==typeof define&&define.amd?define(["load-image"],e):e(window.loadImage)}(function(e){"use strict";if(window.navigator&&window.navigator.platform&&/iP(hone|od|ad)/.test(window.navigator.platform)){var t=e.renderImageToCanvas;e.detectSubsampling=function(e){var t,i;return e.width*e.height>1048576?(t=document.createElement("canvas"),t.width=t.height=1,i=t.getContext("2d"),i.drawImage(e,-e.width+1,0),0===i.getImageData(0,0,1,1).data[3]):!1},e.detectVerticalSquash=function(e,t){var i,a,n,r,o,s=document.createElement("canvas"),d=s.getContext("2d");for(s.width=1,s.height=t,d.drawImage(e,0,0),i=d.getImageData(0,0,1,t).data,a=0,n=t,r=t;r>a;)o=i[4*(r-1)+3],0===o?n=r:a=r,r=n+a>>1;return r/t||1},e.renderImageToCanvas=function(i,a,n,r,o,s,d,l,c,u){if("image/jpeg"===a._type){var g,f,h,m,p=i.getContext("2d"),S=document.createElement("canvas"),x=1024,y=S.getContext("2d");if(S.width=x,S.height=x,p.save(),g=e.detectSubsampling(a),g&&(o/=2,s/=2),f=e.detectVerticalSquash(a,s),g&&1!==f){for(c=Math.ceil(x*c/o),u=Math.ceil(x*u/s/f),l=0,m=0;s>m;){for(d=0,h=0;o>h;)y.clearRect(0,0,x,x),y.drawImage(a,n,r,o,s,-h,-m,o,s),p.drawImage(S,0,0,x,x,d,l,c,u),h+=x,d+=c;m+=x,l+=u}return p.restore(),i}}return t(i,a,n,r,o,s,d,l,c,u)}}}),function(e){"use strict";"function"==typeof define&&define.amd?define(["load-image"],e):e(window.loadImage)}(function(e){"use strict";var t=window.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice);e.blobSlice=t&&function(){var e=this.slice||this.webkitSlice||this.mozSlice;return e.apply(this,arguments)},e.metaDataParsers={jpeg:{65505:[]}},e.parseMetaData=function(t,i,a){a=a||{};var n=this,r=a.maxMetaDataSize||262144,o={},s=!(window.DataView&&t&&t.size>=12&&"image/jpeg"===t.type&&e.blobSlice);(s||!e.readFile(e.blobSlice.call(t,0,r),function(t){var r,s,d,l,c=t.target.result,u=new DataView(c),g=2,f=u.byteLength-4,h=g;if(65496===u.getUint16(0)){for(;f>g&&(r=u.getUint16(g),r>=65504&&65519>=r||65534===r);){if(s=u.getUint16(g+2)+2,g+s>u.byteLength){console.log("Invalid meta data: Invalid segment size.");break}if(d=e.metaDataParsers.jpeg[r])for(l=0;d.length>l;l+=1)d[l].call(n,u,g,s,o,a);g+=s,h=g}!a.disableImageHead&&h>6&&(o.imageHead=c.slice?c.slice(0,h):new Uint8Array(c).subarray(0,h))}else console.log("Invalid JPEG file: Missing JPEG marker.");i(o)},"readAsArrayBuffer"))&&i(o)}}),function(e){"use strict";"function"==typeof define&&define.amd?define(["load-image","load-image-meta"],e):e(window.loadImage)}(function(e){"use strict";e.ExifMap=function(){return this},e.ExifMap.prototype.map={Orientation:274},e.ExifMap.prototype.get=function(e){return this[e]||this[this.map[e]]},e.getExifThumbnail=function(e,t,i){var a,n,r;if(!i||t+i>e.byteLength)return console.log("Invalid Exif data: Invalid thumbnail data."),void 0;for(a=[],n=0;i>n;n+=1)r=e.getUint8(t+n),a.push((16>r?"0":"")+r.toString(16));return"data:image/jpeg,%"+a.join("%")},e.exifTagTypes={1:{getValue:function(e,t){return e.getUint8(t)},size:1},2:{getValue:function(e,t){return String.fromCharCode(e.getUint8(t))},size:1,ascii:!0},3:{getValue:function(e,t,i){return e.getUint16(t,i)},size:2},4:{getValue:function(e,t,i){return e.getUint32(t,i)},size:4},5:{getValue:function(e,t,i){return e.getUint32(t,i)/e.getUint32(t+4,i)},size:8},9:{getValue:function(e,t,i){return e.getInt32(t,i)},size:4},10:{getValue:function(e,t,i){return e.getInt32(t,i)/e.getInt32(t+4,i)},size:8}},e.exifTagTypes[7]=e.exifTagTypes[1],e.getExifValue=function(t,i,a,n,r,o){var s,d,l,c,u,g,f=e.exifTagTypes[n];if(!f)return console.log("Invalid Exif data: Invalid tag type."),void 0;if(s=f.size*r,d=s>4?i+t.getUint32(a+8,o):a+8,d+s>t.byteLength)return console.log("Invalid Exif data: Invalid data offset."),void 0;if(1===r)return f.getValue(t,d,o);for(l=[],c=0;r>c;c+=1)l[c]=f.getValue(t,d+c*f.size,o);if(f.ascii){for(u="",c=0;l.length>c&&(g=l[c],"\0"!==g);c+=1)u+=g;return u}return l},e.parseExifTag=function(t,i,a,n,r){var o=t.getUint16(a,n);r.exif[o]=e.getExifValue(t,i,a,t.getUint16(a+2,n),t.getUint32(a+4,n),n)},e.parseExifTags=function(e,t,i,a,n){var r,o,s;if(i+6>e.byteLength)return console.log("Invalid Exif data: Invalid directory offset."),void 0;if(r=e.getUint16(i,a),o=i+2+12*r,o+4>e.byteLength)return console.log("Invalid Exif data: Invalid directory size."),void 0;for(s=0;r>s;s+=1)this.parseExifTag(e,t,i+2+12*s,a,n);return e.getUint32(o,a)},e.parseExifData=function(t,i,a,n,r){if(!r.disableExif){var o,s,d,l=i+10;if(1165519206===t.getUint32(i+4)){if(l+8>t.byteLength)return console.log("Invalid Exif data: Invalid segment size."),void 0;if(0!==t.getUint16(i+8))return console.log("Invalid Exif data: Missing byte alignment offset."),void 0;switch(t.getUint16(l)){case 18761:o=!0;break;case 19789:o=!1;break;default:return console.log("Invalid Exif data: Invalid byte alignment marker."),void 0}if(42!==t.getUint16(l+2,o))return console.log("Invalid Exif data: Missing TIFF marker."),void 0;s=t.getUint32(l+4,o),n.exif=new e.ExifMap,s=e.parseExifTags(t,l,l+s,o,n),s&&!r.disableExifThumbnail&&(d={exif:{}},s=e.parseExifTags(t,l,l+s,o,d),d.exif[513]&&(n.exif.Thumbnail=e.getExifThumbnail(t,l+d.exif[513],d.exif[514]))),n.exif[34665]&&!r.disableExifSub&&e.parseExifTags(t,l,l+n.exif[34665],o,n),n.exif[34853]&&!r.disableExifGps&&e.parseExifTags(t,l,l+n.exif[34853],o,n)}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData)}),function(e){"use strict";"function"==typeof define&&define.amd?define(["load-image","load-image-exif"],e):e(window.loadImage)}(function(e){"use strict";var t,i,a;e.ExifMap.prototype.tags={256:"ImageWidth",257:"ImageHeight",34665:"ExifIFDPointer",34853:"GPSInfoIFDPointer",40965:"InteroperabilityIFDPointer",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},e.ExifMap.prototype.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"top-left",2:"top-right",3:"bottom-right",4:"bottom-left",5:"left-top",6:"right-top",7:"right-bottom",8:"left-bottom"}},e.ExifMap.prototype.getText=function(e){var t=this.get(e);switch(e){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[e][t];case"ExifVersion":case"FlashpixVersion":return String.fromCharCode(t[0],t[1],t[2],t[3]);case"ComponentsConfiguration":return this.stringValues[e][t[0]]+this.stringValues[e][t[1]]+this.stringValues[e][t[2]]+this.stringValues[e][t[3]];case"GPSVersionID":return t[0]+"."+t[1]+"."+t[2]+"."+t[3]}return t+""},t=e.ExifMap.prototype.tags,i=e.ExifMap.prototype.map;for(a in t)t.hasOwnProperty(a)&&(i[t[a]]=a);e.ExifMap.prototype.getAll=function(){var e,i,a={};for(e in this)this.hasOwnProperty(e)&&(i=t[e],i&&(a[i]=this.getText(i)));return a}});
/*
 * jQuery File Upload Plugin Localization Example 6.5
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

window.locale = {
    "fileupload": {
        "errors": {
            "maxFileSize": "File is too big",
            "minFileSize": "File is too small",
            "acceptFileTypes": "Filetype not allowed",
            "maxNumberOfFiles": "Max number of files exceeded",
            "uploadedBytes": "Uploaded bytes exceed file size",
            "emptyResult": "Empty file upload result"
        },
        "error": "Error",
        "start": "Start",
        "cancel": "Cancel",
        "destroy": "Delete"
    }
};

/*
 * JavaScript Templates 2.2.0
 * https://github.com/blueimp/JavaScript-Templates
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Inspired by John Resig's JavaScript Micro-Templating:
 * http://ejohn.org/blog/javascript-micro-templating/
 */

/*jslint evil: true, regexp: true */
/*global document, define */

(function ($) {
    "use strict";
    var tmpl = function (str, data) {
        var f = !/[^\w\-\.:]/.test(str) ? tmpl.cache[str] = tmpl.cache[str] ||
                tmpl(tmpl.load(str)) :
                    new Function(
                        tmpl.arg + ',tmpl',
                        "var _e=tmpl.encode" + tmpl.helper + ",_s='" +
                            str.replace(tmpl.regexp, tmpl.func) +
                            "';return _s;"
                    );
        return data ? f(data, tmpl) : function (data) {
            return f(data, tmpl);
        };
    };
    tmpl.cache = {};
    tmpl.load = function (id) {
        return document.getElementById(id).innerHTML;
    };
    tmpl.regexp = /([\s'\\])(?![^%]*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g;
    tmpl.func = function (s, p1, p2, p3, p4, p5) {
        if (p1) { // whitespace, quote and backspace in interpolation context
            return {
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t",
                " " : " "
            }[s] || "\\" + s;
        }
        if (p2) { // interpolation: {%=prop%}, or unescaped: {%#prop%}
            if (p2 === "=") {
                return "'+_e(" + p3 + ")+'";
            }
            return "'+" + p3 + "+'";
        }
        if (p4) { // evaluation start tag: {%
            return "';";
        }
        if (p5) { // evaluation end tag: %}
            return "_s+='";
        }
    };
    tmpl.encReg = /[<>&"'\x00]/g;
    tmpl.encMap = {
        "<"   : "&lt;",
        ">"   : "&gt;",
        "&"   : "&amp;",
        "\""  : "&quot;",
        "'"   : "&#39;"
    };
    tmpl.encode = function (s) {
        return String(s).replace(
            tmpl.encReg,
            function (c) {
                return tmpl.encMap[c] || "";
            }
        );
    };
    tmpl.arg = "o";
    tmpl.helper = ",print=function(s,e){_s+=e&&(s||'')||_e(s);}" +
        ",include=function(s,d){_s+=tmpl(s,d);}";
    if (typeof define === "function" && define.amd) {
        define(function () {
            return tmpl;
        });
    } else {
        $.tmpl = tmpl;
    }
}(this));

/*
 * JavaScript Canvas to Blob 2.0.5
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */

/*jslint nomen: true, regexp: true */
/*global window, atob, Blob, ArrayBuffer, Uint8Array, define */

(function (window) {
    'use strict';
    var CanvasPrototype = window.HTMLCanvasElement &&
            window.HTMLCanvasElement.prototype,
        hasBlobConstructor = window.Blob && (function () {
            try {
                return Boolean(new Blob());
            } catch (e) {
                return false;
            }
        }()),
        hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array &&
            (function () {
                try {
                    return new Blob([new Uint8Array(100)]).size === 100;
                } catch (e) {
                    return false;
                }
            }()),
        BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder ||
            window.MozBlobBuilder || window.MSBlobBuilder,
        dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob &&
            window.ArrayBuffer && window.Uint8Array && function (dataURI) {
                var byteString,
                    arrayBuffer,
                    intArray,
                    i,
                    mimeString,
                    bb;
                if (dataURI.split(',')[0].indexOf('base64') >= 0) {
                    // Convert base64 to raw binary data held in a string:
                    byteString = atob(dataURI.split(',')[1]);
                } else {
                    // Convert base64/URLEncoded data component to raw binary data:
                    byteString = decodeURIComponent(dataURI.split(',')[1]);
                }
                // Write the bytes of the string to an ArrayBuffer:
                arrayBuffer = new ArrayBuffer(byteString.length);
                intArray = new Uint8Array(arrayBuffer);
                for (i = 0; i < byteString.length; i += 1) {
                    intArray[i] = byteString.charCodeAt(i);
                }
                // Separate out the mime component:
                mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                // Write the ArrayBuffer (or ArrayBufferView) to a blob:
                if (hasBlobConstructor) {
                    return new Blob(
                        [hasArrayBufferViewSupport ? intArray : arrayBuffer],
                        {type: mimeString}
                    );
                }
                bb = new BlobBuilder();
                bb.append(arrayBuffer);
                return bb.getBlob(mimeString);
            };
    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
        if (CanvasPrototype.mozGetAsFile) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
                    callback(dataURLtoBlob(this.toDataURL(type, quality)));
                } else {
                    callback(this.mozGetAsFile('blob', type));
                }
            };
        } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
            CanvasPrototype.toBlob = function (callback, type, quality) {
                callback(dataURLtoBlob(this.toDataURL(type, quality)));
            };
        }
    }
    if (typeof define === 'function' && define.amd) {
        define(function () {
            return dataURLtoBlob;
        });
    } else {
        window.dataURLtoBlob = dataURLtoBlob;
    }
}(this));

/*
 * jQuery Iframe Transport Plugin 1.7
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true, nomen: true */
/*global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['jquery'], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // Helper variable to create unique names for the transport iframes:
    var counter = 0;

    // The iframe transport accepts three additional options:
    // options.fileInput: a jQuery collection of file input fields
    // options.paramName: the parameter name for the file form data,
    //  overrides the name property of the file input field(s),
    //  can be a string or an array of strings.
    // options.formData: an array of objects with name and value properties,
    //  equivalent to the return data of .serializeArray(), e.g.:
    //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
    $.ajaxTransport('iframe', function (options) {
        if (options.async) {
            var form,
                iframe,
                addParamChar;
            return {
                send: function (_, completeCallback) {
                    form = $('<form style="display:none;"></form>');
                    form.attr('accept-charset', options.formAcceptCharset);
                    addParamChar = /\?/.test(options.url) ? '&' : '?';
                    // XDomainRequest only supports GET and POST:
                    if (options.type === 'DELETE') {
                        options.url = options.url + addParamChar + '_method=DELETE';
                        options.type = 'POST';
                    } else if (options.type === 'PUT') {
                        options.url = options.url + addParamChar + '_method=PUT';
                        options.type = 'POST';
                    } else if (options.type === 'PATCH') {
                        options.url = options.url + addParamChar + '_method=PATCH';
                        options.type = 'POST';
                    }
                    // javascript:false as initial iframe src
                    // prevents warning popups on HTTPS in IE6.
                    // IE versions below IE8 cannot set the name property of
                    // elements that have already been added to the DOM,
                    // so we set the name along with the iframe HTML markup:
                    counter += 1;
                    iframe = $(
                        '<iframe src="javascript:false;" name="iframe-transport-' +
                            counter + '"></iframe>'
                    ).bind('load', function () {
                        var fileInputClones,
                            paramNames = $.isArray(options.paramName) ?
                                    options.paramName : [options.paramName];
                        iframe
                            .unbind('load')
                            .bind('load', function () {
                                var response;
                                // Wrap in a try/catch block to catch exceptions thrown
                                // when trying to access cross-domain iframe contents:
                                try {
                                    response = iframe.contents();
                                    // Google Chrome and Firefox do not throw an
                                    // exception when calling iframe.contents() on
                                    // cross-domain requests, so we unify the response:
                                    if (!response.length || !response[0].firstChild) {
                                        throw new Error();
                                    }
                                } catch (e) {
                                    response = undefined;
                                }
                                // The complete callback returns the
                                // iframe content document as response object:
                                completeCallback(
                                    200,
                                    'success',
                                    {'iframe': response}
                                );
                                // Fix for IE endless progress bar activity bug
                                // (happens on form submits to iframe targets):
                                $('<iframe src="javascript:false;"></iframe>')
                                    .appendTo(form);
                                window.setTimeout(function () {
                                    // Removing the form in a setTimeout call
                                    // allows Chrome's developer tools to display
                                    // the response result
                                    form.remove();
                                }, 0);
                            });
                        form
                            .prop('target', iframe.prop('name'))
                            .prop('action', options.url)
                            .prop('method', options.type);
                        if (options.formData) {
                            $.each(options.formData, function (index, field) {
                                $('<input type="hidden"/>')
                                    .prop('name', field.name)
                                    .val(field.value)
                                    .appendTo(form);
                            });
                        }
                        if (options.fileInput && options.fileInput.length &&
                                options.type === 'POST') {
                            fileInputClones = options.fileInput.clone();
                            // Insert a clone for each file input field:
                            options.fileInput.after(function (index) {
                                return fileInputClones[index];
                            });
                            if (options.paramName) {
                                options.fileInput.each(function (index) {
                                    $(this).prop(
                                        'name',
                                        paramNames[index] || options.paramName
                                    );
                                });
                            }
                            // Appending the file input fields to the hidden form
                            // removes them from their original location:
                            form
                                .append(options.fileInput)
                                .prop('enctype', 'multipart/form-data')
                                // enctype must be set as encoding for IE:
                                .prop('encoding', 'multipart/form-data');
                        }
                        form.submit();
                        // Insert the file input fields at their original location
                        // by replacing the clones with the originals:
                        if (fileInputClones && fileInputClones.length) {
                            options.fileInput.each(function (index, input) {
                                var clone = $(fileInputClones[index]);
                                $(input).prop('name', clone.prop('name'));
                                clone.replaceWith(input);
                            });
                        }
                    });
                    form.append(iframe).appendTo(document.body);
                },
                abort: function () {
                    if (iframe) {
                        // javascript:false as iframe src aborts the request
                        // and prevents warning popups on HTTPS in IE6.
                        // concat is used to avoid the "Script URL" JSLint error:
                        iframe
                            .unbind('load')
                            .prop('src', 'javascript'.concat(':false;'));
                    }
                    if (form) {
                        form.remove();
                    }
                }
            };
        }
    });

    // The iframe transport returns the iframe content document as response.
    // The following adds converters from iframe to text, json, html, xml
    // and script.
    // Please note that the Content-Type for JSON responses has to be text/plain
    // or text/html, if the browser doesn't include application/json in the
    // Accept header, else IE will show a download dialog.
    // The Content-Type for XML responses on the other hand has to be always
    // application/xml or text/xml, so IE properly parses the XML response.
    // See also
    // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
    $.ajaxSetup({
        converters: {
            'iframe text': function (iframe) {
                return iframe && $(iframe[0].body).text();
            },
            'iframe json': function (iframe) {
                return iframe && $.parseJSON($(iframe[0].body).text());
            },
            'iframe html': function (iframe) {
                return iframe && $(iframe[0].body).html();
            },
            'iframe xml': function (iframe) {
                var xmlDoc = iframe && iframe[0];
                return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc :
                        $.parseXML((xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml) ||
                            $(xmlDoc.body).html());
            },
            'iframe script': function (iframe) {
                return iframe && $.globalEval($(iframe[0].body).text());
            }
        }
    });

}));

/*
 * jQuery File Upload Plugin 5.31.6
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, location, File, Blob, FormData */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'jquery.ui.widget'
        ], factory);
    } else {
        // Browser globals:
        factory(window.jQuery);
    }
}(function ($) {
    'use strict';

    // The FileReader API is not actually used, but works as feature detection,
    // as e.g. Safari supports XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads:
    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // Detect support for Blob slicing (required for chunked uploads):
    $.support.blobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Error and info messages:
            messages: {
                uploadedBytes: 'Uploaded bytes exceed file size'
            },

            // Translation function, gets the message key to be translated
            // and an object with context specific data as arguments:
            i18n: function (message, context) {
                message = this.messages[message] || message.toString();
                if (context) {
                    $.each(context, function (key, value) {
                        message = message.replace('{' + key + '}', value);
                    });
                }
                return message;
            },

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uploads, else
            // once for each file selection.
            //
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows you to override plugin options as well as define ajax settings.
            //
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            //
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                if (data.autoUpload || (data.autoUpload !== false &&
                        $(this).fileupload('option', 'autoUpload'))) {
                    data.process().done(function () {
                        data.submit();
                    });
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require reinitializing event listeners and/or
        // special initialization code:
        _specialOptions: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _blobSlice: $.support.blobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice;
            return slice.apply(this, arguments);
        },

        _BitrateTimer: function () {
            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if (typeof options.formData === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if ($.type(options.formData) === 'object') {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            var progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
            if (obj._progress) {
                $.extend(obj._progress, progress);
            } else {
                obj._progress = progress;
            }
        },

        _initResponseObject: function (obj) {
            var prop;
            if (obj._response) {
                for (prop in obj._response) {
                    if (obj._response.hasOwnProperty(prop)) {
                        delete obj._response[prop];
                    }
                }
            } else {
                obj._response = {};
            }
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger('progress', e, data);
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger('progressall', e, this._progress);
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _isInstanceOf: function (type, obj) {
            // Cross-frame instanceof check
            return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        },

        _initXHRData: function (options) {
            var that = this,
                formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = options.paramName[0];
            options.headers = options.headers || {};
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
            }
            if (!multipart) {
                options.contentType = file.type;
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: options.paramName[index] || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (that._isInstanceOf('FormData', options.formData)) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // This check allows the tests to run with
                            // dummy objects:
                            if (that._isInstanceOf('File', file) ||
                                    that._isInstanceOf('Blob', file)) {
                                formData.append(
                                    options.paramName[index] || paramName,
                                    file,
                                    file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            var targetHost = $('<a></a>').prop('href', options.url).prop('host');
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && targetHost && targetHost !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options);
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type || options.form.prop('method') || '')
                .toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the data callback argument:
        _addConvenienceMethods: function (e, data) {
            var that = this,
                getPromise = function (data) {
                    return $.Deferred().resolveWith(that, [data]).promise();
                };
            data.process = function (resolveFunc, rejectFunc) {
                if (resolveFunc || rejectFunc) {
                    data._processQueue = this._processQueue =
                        (this._processQueue || getPromise(this))
                            .pipe(resolveFunc, rejectFunc);
                }
                return this._processQueue || getPromise(this);
            };
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger('submit', e, this) !== false) &&
                        that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                return that._getXHRPromise();
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
                if (this._processQueue) {
                    return that._getDeferredState(this._processQueue);
                }
            };
            data.progress = function () {
                return this._progress;
            };
            data.response = function () {
                return this._response;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            options.uploadedBytes = options.uploadedBytes || 0;
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes,
                mcs = options.maxChunkSize || fs,
                slice = this._blobSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = options.i18n('uploadedBytes');
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function () {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (currentLoaded + o.chunkSize - o._progress.loaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            // Make sure the container objects for the .response() and
            // .progress() methods on the data object are available
            // and reset to their initial state:
            this._initResponseObject(data);
            this._initProgressObject(data);
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total,
                response = options._response;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            response.result = options.result = result;
            response.textStatus = options.textStatus = textStatus;
            response.jqXHR = options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            var response = options._response;
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
            response.jqXHR = options.jqXHR = jqXHR;
            response.textStatus = options.textStatus = textStatus;
            response.errorThrown = options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._trigger('always', null, options);
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger('send', e, options) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        that._sending -= 1;
                        that._active -= 1;
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                        if (that._active === 0) {
                            // The stop callback is triggered when all uploads have
                            // been completed, equivalent to the global ajaxStop event:
                            that._trigger('stop');
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    this._sequence = this._sequence.pipe(send, send);
                    pipe = this._sequence;
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                limit = options.limitMultiFileUploads,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i;
            if (!(options.singleFileUploads || limit) ||
                    !this._isXHRUpload(options)) {
                fileSet = [data.files];
                paramNameSet = [paramName];
            } else if (!options.singleFileUploads && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < data.files.length; i += limit) {
                    fileSet.push(data.files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = data.files;
            $.each(fileSet || data.files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initResponseObject(newData);
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger('add', e, newData);
                return result;
            });
            return result;
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger('change', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var items = e.originalEvent && e.originalEvent.clipboardData &&
                    e.originalEvent.clipboardData.items,
                data = {files: []};
            if (items && items.length) {
                $.each(items, function (index, item) {
                    var file = item.getAsFile && item.getAsFile();
                    if (file) {
                        data.files.push(file);
                    }
                });
                if (this._trigger('paste', e, data) === false ||
                        this._onAdd(e, data) === false) {
                    return false;
                }
            }
        },

        _onDrop: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var that = this,
                dataTransfer = e.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
                this._getDroppedFiles(dataTransfer).always(function (files) {
                    data.files = files;
                    if (that._trigger('drop', e, data) !== false) {
                        that._onAdd(e, data);
                    }
                });
            }
        },

        _onDragOver: function (e) {
            e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
            var dataTransfer = e.dataTransfer;
            if (dataTransfer) {
                if (this._trigger('dragover', e) === false) {
                    return false;
                }
                if ($.inArray('Files', dataTransfer.types) !== -1) {
                    dataTransfer.dropEffect = 'copy';
                    e.preventDefault();
                }
            }
        },

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            this._on(this.options.fileInput, {
                change: this._onChange
            });
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var reinit = $.inArray(key, this._specialOptions) !== -1;
            if (reinit) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (reinit) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _getRegExp: function (str) {
            var parts = str.split('/'),
                modifiers = parts.pop();
            parts.shift();
            return new RegExp(parts.join('/'), modifiers);
        },

        _isRegExpOption: function (key, value) {
            return key !== 'url' && $.type(value) === 'string' &&
                /^\/.*\/[igm]{0,3}$/.test(value);
        },

        _initDataAttributes: function () {
            var that = this,
                options = this.options;
            // Initialize options set via HTML5 data-attributes:
            $.each(
                $(this.element[0].cloneNode(false)).data(),
                function (key, value) {
                    if (that._isRegExpOption(key, value)) {
                        value = that._getRegExp(value);
                    }
                    options[key] = value;
                }
            );
        },

        _create: function () {
            this._initDataAttributes();
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the number of active uploads:
        active: function () {
            return this._active;
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function () {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));

/*
 * jQuery File Upload Processing Plugin 1.2.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true */
/*global define, window */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            './jquery.fileupload'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery
        );
    }
}(function ($) {
    'use strict';

    var originalAdd = $.blueimp.fileupload.prototype.options.add;

    // The File Upload Processing plugin extends the fileupload widget
    // with file processing functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // The list of processing actions:
            processQueue: [
                /*
                {
                    action: 'log',
                    type: 'debug'
                }
                */
            ],
            add: function (e, data) {
                var $this = $(this);
                data.process(function () {
                    return $this.fileupload('process', data);
                });
                originalAdd.call(this, e, data);
            }
        },

        processActions: {
            /*
            log: function (data, options) {
                console[options.type](
                    'Processing "' + data.files[data.index].name + '"'
                );
            }
            */
        },

        _processFile: function (data) {
            var that = this,
                dfd = $.Deferred().resolveWith(that, [data]),
                chain = dfd.promise();
            this._trigger('process', null, data);
            $.each(data.processQueue, function (i, settings) {
                var func = function (data) {
                    return that.processActions[settings.action].call(
                        that,
                        data,
                        settings
                    );
                };
                chain = chain.pipe(func, settings.always && func);
            });
            chain
                .done(function () {
                    that._trigger('processdone', null, data);
                    that._trigger('processalways', null, data);
                })
                .fail(function () {
                    that._trigger('processfail', null, data);
                    that._trigger('processalways', null, data);
                });
            return chain;
        },

        // Replaces the settings of each processQueue item that
        // are strings starting with an "@", using the remaining
        // substring as key for the option map,
        // e.g. "@autoUpload" is replaced with options.autoUpload:
        _transformProcessQueue: function (options) {
            var processQueue = [];
            $.each(options.processQueue, function () {
                var settings = {},
                    action = this.action,
                    prefix = this.prefix === true ? action : this.prefix;
                $.each(this, function (key, value) {
                    if ($.type(value) === 'string' &&
                            value.charAt(0) === '@') {
                        settings[key] = options[
                            value.slice(1) || (prefix ? prefix +
                                key.charAt(0).toUpperCase() + key.slice(1) : key)
                        ];
                    } else {
                        settings[key] = value;
                    }

                });
                processQueue.push(settings);
            });
            options.processQueue = processQueue;
        },

        // Returns the number of files currently in the processsing queue:
        processing: function () {
            return this._processing;
        },

        // Processes the files given as files property of the data parameter,
        // returns a Promise object that allows to bind callbacks:
        process: function (data) {
            var that = this,
                options = $.extend({}, this.options, data);
            if (options.processQueue && options.processQueue.length) {
                this._transformProcessQueue(options);
                if (this._processing === 0) {
                    this._trigger('processstart');
                }
                $.each(data.files, function (index) {
                    var opts = index ? $.extend({}, options) : options,
                        func = function () {
                            return that._processFile(opts);
                        };
                    opts.index = index;
                    that._processing += 1;
                    that._processingQueue = that._processingQueue.pipe(func, func)
                        .always(function () {
                            that._processing -= 1;
                            if (that._processing === 0) {
                                that._trigger('processstop');
                            }
                        });
                });
            }
            return this._processingQueue;
        },

        _create: function () {
            this._super();
            this._processing = 0;
            this._processingQueue = $.Deferred().resolveWith(this)
                .promise();
        }

    });

}));

/*
 * jQuery File Upload Image Preview & Resize Plugin 1.2.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, DataView, Blob, Uint8Array */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'load-image',
            'load-image-meta',
            'load-image-exif',
            'load-image-ios',
            'canvas-to-blob',
            './jquery.fileupload-process'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    // Prepend to the default processQueue:
    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadImageMetaData',
            // Always trigger this action,
            // even if the previous action was rejected: 
            always: true,
            disableImageHead: '@',
            disableExif: '@',
            disableExifThumbnail: '@',
            disableExifSub: '@',
            disableExifGps: '@',
            disabled: '@disableImageMetaDataLoad'
        },
        {
            action: 'loadImage',
            // Use the action as prefix for the "@" options:
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            noRevoke: '@',
            disabled: '@disableImageLoad'
        },
        {
            action: 'resizeImage',
            // Use "image" as prefix for the "@" options:
            prefix: 'image',
            maxWidth: '@',
            maxHeight: '@',
            minWidth: '@',
            minHeight: '@',
            crop: '@',
            disabled: '@disableImageResize'
        },
        {
            action: 'saveImage',
            disabled: '@disableImageResize'
        },
        {
            action: 'saveImageMetaData',
            disabled: '@disableImageMetaDataSave'
        },
        {
            action: 'resizeImage',
            // Always trigger this action,
            // even if the previous action was rejected: 
            always: true,
            // Use "preview" as prefix for the "@" options:
            prefix: 'preview',
            maxWidth: '@',
            maxHeight: '@',
            minWidth: '@',
            minHeight: '@',
            crop: '@',
            orientation: '@',
            thumbnail: '@',
            canvas: '@',
            disabled: '@disableImagePreview'
        },
        {
            action: 'setImage',
            name: '@imagePreviewName',
            disabled: '@disableImagePreview'
        }
    );

    // The File Upload Resize plugin extends the fileupload widget
    // with image resize functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // The regular expression for the types of images to load:
            // matched against the file type:
            loadImageFileTypes: /^image\/(gif|jpeg|png)$/,
            // The maximum file size of images to load:
            loadImageMaxFileSize: 10000000, // 10MB
            // The maximum width of resized images:
            imageMaxWidth: 1920,
            // The maximum height of resized images:
            imageMaxHeight: 1080,
            // Define if resized images should be cropped or only scaled:
            imageCrop: false,
            // Disable the resize image functionality by default:
            disableImageResize: true,
            // The maximum width of the preview images:
            previewMaxWidth: 80,
            // The maximum height of the preview images:
            previewMaxHeight: 80,
            // Defines the preview orientation (1-8) or takes the orientation
            // value from Exif data if set to true:
            previewOrientation: true,
            // Create the preview using the Exif data thumbnail:
            previewThumbnail: true,
            // Define if preview images should be cropped or only scaled:
            previewCrop: false,
            // Define if preview images should be resized as canvas elements:
            previewCanvas: true
        },

        processActions: {

            // Loads the image given via data.files and data.index
            // as img element if the browser supports canvas.
            // Accepts the options fileTypes (regular expression)
            // and maxFileSize (integer) to limit the files to load:
            loadImage: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred();
                if (($.type(options.maxFileSize) === 'number' &&
                            file.size > options.maxFileSize) ||
                        (options.fileTypes &&
                            !options.fileTypes.test(file.type)) ||
                        !loadImage(
                            file,
                            function (img) {
                                if (!img.src) {
                                    return dfd.rejectWith(that, [data]);
                                }
                                data.img = img;
                                dfd.resolveWith(that, [data]);
                            },
                            options
                        )) {
                    dfd.rejectWith(that, [data]);
                }
                return dfd.promise();
            },

            // Resizes the image given as data.canvas or data.img
            // and updates data.canvas or data.img with the resized image.
            // Accepts the options maxWidth, maxHeight, minWidth,
            // minHeight, canvas and crop:
            resizeImage: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    dfd = $.Deferred(),
                    resolve = function (newImg) {
                        data[newImg.getContext ? 'canvas' : 'img'] = newImg;
                        dfd.resolveWith(that, [data]);
                    },
                    thumbnail,
                    img,
                    newImg;
                options = $.extend({canvas: true}, options);
                if (data.exif) {
                    if (options.orientation === true) {
                        options.orientation = data.exif.get('Orientation');
                    }
                    if (options.thumbnail) {
                        thumbnail = data.exif.get('Thumbnail');
                        if (thumbnail) {
                            loadImage(thumbnail, resolve, options);
                            return dfd.promise();
                        }
                    }
                }
                img = (options.canvas && data.canvas) || data.img;
                if (img) {
                    newImg = loadImage.scale(img, options);
                    if (newImg.width !== img.width ||
                            newImg.height !== img.height) {
                        resolve(newImg);
                        return dfd.promise();
                    }
                }
                return data;
            },

            // Saves the processed image given as data.canvas
            // inplace at data.index of data.files:
            saveImage: function (data, options) {
                if (!data.canvas || options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    name = file.name,
                    dfd = $.Deferred(),
                    callback = function (blob) {
                        if (!blob.name) {
                            if (file.type === blob.type) {
                                blob.name = file.name;
                            } else if (file.name) {
                                blob.name = file.name.replace(
                                    /\..+$/,
                                    '.' + blob.type.substr(6)
                                );
                            }
                        }
                        // Store the created blob at the position
                        // of the original file in the files list:
                        data.files[data.index] = blob;
                        dfd.resolveWith(that, [data]);
                    };
                // Use canvas.mozGetAsFile directly, to retain the filename, as
                // Gecko doesn't support the filename option for FormData.append:
                if (data.canvas.mozGetAsFile) {
                    callback(data.canvas.mozGetAsFile(
                        (/^image\/(jpeg|png)$/.test(file.type) && name) ||
                            ((name && name.replace(/\..+$/, '')) ||
                                'blob') + '.png',
                        file.type
                    ));
                } else if (data.canvas.toBlob) {
                    data.canvas.toBlob(callback, file.type);
                } else {
                    return data;
                }
                return dfd.promise();
            },

            loadImageMetaData: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    dfd = $.Deferred();
                loadImage.parseMetaData(data.files[data.index], function (result) {
                    $.extend(data, result);
                    dfd.resolveWith(that, [data]);
                }, options);
                return dfd.promise();
            },

            saveImageMetaData: function (data, options) {
                if (!(data.imageHead && data.canvas &&
                        data.canvas.toBlob && !options.disabled)) {
                    return data;
                }
                var file = data.files[data.index],
                    blob = new Blob([
                        data.imageHead,
                        // Resized images always have a head size of 20 bytes,
                        // including the JPEG marker and a minimal JFIF header:
                        this._blobSlice.call(file, 20)
                    ], {type: file.type});
                blob.name = file.name;
                data.files[data.index] = blob;
                return data;
            },

            // Sets the resized version of the image as a property of the
            // file object, must be called after "saveImage":
            setImage: function (data, options) {
                var img = data.canvas || data.img;
                if (img && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = img;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Audio Preview Plugin 1.0.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'load-image',
            './jquery.fileupload-process'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    // Prepend to the default processQueue:
    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadAudio',
            // Always trigger this action,
            // even if the previous action was rejected: 
            always: true,
            // Use the action as prefix for the "@" options:
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            disabled: '@disableAudioPreview'
        },
        {
            action: 'setAudio',
            name: '@audioPreviewName',
            disabled: '@disableAudioPreview'
        }
    );

    // The File Upload Audio Preview plugin extends the fileupload widget
    // with audio preview functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // The regular expression for the types of audio files to load,
            // matched against the file type:
            loadAudioFileTypes: /^audio\/.*$/
        },

        _audioElement: document.createElement('audio'),

        processActions: {

            // Loads the audio file given via data.files and data.index
            // as audio element if the browser supports playing it.
            // Accepts the options fileTypes (regular expression)
            // and maxFileSize (integer) to limit the files to load:
            loadAudio: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred(),
                    url,
                    audio;
                if (this._audioElement.canPlayType &&
                        this._audioElement.canPlayType(file.type) &&
                        ($.type(options.maxFileSize) !== 'number' ||
                            file.size <= options.maxFileSize) &&
                        (!options.fileTypes ||
                            options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        audio = this._audioElement.cloneNode(false);
                        audio.src = url;
                        audio.controls = true;
                        data.audio = audio;
                        dfd.resolveWith(that, [data]);
                        return dfd.promise();
                    }
                }
                dfd.rejectWith(that, [data]);
                return dfd.promise();
            },

            // Sets the audio element as a property of the file object:
            setAudio: function (data, options) {
                if (data.audio && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = data.audio;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Video Preview Plugin 1.0.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'load-image',
            './jquery.fileupload-process'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery,
            window.loadImage
        );
    }
}(function ($, loadImage) {
    'use strict';

    // Prepend to the default processQueue:
    $.blueimp.fileupload.prototype.options.processQueue.unshift(
        {
            action: 'loadVideo',
            // Always trigger this action,
            // even if the previous action was rejected: 
            always: true,
            // Use the action as prefix for the "@" options:
            prefix: true,
            fileTypes: '@',
            maxFileSize: '@',
            disabled: '@disableVideoPreview'
        },
        {
            action: 'setVideo',
            name: '@videoPreviewName',
            disabled: '@disableVideoPreview'
        }
    );

    // The File Upload Video Preview plugin extends the fileupload widget
    // with video preview functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // The regular expression for the types of video files to load,
            // matched against the file type:
            loadVideoFileTypes: /^video\/.*$/
        },

        _videoElement: document.createElement('video'),

        processActions: {

            // Loads the video file given via data.files and data.index
            // as video element if the browser supports playing it.
            // Accepts the options fileTypes (regular expression)
            // and maxFileSize (integer) to limit the files to load:
            loadVideo: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var that = this,
                    file = data.files[data.index],
                    dfd = $.Deferred(),
                    url,
                    video;
                if (this._videoElement.canPlayType &&
                        this._videoElement.canPlayType(file.type) &&
                        ($.type(options.maxFileSize) !== 'number' ||
                            file.size <= options.maxFileSize) &&
                        (!options.fileTypes ||
                            options.fileTypes.test(file.type))) {
                    url = loadImage.createObjectURL(file);
                    if (url) {
                        video = this._videoElement.cloneNode(false);
                        video.src = url;
                        video.controls = true;
                        data.video = video;
                        dfd.resolveWith(that, [data]);
                        return dfd.promise();
                    }
                }
                dfd.rejectWith(that, [data]);
                return dfd.promise();
            },

            // Sets the video element as a property of the file object:
            setVideo: function (data, options) {
                if (data.video && !options.disabled) {
                    data.files[data.index][options.name || 'preview'] = data.video;
                }
                return data;
            }

        }

    });

}));

/*
 * jQuery File Upload Validation Plugin 1.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            './jquery.fileupload-process'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery
        );
    }
}(function ($) {
    'use strict';

    // Append to the default processQueue:
    $.blueimp.fileupload.prototype.options.processQueue.push(
        {
            action: 'validate',
            // Always trigger this action,
            // even if the previous action was rejected: 
            always: true,
            // Options taken from the global options map:
            acceptFileTypes: '@',
            maxFileSize: '@',
            minFileSize: '@',
            maxNumberOfFiles: '@',
            disabled: '@disableValidation'
        }
    );

    // The File Upload Validation plugin extends the fileupload widget
    // with file validation functionality:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            /*
            // The regular expression for allowed file types, matches
            // against either file type or file name:
            acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
            // The maximum allowed file size in bytes:
            maxFileSize: 10000000, // 10 MB
            // The minimum allowed file size in bytes:
            minFileSize: undefined, // No minimal file size
            // The limit of files to be uploaded:
            maxNumberOfFiles: 10,
            */

            // Function returning the current number of files,
            // has to be overriden for maxNumberOfFiles validation:
            getNumberOfFiles: $.noop,

            // Error and info messages:
            messages: {
                maxNumberOfFiles: 'Maximum number of files exceeded',
                acceptFileTypes: 'File type not allowed',
                maxFileSize: 'File is too large',
                minFileSize: 'File is too small'
            }
        },

        processActions: {

            validate: function (data, options) {
                if (options.disabled) {
                    return data;
                }
                var dfd = $.Deferred(),
                    settings = this.options,
                    file = data.files[data.index],
                    numberOfFiles = settings.getNumberOfFiles();
                if (numberOfFiles && $.type(options.maxNumberOfFiles) === 'number' &&
                        numberOfFiles + data.files.length > options.maxNumberOfFiles) {
                    file.error = settings.i18n('maxNumberOfFiles');
                } else if (options.acceptFileTypes &&
                        !(options.acceptFileTypes.test(file.type) ||
                        options.acceptFileTypes.test(file.name))) {
                    file.error = settings.i18n('acceptFileTypes');
                } else if (options.maxFileSize && file.size > options.maxFileSize) {
                    file.error = settings.i18n('maxFileSize');
                } else if ($.type(file.size) === 'number' &&
                        file.size < options.minFileSize) {
                    file.error = settings.i18n('minFileSize');
                } else {
                    delete file.error;
                }
                if (file.error || data.files.error) {
                    data.files.error = true;
                    dfd.rejectWith(this, [data]);
                } else {
                    dfd.resolveWith(this, [data]);
                }
                return dfd.promise();
            }

        }

    });

}));

/*
 * jQuery File Upload User Interface Plugin 8.3
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, URL, webkitURL, FileReader */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'tmpl',
            './jquery.fileupload-image',
            './jquery.fileupload-audio',
            './jquery.fileupload-video',
            './jquery.fileupload-validate'
        ], factory);
    } else {
        // Browser globals:
        factory(
            window.jQuery,
            window.tmpl
        );
    }
}(function ($, tmpl, loadImage) {
    'use strict';

    $.blueimp.fileupload.prototype._specialOptions.push(
        'filesContainer',
        'uploadTemplateId',
        'downloadTemplateId'
    );

    // The UI version extends the file upload widget
    // and adds complete user interface interaction:
    $.widget('blueimp.fileupload', $.blueimp.fileupload, {

        options: {
            // By default, files added to the widget are uploaded as soon
            // as the user clicks on the start buttons. To enable automatic
            // uploads, set the following option to true:
            autoUpload: false,
            // The ID of the upload template:
            uploadTemplateId: 'template-upload',
            // The ID of the download template:
            downloadTemplateId: 'template-download',
            // The container for the list of files. If undefined, it is set to
            // an element with class "files" inside of the widget element:
            filesContainer: undefined,
            // By default, files are appended to the files container.
            // Set the following option to true, to prepend files instead:
            prependFiles: false,
            // The expected data type of the upload response, sets the dataType
            // option of the $.ajax upload requests:
            dataType: 'json',

            // Function returning the current number of files,
            // used by the maxNumberOfFiles validation:
            getNumberOfFiles: function () {
                return this.filesContainer.children().length;
            },

            // Callback to retrieve the list of files from the server response:
            getFilesFromResponse: function (data) {
                if (data.result && $.isArray(data.result.files)) {
                    return data.result.files;
                }
                return [];
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop or add API call).
            // See the basic file upload widget for more information:
            add: function (e, data) {
                var $this = $(this),
                    that = $this.data('blueimp-fileupload') ||
                        $this.data('fileupload'),
                    options = that.options,
                    files = data.files;
                data.process(function () {
                    return $this.fileupload('process', data);
                }).always(function () {
                    data.context = that._renderUpload(files).data('data', data);
                    that._renderPreviews(data);
                    options.filesContainer[
                        options.prependFiles ? 'prepend' : 'append'
                    ](data.context);
                    that._forceReflow(data.context);
                    that._transition(data.context).done(
                        function () {
                            if ((that._trigger('added', e, data) !== false) &&
                                    (options.autoUpload || data.autoUpload) &&
                                    data.autoUpload !== false && !data.files.error) {
                                data.submit();
                            }
                        }
                    );
                });
            },
            // Callback for the start of each file upload request:
            send: function (e, data) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload');
                if (data.context && data.dataType &&
                        data.dataType.substr(0, 6) === 'iframe') {
                    // Iframe Transport does not support progress events.
                    // In lack of an indeterminate progress bar, we set
                    // the progress to 100%, showing the full animated bar:
                    data.context
                        .find('.progress').addClass(
                            !$.support.transition && 'progress-animated'
                        )
                        .attr('aria-valuenow', 100)
                        .find('.progress-bar').css(
                            'width',
                            '100%'
                        );
                }
                return that._trigger('sent', e, data);
            },
            // Callback for successful uploads:
            done: function (e, data) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload'),
                    getFilesFromResponse = data.getFilesFromResponse ||
                        that.options.getFilesFromResponse,
                    files = getFilesFromResponse(data),
                    template,
                    deferred;
                if (data.context) {
                    data.context.each(function (index) {
                        var file = files[index] ||
                                {error: 'Empty file upload result'},
                            deferred = that._addFinishedDeferreds();
                        
                        that._transition($(this)).done(
                            function () {
                                var node = $(this);
                                template = that._renderDownload([file])
                                    .replaceAll(node);
                                that._forceReflow(template);
                                that._transition(template).done(
                                    function () {
                                        data.context = $(this);
                                        that._trigger('completed', e, data);
                                        that._trigger('finished', e, data);
                                        deferred.resolve();
                                    }
                                );
                            }
                        );
                    });
                } else {
                    template = that._renderDownload(files)
                        .appendTo(that.options.filesContainer);
                    that._forceReflow(template);
                    deferred = that._addFinishedDeferreds();
                    that._transition(template).done(
                        function () {
                            data.context = $(this);
                            that._trigger('completed', e, data);
                            that._trigger('finished', e, data);
                            deferred.resolve();
                        }
                    );
                }
            },
            // Callback for failed (abort or error) uploads:
            fail: function (e, data) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload'),
                    template,
                    deferred;
                if (data.context) {
                    data.context.each(function (index) {
                        if (data.errorThrown !== 'abort') {
                            var file = data.files[index];
                            file.error = file.error || data.errorThrown ||
                                true;
                            deferred = that._addFinishedDeferreds();
                            that._transition($(this)).done(
                                function () {
                                    var node = $(this);
                                    template = that._renderDownload([file])
                                        .replaceAll(node);
                                    that._forceReflow(template);
                                    that._transition(template).done(
                                        function () {
                                            data.context = $(this);
                                            that._trigger('failed', e, data);
                                            that._trigger('finished', e, data);
                                            deferred.resolve();
                                        }
                                    );
                                }
                            );
                        } else {
                            deferred = that._addFinishedDeferreds();
                            that._transition($(this)).done(
                                function () {
                                    $(this).remove();
                                    that._trigger('failed', e, data);
                                    that._trigger('finished', e, data);
                                    deferred.resolve();
                                }
                            );
                        }
                    });
                } else if (data.errorThrown !== 'abort') {
                    data.context = that._renderUpload(data.files)
                        .appendTo(that.options.filesContainer)
                        .data('data', data);
                    that._forceReflow(data.context);
                    deferred = that._addFinishedDeferreds();
                    that._transition(data.context).done(
                        function () {
                            data.context = $(this);
                            that._trigger('failed', e, data);
                            that._trigger('finished', e, data);
                            deferred.resolve();
                        }
                    );
                } else {
                    that._trigger('failed', e, data);
                    that._trigger('finished', e, data);
                    that._addFinishedDeferreds().resolve();
                }
            },
            // Callback for upload progress events:
            progress: function (e, data) {
                if (data.context) {
                    var progress = Math.floor(data.loaded / data.total * 100);
                    data.context.find('.progress')
                        .attr('aria-valuenow', progress)
                        .find('.progress-bar').css(
                            'width',
                            progress + '%'
                        );
                }
            },
            // Callback for global upload progress events:
            progressall: function (e, data) {
                var $this = $(this),
                    progress = Math.floor(data.loaded / data.total * 100),
                    globalProgressNode = $this.find('.fileupload-progress'),
                    extendedProgressNode = globalProgressNode
                        .find('.progress-extended');
                if (extendedProgressNode.length) {
                    extendedProgressNode.html(
                        ($this.data('blueimp-fileupload') || $this.data('fileupload'))
                            ._renderExtendedProgress(data)
                    );
                }
                globalProgressNode
                    .find('.progress')
                    .attr('aria-valuenow', progress)
                    .find('.progress-bar').css(
                        'width',
                        progress + '%'
                    );
            },
            // Callback for uploads start, equivalent to the global ajaxStart event:
            start: function (e) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload');
                that._resetFinishedDeferreds();
                that._transition($(this).find('.fileupload-progress')).done(
                    function () {
                        that._trigger('started', e);
                    }
                );
            },
            // Callback for uploads stop, equivalent to the global ajaxStop event:
            stop: function (e) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload'),
                    deferred = that._addFinishedDeferreds();
                $.when.apply($, that._getFinishedDeferreds())
                    .done(function () {
                        that._trigger('stopped', e);
                    });
                that._transition($(this).find('.fileupload-progress')).done(
                    function () {
                        $(this).find('.progress')
                            .attr('aria-valuenow', '0')
                            .find('.progress-bar').css('width', '0%');
                        $(this).find('.progress-extended').html('&nbsp;');
                        deferred.resolve();
                    }
                );
            },
            processstart: function () {
                $(this).addClass('fileupload-processing');
            },
            processstop: function () {
                $(this).removeClass('fileupload-processing');
            },
            // Callback for file deletion:
            destroy: function (e, data) {
                var that = $(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload'),
                    removeNode = function () {
                        that._transition(data.context).done(
                            function () {
                                $(this).remove();
                                that._trigger('destroyed', e, data);
                            }
                        );
                    };
                if (data.url && data.url != "undefined") {
                    $.ajax(data).done(removeNode);
                } else {
                    removeNode();
                }
            }
        },

        _resetFinishedDeferreds: function () {
            this._finishedUploads = [];
        },

        _addFinishedDeferreds: function (deferred) {
            if (!deferred) {
                deferred = $.Deferred();
            }
            this._finishedUploads.push(deferred);
            return deferred;
        },

        _getFinishedDeferreds: function () {
            return this._finishedUploads;
        },

        // Link handler, that allows to download files
        // by drag & drop of the links to the desktop:
        _enableDragToDesktop: function () {
            var link = $(this),
                url = link.prop('href'),
                name = link.prop('download'),
                type = 'application/octet-stream';
            link.bind('dragstart', function (e) {
                try {
                    e.originalEvent.dataTransfer.setData(
                        'DownloadURL',
                        [type, name, url].join(':')
                    );
                } catch (ignore) {}
            });
        },

        _formatFileSize: function (bytes) {
            if (typeof bytes !== 'number') {
                return '';
            }
            if (bytes >= 1000000000) {
                return (bytes / 1000000000).toFixed(2) + ' GB';
            }
            if (bytes >= 1000000) {
                return (bytes / 1000000).toFixed(2) + ' MB';
            }
            return (bytes / 1000).toFixed(2) + ' KB';
        },

        _formatBitrate: function (bits) {
            if (typeof bits !== 'number') {
                return '';
            }
            if (bits >= 1000000000) {
                return (bits / 1000000000).toFixed(2) + ' Gbit/s';
            }
            if (bits >= 1000000) {
                return (bits / 1000000).toFixed(2) + ' Mbit/s';
            }
            if (bits >= 1000) {
                return (bits / 1000).toFixed(2) + ' kbit/s';
            }
            return bits.toFixed(2) + ' bit/s';
        },

        _formatTime: function (seconds) {
            var date = new Date(seconds * 1000),
                days = Math.floor(seconds / 86400);
            days = days ? days + 'd ' : '';
            return days +
                ('0' + date.getUTCHours()).slice(-2) + ':' +
                ('0' + date.getUTCMinutes()).slice(-2) + ':' +
                ('0' + date.getUTCSeconds()).slice(-2);
        },

        _formatPercentage: function (floatValue) {
            return (floatValue * 100).toFixed(2) + ' %';
        },

        _renderExtendedProgress: function (data) {
            return this._formatBitrate(data.bitrate) + ' | ' +
                this._formatTime(
                    (data.total - data.loaded) * 8 / data.bitrate
                ) + ' | ' +
                this._formatPercentage(
                    data.loaded / data.total
                ) + ' | ' +
                this._formatFileSize(data.loaded) + ' / ' +
                this._formatFileSize(data.total);
        },

        _renderTemplate: function (func, files) {
            if (!func) {
                return $();
            }
            var result = func({
                files: files,
                formatFileSize: this._formatFileSize,
                options: this.options
            });
            if (result instanceof $) {
                return result;
            }
            return $(this.options.templatesContainer).html(result).children();
        },

        _renderPreviews: function (data) {
            data.context.find('.preview').each(function (index, elm) {
                $(elm).append(data.files[index].preview);
            });
        },

        _renderUpload: function (files) {
            return this._renderTemplate(
                this.options.uploadTemplate,
                files
            );
        },

        _renderDownload: function (files) {
            return this._renderTemplate(
                this.options.downloadTemplate,
                files
            ).find('a[download]').each(this._enableDragToDesktop).end();
        },

        _startHandler: function (e) {
            e.preventDefault();
            var button = $(e.currentTarget),
                template = button.closest('.template-upload'),
                data = template.data('data');
            if (data && data.submit && !data.jqXHR && data.submit()) {
                button.prop('disabled', true);
            }
        },

        _cancelHandler: function (e) {
            e.preventDefault();
            var template = $(e.currentTarget).closest('.template-upload'),
                data = template.data('data') || {};
            if (!data.jqXHR) {
                data.errorThrown = 'abort';
                this._trigger('fail', e, data);
            } else {
                data.jqXHR.abort();
            }
        },

        _deleteHandler: function (e) {
            e.preventDefault();
            var button = $(e.currentTarget);
            this._trigger('destroy', e, $.extend({
                context: button.closest('.template-download'),
                type: 'DELETE'
            }, button.data()));
        },

        _forceReflow: function (node) {
            return $.support.transition && node.length &&
                node[0].offsetWidth;
        },

        _transition: function (node) {
            var dfd = $.Deferred();
            if ($.support.transition && node.hasClass('fade') && node.is(':visible')) {
                node.bind(
                    $.support.transition.end,
                    function (e) {
                        // Make sure we don't respond to other transitions events
                        // in the container element, e.g. from button elements:
                        if (e.target === node[0]) {
                            node.unbind($.support.transition.end);
                            dfd.resolveWith(node);
                        }
                    }
                ).toggleClass('in');
            } else {
                node.toggleClass('in');
                dfd.resolveWith(node);
            }
            return dfd;
        },

        _initButtonBarEventHandlers: function () {
            var fileUploadButtonBar = this.element.find('.fileupload-buttonbar'),
                filesList = this.options.filesContainer;
            this._on(fileUploadButtonBar.find('.start'), {
                click: function (e) {
                    e.preventDefault();
                    filesList.find('.start').click();
                }
            });
            this._on(fileUploadButtonBar.find('.cancel'), {
                click: function (e) {
                    e.preventDefault();
                    filesList.find('.cancel').click();
                }
            });
            this._on(fileUploadButtonBar.find('.delete'), {
                click: function (e) {
                    e.preventDefault();
                    filesList.find('.delete').click();
                    fileUploadButtonBar.find('.toggle')
                        .prop('checked', false);
                }
            });
            this._on(fileUploadButtonBar.find('.toggle'), {
                change: function (e) {
                    filesList.find('.toggle').prop(
                        'checked',
                        $(e.currentTarget).is(':checked')
                    );
                }
            });
        },

        _destroyButtonBarEventHandlers: function () {
            this._off(
                this.element.find('.fileupload-buttonbar')
                    .find('.start, .cancel, .delete'),
                'click'
            );
            this._off(
                this.element.find('.fileupload-buttonbar .toggle'),
                'change.'
            );
        },

        _initEventHandlers: function () {
            this._super();
            this._on(this.options.filesContainer, {
                'click .start': this._startHandler,
                'click .cancel': this._cancelHandler,
                'click .delete': this._deleteHandler
            });
            this._initButtonBarEventHandlers();
        },

        _destroyEventHandlers: function () {
            this._destroyButtonBarEventHandlers();
            this._off(this.options.filesContainer, 'click');
            this._super();
        },

        _enableFileInputButton: function () {
            this.element.find('.fileinput-button input')
                .prop('disabled', false)
                .parent().removeClass('disabled');
        },

        _disableFileInputButton: function () {
            this.element.find('.fileinput-button input')
                .prop('disabled', true)
                .parent().addClass('disabled');
        },

        _initTemplates: function () {
            var options = this.options;
            options.templatesContainer = this.document[0].createElement(
                options.filesContainer.prop('nodeName')
            );
            if (tmpl) {
                if (options.uploadTemplateId) {
                    options.uploadTemplate = tmpl(options.uploadTemplateId);
                }
                if (options.downloadTemplateId) {
                    options.downloadTemplate = tmpl(options.downloadTemplateId);
                }
            }
        },

        _initFilesContainer: function () {
            var options = this.options;
            if (options.filesContainer === undefined) {
                options.filesContainer = this.element.find('.files');
            } else if (!(options.filesContainer instanceof $)) {
                options.filesContainer = $(options.filesContainer);
            }
        },

        _initSpecialOptions: function () {
            this._super();
            this._initFilesContainer();
            this._initTemplates();
        },

        _create: function () {
            this._super();
            this._resetFinishedDeferreds();
        },

        enable: function () {
            var wasDisabled = false;
            if (this.options.disabled) {
                wasDisabled = true;
            }
            this._super();
            if (wasDisabled) {
                this.element.find('input, button').prop('disabled', false);
                this._enableFileInputButton();
            }
        },

        disable: function () {
            if (!this.options.disabled) {
                this.element.find('input, button').prop('disabled', true);
                this._disableFileInputButton();
            }
            this._super();
        }

    });

}));

/**
 * Swiper 3.4.0
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2016, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: October 16, 2016
 */
!function(){"use strict";function e(e){e.fn.swiper=function(a){var s;return e(this).each(function(){var e=new t(this,a);s||(s=e)}),s}}var a,t=function(e,i){function n(e){return Math.floor(e)}function o(){var e=S.params.autoplay,a=S.slides.eq(S.activeIndex);a.attr("data-swiper-autoplay")&&(e=a.attr("data-swiper-autoplay")||S.params.autoplay),S.autoplayTimeoutId=setTimeout(function(){S.params.loop?(S.fixLoop(),S._slideNext(),S.emit("onAutoplay",S)):S.isEnd?i.autoplayStopOnLast?S.stopAutoplay():(S._slideTo(0),S.emit("onAutoplay",S)):(S._slideNext(),S.emit("onAutoplay",S))},e)}function l(e,t){var s=a(e.target);if(!s.is(t))if("string"==typeof t)s=s.parents(t);else if(t.nodeType){var i;return s.parents().each(function(e,a){a===t&&(i=t)}),i?t:void 0}if(0!==s.length)return s[0]}function p(e,a){a=a||{};var t=window.MutationObserver||window.WebkitMutationObserver,s=new t(function(e){e.forEach(function(e){S.onResize(!0),S.emit("onObserverUpdate",S,e)})});s.observe(e,{attributes:"undefined"==typeof a.attributes||a.attributes,childList:"undefined"==typeof a.childList||a.childList,characterData:"undefined"==typeof a.characterData||a.characterData}),S.observers.push(s)}function d(e){e.originalEvent&&(e=e.originalEvent);var a=e.keyCode||e.charCode;if(!S.params.allowSwipeToNext&&(S.isHorizontal()&&39===a||!S.isHorizontal()&&40===a))return!1;if(!S.params.allowSwipeToPrev&&(S.isHorizontal()&&37===a||!S.isHorizontal()&&38===a))return!1;if(!(e.shiftKey||e.altKey||e.ctrlKey||e.metaKey||document.activeElement&&document.activeElement.nodeName&&("input"===document.activeElement.nodeName.toLowerCase()||"textarea"===document.activeElement.nodeName.toLowerCase()))){if(37===a||39===a||38===a||40===a){var t=!1;if(S.container.parents("."+S.params.slideClass).length>0&&0===S.container.parents("."+S.params.slideActiveClass).length)return;var s={left:window.pageXOffset,top:window.pageYOffset},i=window.innerWidth,r=window.innerHeight,n=S.container.offset();S.rtl&&(n.left=n.left-S.container[0].scrollLeft);for(var o=[[n.left,n.top],[n.left+S.width,n.top],[n.left,n.top+S.height],[n.left+S.width,n.top+S.height]],l=0;l<o.length;l++){var p=o[l];p[0]>=s.left&&p[0]<=s.left+i&&p[1]>=s.top&&p[1]<=s.top+r&&(t=!0)}if(!t)return}S.isHorizontal()?(37!==a&&39!==a||(e.preventDefault?e.preventDefault():e.returnValue=!1),(39===a&&!S.rtl||37===a&&S.rtl)&&S.slideNext(),(37===a&&!S.rtl||39===a&&S.rtl)&&S.slidePrev()):(38!==a&&40!==a||(e.preventDefault?e.preventDefault():e.returnValue=!1),40===a&&S.slideNext(),38===a&&S.slidePrev())}}function u(){var e="onwheel",a=e in document;if(!a){var t=document.createElement("div");t.setAttribute(e,"return;"),a="function"==typeof t[e]}return!a&&document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("","")!==!0&&(a=document.implementation.hasFeature("Events.wheel","3.0")),a}function c(e){e.originalEvent&&(e=e.originalEvent);var a=0,t=S.rtl?-1:1,s=m(e);if(S.params.mousewheelForceToAxis)if(S.isHorizontal()){if(!(Math.abs(s.pixelX)>Math.abs(s.pixelY)))return;a=s.pixelX*t}else{if(!(Math.abs(s.pixelY)>Math.abs(s.pixelX)))return;a=s.pixelY}else a=Math.abs(s.pixelX)>Math.abs(s.pixelY)?-s.pixelX*t:-s.pixelY;if(0!==a){if(S.params.mousewheelInvert&&(a=-a),S.params.freeMode){var i=S.getWrapperTranslate()+a*S.params.mousewheelSensitivity,r=S.isBeginning,n=S.isEnd;if(i>=S.minTranslate()&&(i=S.minTranslate()),i<=S.maxTranslate()&&(i=S.maxTranslate()),S.setWrapperTransition(0),S.setWrapperTranslate(i),S.updateProgress(),S.updateActiveIndex(),(!r&&S.isBeginning||!n&&S.isEnd)&&S.updateClasses(),S.params.freeModeSticky?(clearTimeout(S.mousewheel.timeout),S.mousewheel.timeout=setTimeout(function(){S.slideReset()},300)):S.params.lazyLoading&&S.lazy&&S.lazy.load(),S.emit("onScroll",S,e),S.params.autoplay&&S.params.autoplayDisableOnInteraction&&S.stopAutoplay(),0===i||i===S.maxTranslate())return}else{if((new window.Date).getTime()-S.mousewheel.lastScrollTime>60)if(a<0)if(S.isEnd&&!S.params.loop||S.animating){if(S.params.mousewheelReleaseOnEdges)return!0}else S.slideNext(),S.emit("onScroll",S,e);else if(S.isBeginning&&!S.params.loop||S.animating){if(S.params.mousewheelReleaseOnEdges)return!0}else S.slidePrev(),S.emit("onScroll",S,e);S.mousewheel.lastScrollTime=(new window.Date).getTime()}return e.preventDefault?e.preventDefault():e.returnValue=!1,!1}}function m(e){var a=10,t=40,s=800,i=0,r=0,n=0,o=0;return"detail"in e&&(r=e.detail),"wheelDelta"in e&&(r=-e.wheelDelta/120),"wheelDeltaY"in e&&(r=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(i=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(i=r,r=0),n=i*a,o=r*a,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(n=e.deltaX),(n||o)&&e.deltaMode&&(1===e.deltaMode?(n*=t,o*=t):(n*=s,o*=s)),n&&!i&&(i=n<1?-1:1),o&&!r&&(r=o<1?-1:1),{spinX:i,spinY:r,pixelX:n,pixelY:o}}function h(e,t){e=a(e);var s,i,r,n=S.rtl?-1:1;s=e.attr("data-swiper-parallax")||"0",i=e.attr("data-swiper-parallax-x"),r=e.attr("data-swiper-parallax-y"),i||r?(i=i||"0",r=r||"0"):S.isHorizontal()?(i=s,r="0"):(r=s,i="0"),i=i.indexOf("%")>=0?parseInt(i,10)*t*n+"%":i*t*n+"px",r=r.indexOf("%")>=0?parseInt(r,10)*t+"%":r*t+"px",e.transform("translate3d("+i+", "+r+",0px)")}function g(e){return 0!==e.indexOf("on")&&(e=e[0]!==e[0].toUpperCase()?"on"+e[0].toUpperCase()+e.substring(1):"on"+e),e}if(!(this instanceof t))return new t(e,i);var f={direction:"horizontal",touchEventsTarget:"container",initialSlide:0,speed:300,autoplay:!1,autoplayDisableOnInteraction:!0,autoplayStopOnLast:!1,iOSEdgeSwipeDetection:!1,iOSEdgeSwipeThreshold:20,freeMode:!1,freeModeMomentum:!0,freeModeMomentumRatio:1,freeModeMomentumBounce:!0,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:!1,freeModeMinimumVelocity:.02,autoHeight:!1,setWrapperSize:!1,virtualTranslate:!1,effect:"slide",coverflow:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:!0},flip:{slideShadows:!0,limitRotation:!0},cube:{slideShadows:!0,shadow:!0,shadowOffset:20,shadowScale:.94},fade:{crossFade:!1},parallax:!1,zoom:!1,zoomMax:3,zoomMin:1,zoomToggle:!0,scrollbar:null,scrollbarHide:!0,scrollbarDraggable:!1,scrollbarSnapOnRelease:!1,keyboardControl:!1,mousewheelControl:!1,mousewheelReleaseOnEdges:!1,mousewheelInvert:!1,mousewheelForceToAxis:!1,mousewheelSensitivity:1,mousewheelEventsTarged:"container",hashnav:!1,hashnavWatchState:!1,history:!1,replaceState:!1,breakpoints:void 0,spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:"column",slidesPerGroup:1,centeredSlides:!1,slidesOffsetBefore:0,slidesOffsetAfter:0,roundLengths:!1,touchRatio:1,touchAngle:45,simulateTouch:!0,shortSwipes:!0,longSwipes:!0,longSwipesRatio:.5,longSwipesMs:300,followFinger:!0,onlyExternal:!1,threshold:0,touchMoveStopPropagation:!0,touchReleaseOnEdges:!1,uniqueNavElements:!0,pagination:null,paginationElement:"span",paginationClickable:!1,paginationHide:!1,paginationBulletRender:null,paginationProgressRender:null,paginationFractionRender:null,paginationCustomRender:null,paginationType:"bullets",resistance:!0,resistanceRatio:.85,nextButton:null,prevButton:null,watchSlidesProgress:!1,watchSlidesVisibility:!1,grabCursor:!1,preventClicks:!0,preventClicksPropagation:!0,slideToClickedSlide:!1,lazyLoading:!1,lazyLoadingInPrevNext:!1,lazyLoadingInPrevNextAmount:1,lazyLoadingOnTransitionStart:!1,preloadImages:!0,updateOnImagesReady:!0,loop:!1,loopAdditionalSlides:0,loopedSlides:null,control:void 0,controlInverse:!1,controlBy:"slide",normalizeSlideIndex:!0,allowSwipeToPrev:!0,allowSwipeToNext:!0,swipeHandler:null,noSwiping:!0,noSwipingClass:"swiper-no-swiping",passiveListeners:!0,containerModifierClass:"swiper-container-",slideClass:"swiper-slide",slideActiveClass:"swiper-slide-active",slideDuplicateActiveClass:"swiper-slide-duplicate-active",slideVisibleClass:"swiper-slide-visible",slideDuplicateClass:"swiper-slide-duplicate",slideNextClass:"swiper-slide-next",slideDuplicateNextClass:"swiper-slide-duplicate-next",slidePrevClass:"swiper-slide-prev",slideDuplicatePrevClass:"swiper-slide-duplicate-prev",wrapperClass:"swiper-wrapper",bulletClass:"swiper-pagination-bullet",bulletActiveClass:"swiper-pagination-bullet-active",buttonDisabledClass:"swiper-button-disabled",paginationCurrentClass:"swiper-pagination-current",paginationTotalClass:"swiper-pagination-total",paginationHiddenClass:"swiper-pagination-hidden",paginationProgressbarClass:"swiper-pagination-progressbar",paginationClickableClass:"swiper-pagination-clickable",paginationModifierClass:"swiper-pagination-",lazyLoadingClass:"swiper-lazy",lazyStatusLoadingClass:"swiper-lazy-loading",lazyStatusLoadedClass:"swiper-lazy-loaded",lazyPreloaderClass:"swiper-lazy-preloader",notificationClass:"swiper-notification",preloaderClass:"preloader",zoomContainerClass:"swiper-zoom-container",observer:!1,observeParents:!1,a11y:!1,prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide",paginationBulletMessage:"Go to slide {{index}}",runCallbacksOnInit:!0},v=i&&i.virtualTranslate;i=i||{};var w={};for(var y in i)if("object"!=typeof i[y]||null===i[y]||(i[y].nodeType||i[y]===window||i[y]===document||"undefined"!=typeof s&&i[y]instanceof s||"undefined"!=typeof jQuery&&i[y]instanceof jQuery))w[y]=i[y];else{w[y]={};for(var x in i[y])w[y][x]=i[y][x]}for(var T in f)if("undefined"==typeof i[T])i[T]=f[T];else if("object"==typeof i[T])for(var b in f[T])"undefined"==typeof i[T][b]&&(i[T][b]=f[T][b]);var S=this;if(S.params=i,S.originalParams=w,S.classNames=[],"undefined"!=typeof a&&"undefined"!=typeof s&&(a=s),("undefined"!=typeof a||(a="undefined"==typeof s?window.Dom7||window.Zepto||window.jQuery:s))&&(S.$=a,S.currentBreakpoint=void 0,S.getActiveBreakpoint=function(){if(!S.params.breakpoints)return!1;var e,a=!1,t=[];for(e in S.params.breakpoints)S.params.breakpoints.hasOwnProperty(e)&&t.push(e);t.sort(function(e,a){return parseInt(e,10)>parseInt(a,10)});for(var s=0;s<t.length;s++)e=t[s],e>=window.innerWidth&&!a&&(a=e);return a||"max"},S.setBreakpoint=function(){var e=S.getActiveBreakpoint();if(e&&S.currentBreakpoint!==e){var a=e in S.params.breakpoints?S.params.breakpoints[e]:S.originalParams,t=S.params.loop&&a.slidesPerView!==S.params.slidesPerView;for(var s in a)S.params[s]=a[s];S.currentBreakpoint=e,t&&S.destroyLoop&&S.reLoop(!0)}},S.params.breakpoints&&S.setBreakpoint(),S.container=a(e),0!==S.container.length)){if(S.container.length>1){var C=[];return S.container.each(function(){C.push(new t(this,i))}),C}S.container[0].swiper=S,S.container.data("swiper",S),S.classNames.push(S.params.containerModifierClass+S.params.direction),S.params.freeMode&&S.classNames.push(S.params.containerModifierClass+"free-mode"),S.support.flexbox||(S.classNames.push(S.params.containerModifierClass+"no-flexbox"),S.params.slidesPerColumn=1),S.params.autoHeight&&S.classNames.push(S.params.containerModifierClass+"autoheight"),(S.params.parallax||S.params.watchSlidesVisibility)&&(S.params.watchSlidesProgress=!0),S.params.touchReleaseOnEdges&&(S.params.resistanceRatio=0),["cube","coverflow","flip"].indexOf(S.params.effect)>=0&&(S.support.transforms3d?(S.params.watchSlidesProgress=!0,S.classNames.push(S.params.containerModifierClass+"3d")):S.params.effect="slide"),"slide"!==S.params.effect&&S.classNames.push(S.params.containerModifierClass+S.params.effect),"cube"===S.params.effect&&(S.params.resistanceRatio=0,S.params.slidesPerView=1,S.params.slidesPerColumn=1,S.params.slidesPerGroup=1,S.params.centeredSlides=!1,S.params.spaceBetween=0,S.params.virtualTranslate=!0,S.params.setWrapperSize=!1),"fade"!==S.params.effect&&"flip"!==S.params.effect||(S.params.slidesPerView=1,S.params.slidesPerColumn=1,S.params.slidesPerGroup=1,S.params.watchSlidesProgress=!0,S.params.spaceBetween=0,S.params.setWrapperSize=!1,"undefined"==typeof v&&(S.params.virtualTranslate=!0)),S.params.grabCursor&&S.support.touch&&(S.params.grabCursor=!1),S.wrapper=S.container.children("."+S.params.wrapperClass),S.params.pagination&&(S.paginationContainer=a(S.params.pagination),S.params.uniqueNavElements&&"string"==typeof S.params.pagination&&S.paginationContainer.length>1&&1===S.container.find(S.params.pagination).length&&(S.paginationContainer=S.container.find(S.params.pagination)),"bullets"===S.params.paginationType&&S.params.paginationClickable?S.paginationContainer.addClass(S.params.paginationModifierClass+"clickable"):S.params.paginationClickable=!1,S.paginationContainer.addClass(S.params.paginationModifierClass+S.params.paginationType)),(S.params.nextButton||S.params.prevButton)&&(S.params.nextButton&&(S.nextButton=a(S.params.nextButton),S.params.uniqueNavElements&&"string"==typeof S.params.nextButton&&S.nextButton.length>1&&1===S.container.find(S.params.nextButton).length&&(S.nextButton=S.container.find(S.params.nextButton))),S.params.prevButton&&(S.prevButton=a(S.params.prevButton),S.params.uniqueNavElements&&"string"==typeof S.params.prevButton&&S.prevButton.length>1&&1===S.container.find(S.params.prevButton).length&&(S.prevButton=S.container.find(S.params.prevButton)))),S.isHorizontal=function(){return"horizontal"===S.params.direction},S.rtl=S.isHorizontal()&&("rtl"===S.container[0].dir.toLowerCase()||"rtl"===S.container.css("direction")),S.rtl&&S.classNames.push(S.params.containerModifierClass+"rtl"),S.rtl&&(S.wrongRTL="-webkit-box"===S.wrapper.css("display")),S.params.slidesPerColumn>1&&S.classNames.push(S.params.containerModifierClass+"multirow"),S.device.android&&S.classNames.push(S.params.containerModifierClass+"android"),S.container.addClass(S.classNames.join(" ")),S.translate=0,S.progress=0,S.velocity=0,S.lockSwipeToNext=function(){S.params.allowSwipeToNext=!1,S.params.allowSwipeToPrev===!1&&S.params.grabCursor&&S.unsetGrabCursor()},S.lockSwipeToPrev=function(){S.params.allowSwipeToPrev=!1,S.params.allowSwipeToNext===!1&&S.params.grabCursor&&S.unsetGrabCursor()},S.lockSwipes=function(){S.params.allowSwipeToNext=S.params.allowSwipeToPrev=!1,S.params.grabCursor&&S.unsetGrabCursor()},S.unlockSwipeToNext=function(){S.params.allowSwipeToNext=!0,S.params.allowSwipeToPrev===!0&&S.params.grabCursor&&S.setGrabCursor()},S.unlockSwipeToPrev=function(){S.params.allowSwipeToPrev=!0,S.params.allowSwipeToNext===!0&&S.params.grabCursor&&S.setGrabCursor()},S.unlockSwipes=function(){S.params.allowSwipeToNext=S.params.allowSwipeToPrev=!0,S.params.grabCursor&&S.setGrabCursor()},S.setGrabCursor=function(e){S.container[0].style.cursor="move",S.container[0].style.cursor=e?"-webkit-grabbing":"-webkit-grab",S.container[0].style.cursor=e?"-moz-grabbin":"-moz-grab",S.container[0].style.cursor=e?"grabbing":"grab"},S.unsetGrabCursor=function(){S.container[0].style.cursor=""},S.params.grabCursor&&S.setGrabCursor(),S.imagesToLoad=[],S.imagesLoaded=0,S.loadImage=function(e,a,t,s,i,r){function n(){r&&r()}var o;e.complete&&i?n():a?(o=new window.Image,o.onload=n,o.onerror=n,s&&(o.sizes=s),t&&(o.srcset=t),a&&(o.src=a)):n()},S.preloadImages=function(){function e(){"undefined"!=typeof S&&null!==S&&(void 0!==S.imagesLoaded&&S.imagesLoaded++,S.imagesLoaded===S.imagesToLoad.length&&(S.params.updateOnImagesReady&&S.update(),S.emit("onImagesReady",S)))}S.imagesToLoad=S.container.find("img");for(var a=0;a<S.imagesToLoad.length;a++)S.loadImage(S.imagesToLoad[a],S.imagesToLoad[a].currentSrc||S.imagesToLoad[a].getAttribute("src"),S.imagesToLoad[a].srcset||S.imagesToLoad[a].getAttribute("srcset"),S.imagesToLoad[a].sizes||S.imagesToLoad[a].getAttribute("sizes"),!0,e)},S.autoplayTimeoutId=void 0,S.autoplaying=!1,S.autoplayPaused=!1,S.startAutoplay=function(){return"undefined"==typeof S.autoplayTimeoutId&&(!!S.params.autoplay&&(!S.autoplaying&&(S.autoplaying=!0,S.emit("onAutoplayStart",S),void o())))},S.stopAutoplay=function(e){S.autoplayTimeoutId&&(S.autoplayTimeoutId&&clearTimeout(S.autoplayTimeoutId),S.autoplaying=!1,S.autoplayTimeoutId=void 0,S.emit("onAutoplayStop",S))},S.pauseAutoplay=function(e){S.autoplayPaused||(S.autoplayTimeoutId&&clearTimeout(S.autoplayTimeoutId),S.autoplayPaused=!0,0===e?(S.autoplayPaused=!1,o()):S.wrapper.transitionEnd(function(){S&&(S.autoplayPaused=!1,S.autoplaying?o():S.stopAutoplay())}))},S.minTranslate=function(){return-S.snapGrid[0]},S.maxTranslate=function(){return-S.snapGrid[S.snapGrid.length-1]},S.updateAutoHeight=function(){var e=[],a=0;if("auto"!==S.params.slidesPerView&&S.params.slidesPerView>1)for(r=0;r<Math.ceil(S.params.slidesPerView);r++){var t=S.activeIndex+r;if(t>S.slides.length)break;e.push(S.slides.eq(t)[0])}else e.push(S.slides.eq(S.activeIndex)[0]);for(r=0;r<e.length;r++)if("undefined"!=typeof e[r]){var s=e[r].offsetHeight;a=s>a?s:a}a&&S.wrapper.css("height",a+"px")},S.updateContainerSize=function(){var e,a;e="undefined"!=typeof S.params.width?S.params.width:S.container[0].clientWidth,a="undefined"!=typeof S.params.height?S.params.height:S.container[0].clientHeight,0===e&&S.isHorizontal()||0===a&&!S.isHorizontal()||(e=e-parseInt(S.container.css("padding-left"),10)-parseInt(S.container.css("padding-right"),10),a=a-parseInt(S.container.css("padding-top"),10)-parseInt(S.container.css("padding-bottom"),10),S.width=e,S.height=a,S.size=S.isHorizontal()?S.width:S.height)},S.updateSlidesSize=function(){S.slides=S.wrapper.children("."+S.params.slideClass),S.snapGrid=[],S.slidesGrid=[],S.slidesSizesGrid=[];var e,a=S.params.spaceBetween,t=-S.params.slidesOffsetBefore,s=0,i=0;if("undefined"!=typeof S.size){"string"==typeof a&&a.indexOf("%")>=0&&(a=parseFloat(a.replace("%",""))/100*S.size),S.virtualSize=-a,S.rtl?S.slides.css({marginLeft:"",marginTop:""}):S.slides.css({marginRight:"",marginBottom:""});var r;S.params.slidesPerColumn>1&&(r=Math.floor(S.slides.length/S.params.slidesPerColumn)===S.slides.length/S.params.slidesPerColumn?S.slides.length:Math.ceil(S.slides.length/S.params.slidesPerColumn)*S.params.slidesPerColumn,"auto"!==S.params.slidesPerView&&"row"===S.params.slidesPerColumnFill&&(r=Math.max(r,S.params.slidesPerView*S.params.slidesPerColumn)));var o,l=S.params.slidesPerColumn,p=r/l,d=p-(S.params.slidesPerColumn*p-S.slides.length);for(e=0;e<S.slides.length;e++){o=0;var u=S.slides.eq(e);if(S.params.slidesPerColumn>1){var c,m,h;"column"===S.params.slidesPerColumnFill?(m=Math.floor(e/l),h=e-m*l,(m>d||m===d&&h===l-1)&&++h>=l&&(h=0,m++),c=m+h*r/l,u.css({"-webkit-box-ordinal-group":c,"-moz-box-ordinal-group":c,"-ms-flex-order":c,"-webkit-order":c,order:c})):(h=Math.floor(e/p),m=e-h*p),u.css("margin-"+(S.isHorizontal()?"top":"left"),0!==h&&S.params.spaceBetween&&S.params.spaceBetween+"px").attr("data-swiper-column",m).attr("data-swiper-row",h)}"none"!==u.css("display")&&("auto"===S.params.slidesPerView?(o=S.isHorizontal()?u.outerWidth(!0):u.outerHeight(!0),S.params.roundLengths&&(o=n(o))):(o=(S.size-(S.params.slidesPerView-1)*a)/S.params.slidesPerView,S.params.roundLengths&&(o=n(o)),S.isHorizontal()?S.slides[e].style.width=o+"px":S.slides[e].style.height=o+"px"),S.slides[e].swiperSlideSize=o,S.slidesSizesGrid.push(o),S.params.centeredSlides?(t=t+o/2+s/2+a,0===e&&(t=t-S.size/2-a),Math.abs(t)<.001&&(t=0),i%S.params.slidesPerGroup===0&&S.snapGrid.push(t),S.slidesGrid.push(t)):(i%S.params.slidesPerGroup===0&&S.snapGrid.push(t),S.slidesGrid.push(t),t=t+o+a),S.virtualSize+=o+a,s=o,i++)}S.virtualSize=Math.max(S.virtualSize,S.size)+S.params.slidesOffsetAfter;var g;if(S.rtl&&S.wrongRTL&&("slide"===S.params.effect||"coverflow"===S.params.effect)&&S.wrapper.css({width:S.virtualSize+S.params.spaceBetween+"px"}),S.support.flexbox&&!S.params.setWrapperSize||(S.isHorizontal()?S.wrapper.css({width:S.virtualSize+S.params.spaceBetween+"px"}):S.wrapper.css({height:S.virtualSize+S.params.spaceBetween+"px"})),S.params.slidesPerColumn>1&&(S.virtualSize=(o+S.params.spaceBetween)*r,S.virtualSize=Math.ceil(S.virtualSize/S.params.slidesPerColumn)-S.params.spaceBetween,S.isHorizontal()?S.wrapper.css({width:S.virtualSize+S.params.spaceBetween+"px"}):S.wrapper.css({height:S.virtualSize+S.params.spaceBetween+"px"}),S.params.centeredSlides)){for(g=[],e=0;e<S.snapGrid.length;e++)S.snapGrid[e]<S.virtualSize+S.snapGrid[0]&&g.push(S.snapGrid[e]);S.snapGrid=g}if(!S.params.centeredSlides){for(g=[],e=0;e<S.snapGrid.length;e++)S.snapGrid[e]<=S.virtualSize-S.size&&g.push(S.snapGrid[e]);S.snapGrid=g,Math.floor(S.virtualSize-S.size)-Math.floor(S.snapGrid[S.snapGrid.length-1])>1&&S.snapGrid.push(S.virtualSize-S.size)}0===S.snapGrid.length&&(S.snapGrid=[0]),0!==S.params.spaceBetween&&(S.isHorizontal()?S.rtl?S.slides.css({marginLeft:a+"px"}):S.slides.css({marginRight:a+"px"}):S.slides.css({marginBottom:a+"px"})),S.params.watchSlidesProgress&&S.updateSlidesOffset()}},S.updateSlidesOffset=function(){for(var e=0;e<S.slides.length;e++)S.slides[e].swiperSlideOffset=S.isHorizontal()?S.slides[e].offsetLeft:S.slides[e].offsetTop},S.updateSlidesProgress=function(e){if("undefined"==typeof e&&(e=S.translate||0),0!==S.slides.length){"undefined"==typeof S.slides[0].swiperSlideOffset&&S.updateSlidesOffset();var a=-e;S.rtl&&(a=e),S.slides.removeClass(S.params.slideVisibleClass);for(var t=0;t<S.slides.length;t++){var s=S.slides[t],i=(a+(S.params.centeredSlides?S.minTranslate():0)-s.swiperSlideOffset)/(s.swiperSlideSize+S.params.spaceBetween);if(S.params.watchSlidesVisibility){var r=-(a-s.swiperSlideOffset),n=r+S.slidesSizesGrid[t],o=r>=0&&r<S.size||n>0&&n<=S.size||r<=0&&n>=S.size;o&&S.slides.eq(t).addClass(S.params.slideVisibleClass)}s.progress=S.rtl?-i:i}}},S.updateProgress=function(e){"undefined"==typeof e&&(e=S.translate||0);var a=S.maxTranslate()-S.minTranslate(),t=S.isBeginning,s=S.isEnd;0===a?(S.progress=0,S.isBeginning=S.isEnd=!0):(S.progress=(e-S.minTranslate())/a,S.isBeginning=S.progress<=0,S.isEnd=S.progress>=1),S.isBeginning&&!t&&S.emit("onReachBeginning",S),S.isEnd&&!s&&S.emit("onReachEnd",S),S.params.watchSlidesProgress&&S.updateSlidesProgress(e),S.emit("onProgress",S,S.progress)},S.updateActiveIndex=function(){var e,a,t,s=S.rtl?S.translate:-S.translate;for(a=0;a<S.slidesGrid.length;a++)"undefined"!=typeof S.slidesGrid[a+1]?s>=S.slidesGrid[a]&&s<S.slidesGrid[a+1]-(S.slidesGrid[a+1]-S.slidesGrid[a])/2?e=a:s>=S.slidesGrid[a]&&s<S.slidesGrid[a+1]&&(e=a+1):s>=S.slidesGrid[a]&&(e=a);S.params.normalizeSlideIndex&&(e<0||"undefined"==typeof e)&&(e=0),t=Math.floor(e/S.params.slidesPerGroup),t>=S.snapGrid.length&&(t=S.snapGrid.length-1),e!==S.activeIndex&&(S.snapIndex=t,S.previousIndex=S.activeIndex,S.activeIndex=e,S.updateClasses(),S.updateRealIndex())},S.updateRealIndex=function(){S.realIndex=S.slides.eq(S.activeIndex).attr("data-swiper-slide-index")||S.activeIndex},S.updateClasses=function(){S.slides.removeClass(S.params.slideActiveClass+" "+S.params.slideNextClass+" "+S.params.slidePrevClass+" "+S.params.slideDuplicateActiveClass+" "+S.params.slideDuplicateNextClass+" "+S.params.slideDuplicatePrevClass);var e=S.slides.eq(S.activeIndex);e.addClass(S.params.slideActiveClass),i.loop&&(e.hasClass(S.params.slideDuplicateClass)?S.wrapper.children("."+S.params.slideClass+":not(."+S.params.slideDuplicateClass+')[data-swiper-slide-index="'+S.realIndex+'"]').addClass(S.params.slideDuplicateActiveClass):S.wrapper.children("."+S.params.slideClass+"."+S.params.slideDuplicateClass+'[data-swiper-slide-index="'+S.realIndex+'"]').addClass(S.params.slideDuplicateActiveClass));var t=e.next("."+S.params.slideClass).addClass(S.params.slideNextClass);S.params.loop&&0===t.length&&(t=S.slides.eq(0),t.addClass(S.params.slideNextClass));var s=e.prev("."+S.params.slideClass).addClass(S.params.slidePrevClass);if(S.params.loop&&0===s.length&&(s=S.slides.eq(-1),s.addClass(S.params.slidePrevClass)),i.loop&&(t.hasClass(S.params.slideDuplicateClass)?S.wrapper.children("."+S.params.slideClass+":not(."+S.params.slideDuplicateClass+')[data-swiper-slide-index="'+t.attr("data-swiper-slide-index")+'"]').addClass(S.params.slideDuplicateNextClass):S.wrapper.children("."+S.params.slideClass+"."+S.params.slideDuplicateClass+'[data-swiper-slide-index="'+t.attr("data-swiper-slide-index")+'"]').addClass(S.params.slideDuplicateNextClass),s.hasClass(S.params.slideDuplicateClass)?S.wrapper.children("."+S.params.slideClass+":not(."+S.params.slideDuplicateClass+')[data-swiper-slide-index="'+s.attr("data-swiper-slide-index")+'"]').addClass(S.params.slideDuplicatePrevClass):S.wrapper.children("."+S.params.slideClass+"."+S.params.slideDuplicateClass+'[data-swiper-slide-index="'+s.attr("data-swiper-slide-index")+'"]').addClass(S.params.slideDuplicatePrevClass)),S.paginationContainer&&S.paginationContainer.length>0){var r,n=S.params.loop?Math.ceil((S.slides.length-2*S.loopedSlides)/S.params.slidesPerGroup):S.snapGrid.length;if(S.params.loop?(r=Math.ceil((S.activeIndex-S.loopedSlides)/S.params.slidesPerGroup),r>S.slides.length-1-2*S.loopedSlides&&(r-=S.slides.length-2*S.loopedSlides),r>n-1&&(r-=n),r<0&&"bullets"!==S.params.paginationType&&(r=n+r)):r="undefined"!=typeof S.snapIndex?S.snapIndex:S.activeIndex||0,"bullets"===S.params.paginationType&&S.bullets&&S.bullets.length>0&&(S.bullets.removeClass(S.params.bulletActiveClass),S.paginationContainer.length>1?S.bullets.each(function(){a(this).index()===r&&a(this).addClass(S.params.bulletActiveClass)}):S.bullets.eq(r).addClass(S.params.bulletActiveClass)),"fraction"===S.params.paginationType&&(S.paginationContainer.find("."+S.params.paginationCurrentClass).text(r+1),S.paginationContainer.find("."+S.params.paginationTotalClass).text(n)),"progress"===S.params.paginationType){var o=(r+1)/n,l=o,p=1;S.isHorizontal()||(p=o,l=1),S.paginationContainer.find("."+S.params.paginationProgressbarClass).transform("translate3d(0,0,0) scaleX("+l+") scaleY("+p+")").transition(S.params.speed)}"custom"===S.params.paginationType&&S.params.paginationCustomRender&&(S.paginationContainer.html(S.params.paginationCustomRender(S,r+1,n)),S.emit("onPaginationRendered",S,S.paginationContainer[0]))}S.params.loop||(S.params.prevButton&&S.prevButton&&S.prevButton.length>0&&(S.isBeginning?(S.prevButton.addClass(S.params.buttonDisabledClass),S.params.a11y&&S.a11y&&S.a11y.disable(S.prevButton)):(S.prevButton.removeClass(S.params.buttonDisabledClass),S.params.a11y&&S.a11y&&S.a11y.enable(S.prevButton))),S.params.nextButton&&S.nextButton&&S.nextButton.length>0&&(S.isEnd?(S.nextButton.addClass(S.params.buttonDisabledClass),S.params.a11y&&S.a11y&&S.a11y.disable(S.nextButton)):(S.nextButton.removeClass(S.params.buttonDisabledClass),S.params.a11y&&S.a11y&&S.a11y.enable(S.nextButton))))},S.updatePagination=function(){if(S.params.pagination&&S.paginationContainer&&S.paginationContainer.length>0){var e="";if("bullets"===S.params.paginationType){for(var a=S.params.loop?Math.ceil((S.slides.length-2*S.loopedSlides)/S.params.slidesPerGroup):S.snapGrid.length,t=0;t<a;t++)e+=S.params.paginationBulletRender?S.params.paginationBulletRender(S,t,S.params.bulletClass):"<"+S.params.paginationElement+' class="'+S.params.bulletClass+'"></'+S.params.paginationElement+">";S.paginationContainer.html(e),S.bullets=S.paginationContainer.find("."+S.params.bulletClass),S.params.paginationClickable&&S.params.a11y&&S.a11y&&S.a11y.initPagination()}"fraction"===S.params.paginationType&&(e=S.params.paginationFractionRender?S.params.paginationFractionRender(S,S.params.paginationCurrentClass,S.params.paginationTotalClass):'<span class="'+S.params.paginationCurrentClass+'"></span> / <span class="'+S.params.paginationTotalClass+'"></span>',S.paginationContainer.html(e)),"progress"===S.params.paginationType&&(e=S.params.paginationProgressRender?S.params.paginationProgressRender(S,S.params.paginationProgressbarClass):'<span class="'+S.params.paginationProgressbarClass+'"></span>',S.paginationContainer.html(e)),"custom"!==S.params.paginationType&&S.emit("onPaginationRendered",S,S.paginationContainer[0])}},S.update=function(e){function a(){S.rtl?-S.translate:S.translate;s=Math.min(Math.max(S.translate,S.maxTranslate()),S.minTranslate()),S.setWrapperTranslate(s),S.updateActiveIndex(),S.updateClasses()}if(S.updateContainerSize(),S.updateSlidesSize(),S.updateProgress(),S.updatePagination(),S.updateClasses(),S.params.scrollbar&&S.scrollbar&&S.scrollbar.set(),e){var t,s;S.controller&&S.controller.spline&&(S.controller.spline=void 0),S.params.freeMode?(a(),S.params.autoHeight&&S.updateAutoHeight()):(t=("auto"===S.params.slidesPerView||S.params.slidesPerView>1)&&S.isEnd&&!S.params.centeredSlides?S.slideTo(S.slides.length-1,0,!1,!0):S.slideTo(S.activeIndex,0,!1,!0),t||a())}else S.params.autoHeight&&S.updateAutoHeight()},S.onResize=function(e){S.params.breakpoints&&S.setBreakpoint();var a=S.params.allowSwipeToPrev,t=S.params.allowSwipeToNext;S.params.allowSwipeToPrev=S.params.allowSwipeToNext=!0,S.updateContainerSize(),S.updateSlidesSize(),("auto"===S.params.slidesPerView||S.params.freeMode||e)&&S.updatePagination(),S.params.scrollbar&&S.scrollbar&&S.scrollbar.set(),S.controller&&S.controller.spline&&(S.controller.spline=void 0);var s=!1;if(S.params.freeMode){var i=Math.min(Math.max(S.translate,S.maxTranslate()),S.minTranslate());S.setWrapperTranslate(i),S.updateActiveIndex(),S.updateClasses(),S.params.autoHeight&&S.updateAutoHeight()}else S.updateClasses(),s=("auto"===S.params.slidesPerView||S.params.slidesPerView>1)&&S.isEnd&&!S.params.centeredSlides?S.slideTo(S.slides.length-1,0,!1,!0):S.slideTo(S.activeIndex,0,!1,!0);S.params.lazyLoading&&!s&&S.lazy&&S.lazy.load(),S.params.allowSwipeToPrev=a,S.params.allowSwipeToNext=t},S.touchEventsDesktop={start:"mousedown",move:"mousemove",end:"mouseup"},window.navigator.pointerEnabled?S.touchEventsDesktop={start:"pointerdown",move:"pointermove",end:"pointerup"}:window.navigator.msPointerEnabled&&(S.touchEventsDesktop={start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}),S.touchEvents={start:S.support.touch||!S.params.simulateTouch?"touchstart":S.touchEventsDesktop.start,move:S.support.touch||!S.params.simulateTouch?"touchmove":S.touchEventsDesktop.move,end:S.support.touch||!S.params.simulateTouch?"touchend":S.touchEventsDesktop.end},(window.navigator.pointerEnabled||window.navigator.msPointerEnabled)&&("container"===S.params.touchEventsTarget?S.container:S.wrapper).addClass("swiper-wp8-"+S.params.direction),S.initEvents=function(e){var a=e?"off":"on",t=e?"removeEventListener":"addEventListener",s="container"===S.params.touchEventsTarget?S.container[0]:S.wrapper[0],r=S.support.touch?s:document,n=!!S.params.nested;if(S.browser.ie)s[t](S.touchEvents.start,S.onTouchStart,!1),r[t](S.touchEvents.move,S.onTouchMove,n),r[t](S.touchEvents.end,S.onTouchEnd,!1);else{if(S.support.touch){var o=!("touchstart"!==S.touchEvents.start||!S.support.passiveListener||!S.params.passiveListeners)&&{passive:!0,capture:!1};s[t](S.touchEvents.start,S.onTouchStart,o),s[t](S.touchEvents.move,S.onTouchMove,n),s[t](S.touchEvents.end,S.onTouchEnd,o)}(i.simulateTouch&&!S.device.ios&&!S.device.android||i.simulateTouch&&!S.support.touch&&S.device.ios)&&(s[t]("mousedown",S.onTouchStart,!1),document[t]("mousemove",S.onTouchMove,n),document[t]("mouseup",S.onTouchEnd,!1))}window[t]("resize",S.onResize),S.params.nextButton&&S.nextButton&&S.nextButton.length>0&&(S.nextButton[a]("click",S.onClickNext),S.params.a11y&&S.a11y&&S.nextButton[a]("keydown",S.a11y.onEnterKey)),S.params.prevButton&&S.prevButton&&S.prevButton.length>0&&(S.prevButton[a]("click",S.onClickPrev),S.params.a11y&&S.a11y&&S.prevButton[a]("keydown",S.a11y.onEnterKey)),S.params.pagination&&S.params.paginationClickable&&(S.paginationContainer[a]("click","."+S.params.bulletClass,S.onClickIndex),S.params.a11y&&S.a11y&&S.paginationContainer[a]("keydown","."+S.params.bulletClass,S.a11y.onEnterKey)),(S.params.preventClicks||S.params.preventClicksPropagation)&&s[t]("click",S.preventClicks,!0)},S.attachEvents=function(){S.initEvents()},S.detachEvents=function(){S.initEvents(!0)},S.allowClick=!0,S.preventClicks=function(e){S.allowClick||(S.params.preventClicks&&e.preventDefault(),S.params.preventClicksPropagation&&S.animating&&(e.stopPropagation(),e.stopImmediatePropagation()))},S.onClickNext=function(e){e.preventDefault(),S.isEnd&&!S.params.loop||S.slideNext()},S.onClickPrev=function(e){e.preventDefault(),S.isBeginning&&!S.params.loop||S.slidePrev()},S.onClickIndex=function(e){
e.preventDefault();var t=a(this).index()*S.params.slidesPerGroup;S.params.loop&&(t+=S.loopedSlides),S.slideTo(t)},S.updateClickedSlide=function(e){var t=l(e,"."+S.params.slideClass),s=!1;if(t)for(var i=0;i<S.slides.length;i++)S.slides[i]===t&&(s=!0);if(!t||!s)return S.clickedSlide=void 0,void(S.clickedIndex=void 0);if(S.clickedSlide=t,S.clickedIndex=a(t).index(),S.params.slideToClickedSlide&&void 0!==S.clickedIndex&&S.clickedIndex!==S.activeIndex){var r,n=S.clickedIndex;if(S.params.loop){if(S.animating)return;r=a(S.clickedSlide).attr("data-swiper-slide-index"),S.params.centeredSlides?n<S.loopedSlides-S.params.slidesPerView/2||n>S.slides.length-S.loopedSlides+S.params.slidesPerView/2?(S.fixLoop(),n=S.wrapper.children("."+S.params.slideClass+'[data-swiper-slide-index="'+r+'"]:not(.'+S.params.slideDuplicateClass+")").eq(0).index(),setTimeout(function(){S.slideTo(n)},0)):S.slideTo(n):n>S.slides.length-S.params.slidesPerView?(S.fixLoop(),n=S.wrapper.children("."+S.params.slideClass+'[data-swiper-slide-index="'+r+'"]:not(.'+S.params.slideDuplicateClass+")").eq(0).index(),setTimeout(function(){S.slideTo(n)},0)):S.slideTo(n)}else S.slideTo(n)}};var z,M,E,P,I,k,L,D,B,H,G="input, select, textarea, button, video",X=Date.now(),Y=[];S.animating=!1,S.touches={startX:0,startY:0,currentX:0,currentY:0,diff:0};var A,O;S.onTouchStart=function(e){if(e.originalEvent&&(e=e.originalEvent),A="touchstart"===e.type,A||!("which"in e)||3!==e.which){if(S.params.noSwiping&&l(e,"."+S.params.noSwipingClass))return void(S.allowClick=!0);if(!S.params.swipeHandler||l(e,S.params.swipeHandler)){var t=S.touches.currentX="touchstart"===e.type?e.targetTouches[0].pageX:e.pageX,s=S.touches.currentY="touchstart"===e.type?e.targetTouches[0].pageY:e.pageY;if(!(S.device.ios&&S.params.iOSEdgeSwipeDetection&&t<=S.params.iOSEdgeSwipeThreshold)){if(z=!0,M=!1,E=!0,I=void 0,O=void 0,S.touches.startX=t,S.touches.startY=s,P=Date.now(),S.allowClick=!0,S.updateContainerSize(),S.swipeDirection=void 0,S.params.threshold>0&&(D=!1),"touchstart"!==e.type){var i=!0;a(e.target).is(G)&&(i=!1),document.activeElement&&a(document.activeElement).is(G)&&document.activeElement.blur(),i&&e.preventDefault()}S.emit("onTouchStart",S,e)}}}},S.onTouchMove=function(e){if(e.originalEvent&&(e=e.originalEvent),!A||"mousemove"!==e.type){if(e.preventedByNestedSwiper)return S.touches.startX="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,void(S.touches.startY="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY);if(S.params.onlyExternal)return S.allowClick=!1,void(z&&(S.touches.startX=S.touches.currentX="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,S.touches.startY=S.touches.currentY="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY,P=Date.now()));if(A&&S.params.touchReleaseOnEdges&&!S.params.loop)if(S.isHorizontal()){if(S.touches.currentX<S.touches.startX&&S.translate<=S.maxTranslate()||S.touches.currentX>S.touches.startX&&S.translate>=S.minTranslate())return}else if(S.touches.currentY<S.touches.startY&&S.translate<=S.maxTranslate()||S.touches.currentY>S.touches.startY&&S.translate>=S.minTranslate())return;if(A&&document.activeElement&&e.target===document.activeElement&&a(e.target).is(G))return M=!0,void(S.allowClick=!1);if(E&&S.emit("onTouchMove",S,e),!(e.targetTouches&&e.targetTouches.length>1)){if(S.touches.currentX="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,S.touches.currentY="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY,"undefined"==typeof I){var t;S.isHorizontal()&&S.touches.currentY===S.touches.startY||!S.isHorizontal()&&S.touches.currentX!==S.touches.startX?I=!1:(t=180*Math.atan2(Math.abs(S.touches.currentY-S.touches.startY),Math.abs(S.touches.currentX-S.touches.startX))/Math.PI,I=S.isHorizontal()?t>S.params.touchAngle:90-t>S.params.touchAngle)}if(I&&S.emit("onTouchMoveOpposite",S,e),"undefined"==typeof O&&S.browser.ieTouch&&(S.touches.currentX===S.touches.startX&&S.touches.currentY===S.touches.startY||(O=!0)),z){if(I)return void(z=!1);if(O||!S.browser.ieTouch){S.allowClick=!1,S.emit("onSliderMove",S,e),e.preventDefault(),S.params.touchMoveStopPropagation&&!S.params.nested&&e.stopPropagation(),M||(i.loop&&S.fixLoop(),L=S.getWrapperTranslate(),S.setWrapperTransition(0),S.animating&&S.wrapper.trigger("webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd"),S.params.autoplay&&S.autoplaying&&(S.params.autoplayDisableOnInteraction?S.stopAutoplay():S.pauseAutoplay()),H=!1,!S.params.grabCursor||S.params.allowSwipeToNext!==!0&&S.params.allowSwipeToPrev!==!0||S.setGrabCursor(!0)),M=!0;var s=S.touches.diff=S.isHorizontal()?S.touches.currentX-S.touches.startX:S.touches.currentY-S.touches.startY;s*=S.params.touchRatio,S.rtl&&(s=-s),S.swipeDirection=s>0?"prev":"next",k=s+L;var r=!0;if(s>0&&k>S.minTranslate()?(r=!1,S.params.resistance&&(k=S.minTranslate()-1+Math.pow(-S.minTranslate()+L+s,S.params.resistanceRatio))):s<0&&k<S.maxTranslate()&&(r=!1,S.params.resistance&&(k=S.maxTranslate()+1-Math.pow(S.maxTranslate()-L-s,S.params.resistanceRatio))),r&&(e.preventedByNestedSwiper=!0),!S.params.allowSwipeToNext&&"next"===S.swipeDirection&&k<L&&(k=L),!S.params.allowSwipeToPrev&&"prev"===S.swipeDirection&&k>L&&(k=L),S.params.threshold>0){if(!(Math.abs(s)>S.params.threshold||D))return void(k=L);if(!D)return D=!0,S.touches.startX=S.touches.currentX,S.touches.startY=S.touches.currentY,k=L,void(S.touches.diff=S.isHorizontal()?S.touches.currentX-S.touches.startX:S.touches.currentY-S.touches.startY)}S.params.followFinger&&((S.params.freeMode||S.params.watchSlidesProgress)&&S.updateActiveIndex(),S.params.freeMode&&(0===Y.length&&Y.push({position:S.touches[S.isHorizontal()?"startX":"startY"],time:P}),Y.push({position:S.touches[S.isHorizontal()?"currentX":"currentY"],time:(new window.Date).getTime()})),S.updateProgress(k),S.setWrapperTranslate(k))}}}}},S.onTouchEnd=function(e){if(e.originalEvent&&(e=e.originalEvent),E&&S.emit("onTouchEnd",S,e),E=!1,z){S.params.grabCursor&&M&&z&&(S.params.allowSwipeToNext===!0||S.params.allowSwipeToPrev===!0)&&S.setGrabCursor(!1);var t=Date.now(),s=t-P;if(S.allowClick&&(S.updateClickedSlide(e),S.emit("onTap",S,e),s<300&&t-X>300&&(B&&clearTimeout(B),B=setTimeout(function(){S&&(S.params.paginationHide&&S.paginationContainer.length>0&&!a(e.target).hasClass(S.params.bulletClass)&&S.paginationContainer.toggleClass(S.params.paginationHiddenClass),S.emit("onClick",S,e))},300)),s<300&&t-X<300&&(B&&clearTimeout(B),S.emit("onDoubleTap",S,e))),X=Date.now(),setTimeout(function(){S&&(S.allowClick=!0)},0),!z||!M||!S.swipeDirection||0===S.touches.diff||k===L)return void(z=M=!1);z=M=!1;var i;if(i=S.params.followFinger?S.rtl?S.translate:-S.translate:-k,S.params.freeMode){if(i<-S.minTranslate())return void S.slideTo(S.activeIndex);if(i>-S.maxTranslate())return void(S.slides.length<S.snapGrid.length?S.slideTo(S.snapGrid.length-1):S.slideTo(S.slides.length-1));if(S.params.freeModeMomentum){if(Y.length>1){var r=Y.pop(),n=Y.pop(),o=r.position-n.position,l=r.time-n.time;S.velocity=o/l,S.velocity=S.velocity/2,Math.abs(S.velocity)<S.params.freeModeMinimumVelocity&&(S.velocity=0),(l>150||(new window.Date).getTime()-r.time>300)&&(S.velocity=0)}else S.velocity=0;S.velocity=S.velocity*S.params.freeModeMomentumVelocityRatio,Y.length=0;var p=1e3*S.params.freeModeMomentumRatio,d=S.velocity*p,u=S.translate+d;S.rtl&&(u=-u);var c,m=!1,h=20*Math.abs(S.velocity)*S.params.freeModeMomentumBounceRatio;if(u<S.maxTranslate())S.params.freeModeMomentumBounce?(u+S.maxTranslate()<-h&&(u=S.maxTranslate()-h),c=S.maxTranslate(),m=!0,H=!0):u=S.maxTranslate();else if(u>S.minTranslate())S.params.freeModeMomentumBounce?(u-S.minTranslate()>h&&(u=S.minTranslate()+h),c=S.minTranslate(),m=!0,H=!0):u=S.minTranslate();else if(S.params.freeModeSticky){var g,f=0;for(f=0;f<S.snapGrid.length;f+=1)if(S.snapGrid[f]>-u){g=f;break}u=Math.abs(S.snapGrid[g]-u)<Math.abs(S.snapGrid[g-1]-u)||"next"===S.swipeDirection?S.snapGrid[g]:S.snapGrid[g-1],S.rtl||(u=-u)}if(0!==S.velocity)p=S.rtl?Math.abs((-u-S.translate)/S.velocity):Math.abs((u-S.translate)/S.velocity);else if(S.params.freeModeSticky)return void S.slideReset();S.params.freeModeMomentumBounce&&m?(S.updateProgress(c),S.setWrapperTransition(p),S.setWrapperTranslate(u),S.onTransitionStart(),S.animating=!0,S.wrapper.transitionEnd(function(){S&&H&&(S.emit("onMomentumBounce",S),S.setWrapperTransition(S.params.speed),S.setWrapperTranslate(c),S.wrapper.transitionEnd(function(){S&&S.onTransitionEnd()}))})):S.velocity?(S.updateProgress(u),S.setWrapperTransition(p),S.setWrapperTranslate(u),S.onTransitionStart(),S.animating||(S.animating=!0,S.wrapper.transitionEnd(function(){S&&S.onTransitionEnd()}))):S.updateProgress(u),S.updateActiveIndex()}return void((!S.params.freeModeMomentum||s>=S.params.longSwipesMs)&&(S.updateProgress(),S.updateActiveIndex()))}var v,w=0,y=S.slidesSizesGrid[0];for(v=0;v<S.slidesGrid.length;v+=S.params.slidesPerGroup)"undefined"!=typeof S.slidesGrid[v+S.params.slidesPerGroup]?i>=S.slidesGrid[v]&&i<S.slidesGrid[v+S.params.slidesPerGroup]&&(w=v,y=S.slidesGrid[v+S.params.slidesPerGroup]-S.slidesGrid[v]):i>=S.slidesGrid[v]&&(w=v,y=S.slidesGrid[S.slidesGrid.length-1]-S.slidesGrid[S.slidesGrid.length-2]);var x=(i-S.slidesGrid[w])/y;if(s>S.params.longSwipesMs){if(!S.params.longSwipes)return void S.slideTo(S.activeIndex);"next"===S.swipeDirection&&(x>=S.params.longSwipesRatio?S.slideTo(w+S.params.slidesPerGroup):S.slideTo(w)),"prev"===S.swipeDirection&&(x>1-S.params.longSwipesRatio?S.slideTo(w+S.params.slidesPerGroup):S.slideTo(w))}else{if(!S.params.shortSwipes)return void S.slideTo(S.activeIndex);"next"===S.swipeDirection&&S.slideTo(w+S.params.slidesPerGroup),"prev"===S.swipeDirection&&S.slideTo(w)}}},S._slideTo=function(e,a){return S.slideTo(e,a,!0,!0)},S.slideTo=function(e,a,t,s){"undefined"==typeof t&&(t=!0),"undefined"==typeof e&&(e=0),e<0&&(e=0),S.snapIndex=Math.floor(e/S.params.slidesPerGroup),S.snapIndex>=S.snapGrid.length&&(S.snapIndex=S.snapGrid.length-1);var i=-S.snapGrid[S.snapIndex];if(S.params.autoplay&&S.autoplaying&&(s||!S.params.autoplayDisableOnInteraction?S.pauseAutoplay(a):S.stopAutoplay()),S.updateProgress(i),S.params.normalizeSlideIndex)for(var r=0;r<S.slidesGrid.length;r++)-Math.floor(100*i)>=Math.floor(100*S.slidesGrid[r])&&(e=r);return!(!S.params.allowSwipeToNext&&i<S.translate&&i<S.minTranslate())&&(!(!S.params.allowSwipeToPrev&&i>S.translate&&i>S.maxTranslate()&&(S.activeIndex||0)!==e)&&("undefined"==typeof a&&(a=S.params.speed),S.previousIndex=S.activeIndex||0,S.activeIndex=e,S.updateRealIndex(),S.rtl&&-i===S.translate||!S.rtl&&i===S.translate?(S.params.autoHeight&&S.updateAutoHeight(),S.updateClasses(),"slide"!==S.params.effect&&S.setWrapperTranslate(i),!1):(S.updateClasses(),S.onTransitionStart(t),0===a||S.browser.lteIE9?(S.setWrapperTranslate(i),S.setWrapperTransition(0),S.onTransitionEnd(t)):(S.setWrapperTranslate(i),S.setWrapperTransition(a),S.animating||(S.animating=!0,S.wrapper.transitionEnd(function(){S&&S.onTransitionEnd(t)}))),!0)))},S.onTransitionStart=function(e){"undefined"==typeof e&&(e=!0),S.params.autoHeight&&S.updateAutoHeight(),S.lazy&&S.lazy.onTransitionStart(),e&&(S.emit("onTransitionStart",S),S.activeIndex!==S.previousIndex&&(S.emit("onSlideChangeStart",S),S.activeIndex>S.previousIndex?S.emit("onSlideNextStart",S):S.emit("onSlidePrevStart",S)))},S.onTransitionEnd=function(e){S.animating=!1,S.setWrapperTransition(0),"undefined"==typeof e&&(e=!0),S.lazy&&S.lazy.onTransitionEnd(),e&&(S.emit("onTransitionEnd",S),S.activeIndex!==S.previousIndex&&(S.emit("onSlideChangeEnd",S),S.activeIndex>S.previousIndex?S.emit("onSlideNextEnd",S):S.emit("onSlidePrevEnd",S))),S.params.history&&S.history&&S.history.setHistory(S.params.history,S.activeIndex),S.params.hashnav&&S.hashnav&&S.hashnav.setHash()},S.slideNext=function(e,a,t){if(S.params.loop){if(S.animating)return!1;S.fixLoop();S.container[0].clientLeft;return S.slideTo(S.activeIndex+S.params.slidesPerGroup,a,e,t)}return S.slideTo(S.activeIndex+S.params.slidesPerGroup,a,e,t)},S._slideNext=function(e){return S.slideNext(!0,e,!0)},S.slidePrev=function(e,a,t){if(S.params.loop){if(S.animating)return!1;S.fixLoop();S.container[0].clientLeft;return S.slideTo(S.activeIndex-1,a,e,t)}return S.slideTo(S.activeIndex-1,a,e,t)},S._slidePrev=function(e){return S.slidePrev(!0,e,!0)},S.slideReset=function(e,a,t){return S.slideTo(S.activeIndex,a,e)},S.disableTouchControl=function(){return S.params.onlyExternal=!0,!0},S.enableTouchControl=function(){return S.params.onlyExternal=!1,!0},S.setWrapperTransition=function(e,a){S.wrapper.transition(e),"slide"!==S.params.effect&&S.effects[S.params.effect]&&S.effects[S.params.effect].setTransition(e),S.params.parallax&&S.parallax&&S.parallax.setTransition(e),S.params.scrollbar&&S.scrollbar&&S.scrollbar.setTransition(e),S.params.control&&S.controller&&S.controller.setTransition(e,a),S.emit("onSetTransition",S,e)},S.setWrapperTranslate=function(e,a,t){var s=0,i=0,r=0;S.isHorizontal()?s=S.rtl?-e:e:i=e,S.params.roundLengths&&(s=n(s),i=n(i)),S.params.virtualTranslate||(S.support.transforms3d?S.wrapper.transform("translate3d("+s+"px, "+i+"px, "+r+"px)"):S.wrapper.transform("translate("+s+"px, "+i+"px)")),S.translate=S.isHorizontal()?s:i;var o,l=S.maxTranslate()-S.minTranslate();o=0===l?0:(e-S.minTranslate())/l,o!==S.progress&&S.updateProgress(e),a&&S.updateActiveIndex(),"slide"!==S.params.effect&&S.effects[S.params.effect]&&S.effects[S.params.effect].setTranslate(S.translate),S.params.parallax&&S.parallax&&S.parallax.setTranslate(S.translate),S.params.scrollbar&&S.scrollbar&&S.scrollbar.setTranslate(S.translate),S.params.control&&S.controller&&S.controller.setTranslate(S.translate,t),S.emit("onSetTranslate",S,S.translate)},S.getTranslate=function(e,a){var t,s,i,r;return"undefined"==typeof a&&(a="x"),S.params.virtualTranslate?S.rtl?-S.translate:S.translate:(i=window.getComputedStyle(e,null),window.WebKitCSSMatrix?(s=i.transform||i.webkitTransform,s.split(",").length>6&&(s=s.split(", ").map(function(e){return e.replace(",",".")}).join(", ")),r=new window.WebKitCSSMatrix("none"===s?"":s)):(r=i.MozTransform||i.OTransform||i.MsTransform||i.msTransform||i.transform||i.getPropertyValue("transform").replace("translate(","matrix(1, 0, 0, 1,"),t=r.toString().split(",")),"x"===a&&(s=window.WebKitCSSMatrix?r.m41:16===t.length?parseFloat(t[12]):parseFloat(t[4])),"y"===a&&(s=window.WebKitCSSMatrix?r.m42:16===t.length?parseFloat(t[13]):parseFloat(t[5])),S.rtl&&s&&(s=-s),s||0)},S.getWrapperTranslate=function(e){return"undefined"==typeof e&&(e=S.isHorizontal()?"x":"y"),S.getTranslate(S.wrapper[0],e)},S.observers=[],S.initObservers=function(){if(S.params.observeParents)for(var e=S.container.parents(),a=0;a<e.length;a++)p(e[a]);p(S.container[0],{childList:!1}),p(S.wrapper[0],{attributes:!1})},S.disconnectObservers=function(){for(var e=0;e<S.observers.length;e++)S.observers[e].disconnect();S.observers=[]},S.createLoop=function(){S.wrapper.children("."+S.params.slideClass+"."+S.params.slideDuplicateClass).remove();var e=S.wrapper.children("."+S.params.slideClass);"auto"!==S.params.slidesPerView||S.params.loopedSlides||(S.params.loopedSlides=e.length),S.loopedSlides=parseInt(S.params.loopedSlides||S.params.slidesPerView,10),S.loopedSlides=S.loopedSlides+S.params.loopAdditionalSlides,S.loopedSlides>e.length&&(S.loopedSlides=e.length);var t,s=[],i=[];for(e.each(function(t,r){var n=a(this);t<S.loopedSlides&&i.push(r),t<e.length&&t>=e.length-S.loopedSlides&&s.push(r),n.attr("data-swiper-slide-index",t)}),t=0;t<i.length;t++)S.wrapper.append(a(i[t].cloneNode(!0)).addClass(S.params.slideDuplicateClass));for(t=s.length-1;t>=0;t--)S.wrapper.prepend(a(s[t].cloneNode(!0)).addClass(S.params.slideDuplicateClass))},S.destroyLoop=function(){S.wrapper.children("."+S.params.slideClass+"."+S.params.slideDuplicateClass).remove(),S.slides.removeAttr("data-swiper-slide-index")},S.reLoop=function(e){var a=S.activeIndex-S.loopedSlides;S.destroyLoop(),S.createLoop(),S.updateSlidesSize(),e&&S.slideTo(a+S.loopedSlides,0,!1)},S.fixLoop=function(){var e;S.activeIndex<S.loopedSlides?(e=S.slides.length-3*S.loopedSlides+S.activeIndex,e+=S.loopedSlides,S.slideTo(e,0,!1,!0)):("auto"===S.params.slidesPerView&&S.activeIndex>=2*S.loopedSlides||S.activeIndex>S.slides.length-2*S.params.slidesPerView)&&(e=-S.slides.length+S.activeIndex+S.loopedSlides,e+=S.loopedSlides,S.slideTo(e,0,!1,!0))},S.appendSlide=function(e){if(S.params.loop&&S.destroyLoop(),"object"==typeof e&&e.length)for(var a=0;a<e.length;a++)e[a]&&S.wrapper.append(e[a]);else S.wrapper.append(e);S.params.loop&&S.createLoop(),S.params.observer&&S.support.observer||S.update(!0)},S.prependSlide=function(e){S.params.loop&&S.destroyLoop();var a=S.activeIndex+1;if("object"==typeof e&&e.length){for(var t=0;t<e.length;t++)e[t]&&S.wrapper.prepend(e[t]);a=S.activeIndex+e.length}else S.wrapper.prepend(e);S.params.loop&&S.createLoop(),S.params.observer&&S.support.observer||S.update(!0),S.slideTo(a,0,!1)},S.removeSlide=function(e){S.params.loop&&(S.destroyLoop(),S.slides=S.wrapper.children("."+S.params.slideClass));var a,t=S.activeIndex;if("object"==typeof e&&e.length){for(var s=0;s<e.length;s++)a=e[s],S.slides[a]&&S.slides.eq(a).remove(),a<t&&t--;t=Math.max(t,0)}else a=e,S.slides[a]&&S.slides.eq(a).remove(),a<t&&t--,t=Math.max(t,0);S.params.loop&&S.createLoop(),S.params.observer&&S.support.observer||S.update(!0),S.params.loop?S.slideTo(t+S.loopedSlides,0,!1):S.slideTo(t,0,!1)},S.removeAllSlides=function(){for(var e=[],a=0;a<S.slides.length;a++)e.push(a);S.removeSlide(e)},S.effects={fade:{setTranslate:function(){for(var e=0;e<S.slides.length;e++){var a=S.slides.eq(e),t=a[0].swiperSlideOffset,s=-t;S.params.virtualTranslate||(s-=S.translate);var i=0;S.isHorizontal()||(i=s,s=0);var r=S.params.fade.crossFade?Math.max(1-Math.abs(a[0].progress),0):1+Math.min(Math.max(a[0].progress,-1),0);a.css({opacity:r}).transform("translate3d("+s+"px, "+i+"px, 0px)")}},setTransition:function(e){if(S.slides.transition(e),S.params.virtualTranslate&&0!==e){var a=!1;S.slides.transitionEnd(function(){if(!a&&S){a=!0,S.animating=!1;for(var e=["webkitTransitionEnd","transitionend","oTransitionEnd","MSTransitionEnd","msTransitionEnd"],t=0;t<e.length;t++)S.wrapper.trigger(e[t])}})}}},flip:{setTranslate:function(){for(var e=0;e<S.slides.length;e++){var t=S.slides.eq(e),s=t[0].progress;S.params.flip.limitRotation&&(s=Math.max(Math.min(t[0].progress,1),-1));var i=t[0].swiperSlideOffset,r=-180*s,n=r,o=0,l=-i,p=0;if(S.isHorizontal()?S.rtl&&(n=-n):(p=l,l=0,o=-n,n=0),t[0].style.zIndex=-Math.abs(Math.round(s))+S.slides.length,S.params.flip.slideShadows){var d=S.isHorizontal()?t.find(".swiper-slide-shadow-left"):t.find(".swiper-slide-shadow-top"),u=S.isHorizontal()?t.find(".swiper-slide-shadow-right"):t.find(".swiper-slide-shadow-bottom");0===d.length&&(d=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"left":"top")+'"></div>'),t.append(d)),0===u.length&&(u=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"right":"bottom")+'"></div>'),t.append(u)),d.length&&(d[0].style.opacity=Math.max(-s,0)),u.length&&(u[0].style.opacity=Math.max(s,0))}t.transform("translate3d("+l+"px, "+p+"px, 0px) rotateX("+o+"deg) rotateY("+n+"deg)")}},setTransition:function(e){if(S.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),S.params.virtualTranslate&&0!==e){var t=!1;S.slides.eq(S.activeIndex).transitionEnd(function(){if(!t&&S&&a(this).hasClass(S.params.slideActiveClass)){t=!0,S.animating=!1;for(var e=["webkitTransitionEnd","transitionend","oTransitionEnd","MSTransitionEnd","msTransitionEnd"],s=0;s<e.length;s++)S.wrapper.trigger(e[s])}})}}},cube:{setTranslate:function(){var e,t=0;S.params.cube.shadow&&(S.isHorizontal()?(e=S.wrapper.find(".swiper-cube-shadow"),0===e.length&&(e=a('<div class="swiper-cube-shadow"></div>'),S.wrapper.append(e)),e.css({height:S.width+"px"})):(e=S.container.find(".swiper-cube-shadow"),0===e.length&&(e=a('<div class="swiper-cube-shadow"></div>'),S.container.append(e))));for(var s=0;s<S.slides.length;s++){var i=S.slides.eq(s),r=90*s,n=Math.floor(r/360);S.rtl&&(r=-r,n=Math.floor(-r/360));var o=Math.max(Math.min(i[0].progress,1),-1),l=0,p=0,d=0;s%4===0?(l=4*-n*S.size,d=0):(s-1)%4===0?(l=0,d=4*-n*S.size):(s-2)%4===0?(l=S.size+4*n*S.size,d=S.size):(s-3)%4===0&&(l=-S.size,d=3*S.size+4*S.size*n),S.rtl&&(l=-l),S.isHorizontal()||(p=l,l=0);var u="rotateX("+(S.isHorizontal()?0:-r)+"deg) rotateY("+(S.isHorizontal()?r:0)+"deg) translate3d("+l+"px, "+p+"px, "+d+"px)";if(o<=1&&o>-1&&(t=90*s+90*o,S.rtl&&(t=90*-s-90*o)),i.transform(u),S.params.cube.slideShadows){var c=S.isHorizontal()?i.find(".swiper-slide-shadow-left"):i.find(".swiper-slide-shadow-top"),m=S.isHorizontal()?i.find(".swiper-slide-shadow-right"):i.find(".swiper-slide-shadow-bottom");0===c.length&&(c=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"left":"top")+'"></div>'),i.append(c)),0===m.length&&(m=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"right":"bottom")+'"></div>'),i.append(m)),c.length&&(c[0].style.opacity=Math.max(-o,0)),m.length&&(m[0].style.opacity=Math.max(o,0))}}if(S.wrapper.css({"-webkit-transform-origin":"50% 50% -"+S.size/2+"px","-moz-transform-origin":"50% 50% -"+S.size/2+"px","-ms-transform-origin":"50% 50% -"+S.size/2+"px","transform-origin":"50% 50% -"+S.size/2+"px"}),S.params.cube.shadow)if(S.isHorizontal())e.transform("translate3d(0px, "+(S.width/2+S.params.cube.shadowOffset)+"px, "+-S.width/2+"px) rotateX(90deg) rotateZ(0deg) scale("+S.params.cube.shadowScale+")");else{var h=Math.abs(t)-90*Math.floor(Math.abs(t)/90),g=1.5-(Math.sin(2*h*Math.PI/360)/2+Math.cos(2*h*Math.PI/360)/2),f=S.params.cube.shadowScale,v=S.params.cube.shadowScale/g,w=S.params.cube.shadowOffset;e.transform("scale3d("+f+", 1, "+v+") translate3d(0px, "+(S.height/2+w)+"px, "+-S.height/2/v+"px) rotateX(-90deg)")}var y=S.isSafari||S.isUiWebView?-S.size/2:0;S.wrapper.transform("translate3d(0px,0,"+y+"px) rotateX("+(S.isHorizontal()?0:t)+"deg) rotateY("+(S.isHorizontal()?-t:0)+"deg)")},setTransition:function(e){S.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),S.params.cube.shadow&&!S.isHorizontal()&&S.container.find(".swiper-cube-shadow").transition(e)}},coverflow:{setTranslate:function(){for(var e=S.translate,t=S.isHorizontal()?-e+S.width/2:-e+S.height/2,s=S.isHorizontal()?S.params.coverflow.rotate:-S.params.coverflow.rotate,i=S.params.coverflow.depth,r=0,n=S.slides.length;r<n;r++){var o=S.slides.eq(r),l=S.slidesSizesGrid[r],p=o[0].swiperSlideOffset,d=(t-p-l/2)/l*S.params.coverflow.modifier,u=S.isHorizontal()?s*d:0,c=S.isHorizontal()?0:s*d,m=-i*Math.abs(d),h=S.isHorizontal()?0:S.params.coverflow.stretch*d,g=S.isHorizontal()?S.params.coverflow.stretch*d:0;Math.abs(g)<.001&&(g=0),Math.abs(h)<.001&&(h=0),Math.abs(m)<.001&&(m=0),Math.abs(u)<.001&&(u=0),Math.abs(c)<.001&&(c=0);var f="translate3d("+g+"px,"+h+"px,"+m+"px)  rotateX("+c+"deg) rotateY("+u+"deg)";if(o.transform(f),o[0].style.zIndex=-Math.abs(Math.round(d))+1,S.params.coverflow.slideShadows){var v=S.isHorizontal()?o.find(".swiper-slide-shadow-left"):o.find(".swiper-slide-shadow-top"),w=S.isHorizontal()?o.find(".swiper-slide-shadow-right"):o.find(".swiper-slide-shadow-bottom");0===v.length&&(v=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"left":"top")+'"></div>'),o.append(v)),0===w.length&&(w=a('<div class="swiper-slide-shadow-'+(S.isHorizontal()?"right":"bottom")+'"></div>'),o.append(w)),v.length&&(v[0].style.opacity=d>0?d:0),w.length&&(w[0].style.opacity=-d>0?-d:0)}}if(S.browser.ie){var y=S.wrapper[0].style;y.perspectiveOrigin=t+"px 50%"}},setTransition:function(e){S.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)}}},S.lazy={initialImageLoaded:!1,loadImageInSlide:function(e,t){if("undefined"!=typeof e&&("undefined"==typeof t&&(t=!0),0!==S.slides.length)){var s=S.slides.eq(e),i=s.find("."+S.params.lazyLoadingClass+":not(."+S.params.lazyStatusLoadedClass+"):not(."+S.params.lazyStatusLoadingClass+")");!s.hasClass(S.params.lazyLoadingClass)||s.hasClass(S.params.lazyStatusLoadedClass)||s.hasClass(S.params.lazyStatusLoadingClass)||(i=i.add(s[0])),0!==i.length&&i.each(function(){var e=a(this);e.addClass(S.params.lazyStatusLoadingClass);var i=e.attr("data-background"),r=e.attr("data-src"),n=e.attr("data-srcset"),o=e.attr("data-sizes");S.loadImage(e[0],r||i,n,o,!1,function(){if(i?(e.css("background-image",'url("'+i+'")'),e.removeAttr("data-background")):(n&&(e.attr("srcset",n),e.removeAttr("data-srcset")),o&&(e.attr("sizes",o),e.removeAttr("data-sizes")),r&&(e.attr("src",r),e.removeAttr("data-src"))),e.addClass(S.params.lazyStatusLoadedClass).removeClass(S.params.lazyStatusLoadingClass),s.find("."+S.params.lazyPreloaderClass+", ."+S.params.preloaderClass).remove(),S.params.loop&&t){var a=s.attr("data-swiper-slide-index");if(s.hasClass(S.params.slideDuplicateClass)){var l=S.wrapper.children('[data-swiper-slide-index="'+a+'"]:not(.'+S.params.slideDuplicateClass+")");S.lazy.loadImageInSlide(l.index(),!1)}else{var p=S.wrapper.children("."+S.params.slideDuplicateClass+'[data-swiper-slide-index="'+a+'"]');S.lazy.loadImageInSlide(p.index(),!1)}}S.emit("onLazyImageReady",S,s[0],e[0])}),S.emit("onLazyImageLoad",S,s[0],e[0])})}},load:function(){var e,t=S.params.slidesPerView;if("auto"===t&&(t=0),S.lazy.initialImageLoaded||(S.lazy.initialImageLoaded=!0),S.params.watchSlidesVisibility)S.wrapper.children("."+S.params.slideVisibleClass).each(function(){S.lazy.loadImageInSlide(a(this).index())});else if(t>1)for(e=S.activeIndex;e<S.activeIndex+t;e++)S.slides[e]&&S.lazy.loadImageInSlide(e);else S.lazy.loadImageInSlide(S.activeIndex);if(S.params.lazyLoadingInPrevNext)if(t>1||S.params.lazyLoadingInPrevNextAmount&&S.params.lazyLoadingInPrevNextAmount>1){var s=S.params.lazyLoadingInPrevNextAmount,i=t,r=Math.min(S.activeIndex+i+Math.max(s,i),S.slides.length),n=Math.max(S.activeIndex-Math.max(i,s),0);for(e=S.activeIndex+t;e<r;e++)S.slides[e]&&S.lazy.loadImageInSlide(e);for(e=n;e<S.activeIndex;e++)S.slides[e]&&S.lazy.loadImageInSlide(e)}else{var o=S.wrapper.children("."+S.params.slideNextClass);o.length>0&&S.lazy.loadImageInSlide(o.index());var l=S.wrapper.children("."+S.params.slidePrevClass);l.length>0&&S.lazy.loadImageInSlide(l.index())}},onTransitionStart:function(){S.params.lazyLoading&&(S.params.lazyLoadingOnTransitionStart||!S.params.lazyLoadingOnTransitionStart&&!S.lazy.initialImageLoaded)&&S.lazy.load()},onTransitionEnd:function(){S.params.lazyLoading&&!S.params.lazyLoadingOnTransitionStart&&S.lazy.load()}},S.scrollbar={isTouched:!1,setDragPosition:function(e){var a=S.scrollbar,t=S.isHorizontal()?"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].pageX:e.pageX||e.clientX:"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].pageY:e.pageY||e.clientY,s=t-a.track.offset()[S.isHorizontal()?"left":"top"]-a.dragSize/2,i=-S.minTranslate()*a.moveDivider,r=-S.maxTranslate()*a.moveDivider;s<i?s=i:s>r&&(s=r),s=-s/a.moveDivider,S.updateProgress(s),S.setWrapperTranslate(s,!0)},dragStart:function(e){var a=S.scrollbar;a.isTouched=!0,e.preventDefault(),e.stopPropagation(),a.setDragPosition(e),clearTimeout(a.dragTimeout),a.track.transition(0),S.params.scrollbarHide&&a.track.css("opacity",1),S.wrapper.transition(100),a.drag.transition(100),S.emit("onScrollbarDragStart",S)},dragMove:function(e){var a=S.scrollbar;a.isTouched&&(e.preventDefault?e.preventDefault():e.returnValue=!1,a.setDragPosition(e),S.wrapper.transition(0),a.track.transition(0),a.drag.transition(0),S.emit("onScrollbarDragMove",S))},dragEnd:function(e){var a=S.scrollbar;a.isTouched&&(a.isTouched=!1,S.params.scrollbarHide&&(clearTimeout(a.dragTimeout),a.dragTimeout=setTimeout(function(){a.track.css("opacity",0),a.track.transition(400)},1e3)),S.emit("onScrollbarDragEnd",S),S.params.scrollbarSnapOnRelease&&S.slideReset())},draggableEvents:function(){return S.params.simulateTouch!==!1||S.support.touch?S.touchEvents:S.touchEventsDesktop}(),enableDraggable:function(){var e=S.scrollbar,t=S.support.touch?e.track:document;a(e.track).on(e.draggableEvents.start,e.dragStart),a(t).on(e.draggableEvents.move,e.dragMove),a(t).on(e.draggableEvents.end,e.dragEnd)},disableDraggable:function(){var e=S.scrollbar,t=S.support.touch?e.track:document;a(e.track).off(S.draggableEvents.start,e.dragStart),a(t).off(S.draggableEvents.move,e.dragMove),a(t).off(S.draggableEvents.end,e.dragEnd)},set:function(){if(S.params.scrollbar){var e=S.scrollbar;e.track=a(S.params.scrollbar),S.params.uniqueNavElements&&"string"==typeof S.params.scrollbar&&e.track.length>1&&1===S.container.find(S.params.scrollbar).length&&(e.track=S.container.find(S.params.scrollbar)),e.drag=e.track.find(".swiper-scrollbar-drag"),0===e.drag.length&&(e.drag=a('<div class="swiper-scrollbar-drag"></div>'),e.track.append(e.drag)),e.drag[0].style.width="",e.drag[0].style.height="",e.trackSize=S.isHorizontal()?e.track[0].offsetWidth:e.track[0].offsetHeight,e.divider=S.size/S.virtualSize,e.moveDivider=e.divider*(e.trackSize/S.size),e.dragSize=e.trackSize*e.divider,S.isHorizontal()?e.drag[0].style.width=e.dragSize+"px":e.drag[0].style.height=e.dragSize+"px",e.divider>=1?e.track[0].style.display="none":e.track[0].style.display="",S.params.scrollbarHide&&(e.track[0].style.opacity=0)}},setTranslate:function(){if(S.params.scrollbar){var e,a=S.scrollbar,t=(S.translate||0,a.dragSize);e=(a.trackSize-a.dragSize)*S.progress,S.rtl&&S.isHorizontal()?(e=-e,e>0?(t=a.dragSize-e,e=0):-e+a.dragSize>a.trackSize&&(t=a.trackSize+e)):e<0?(t=a.dragSize+e,e=0):e+a.dragSize>a.trackSize&&(t=a.trackSize-e),S.isHorizontal()?(S.support.transforms3d?a.drag.transform("translate3d("+e+"px, 0, 0)"):a.drag.transform("translateX("+e+"px)"),a.drag[0].style.width=t+"px"):(S.support.transforms3d?a.drag.transform("translate3d(0px, "+e+"px, 0)"):a.drag.transform("translateY("+e+"px)"),a.drag[0].style.height=t+"px"),S.params.scrollbarHide&&(clearTimeout(a.timeout),a.track[0].style.opacity=1,a.timeout=setTimeout(function(){a.track[0].style.opacity=0,a.track.transition(400)},1e3))}},setTransition:function(e){S.params.scrollbar&&S.scrollbar.drag.transition(e)}},S.controller={LinearSpline:function(e,a){this.x=e,this.y=a,this.lastIndex=e.length-1;var t,s;this.x.length;this.interpolate=function(e){return e?(s=i(this.x,e),t=s-1,(e-this.x[t])*(this.y[s]-this.y[t])/(this.x[s]-this.x[t])+this.y[t]):0};var i=function(){var e,a,t;return function(s,i){for(a=-1,e=s.length;e-a>1;)s[t=e+a>>1]<=i?a=t:e=t;return e}}()},getInterpolateFunction:function(e){S.controller.spline||(S.controller.spline=S.params.loop?new S.controller.LinearSpline(S.slidesGrid,e.slidesGrid):new S.controller.LinearSpline(S.snapGrid,e.snapGrid))},setTranslate:function(e,a){function s(a){e=a.rtl&&"horizontal"===a.params.direction?-S.translate:S.translate,"slide"===S.params.controlBy&&(S.controller.getInterpolateFunction(a),r=-S.controller.spline.interpolate(-e)),r&&"container"!==S.params.controlBy||(i=(a.maxTranslate()-a.minTranslate())/(S.maxTranslate()-S.minTranslate()),r=(e-S.minTranslate())*i+a.minTranslate()),S.params.controlInverse&&(r=a.maxTranslate()-r),a.updateProgress(r),a.setWrapperTranslate(r,!1,S),a.updateActiveIndex()}var i,r,n=S.params.control;if(S.isArray(n))for(var o=0;o<n.length;o++)n[o]!==a&&n[o]instanceof t&&s(n[o]);else n instanceof t&&a!==n&&s(n)},setTransition:function(e,a){function s(a){a.setWrapperTransition(e,S),0!==e&&(a.onTransitionStart(),a.wrapper.transitionEnd(function(){r&&(a.params.loop&&"slide"===S.params.controlBy&&a.fixLoop(),a.onTransitionEnd())}))}var i,r=S.params.control;if(S.isArray(r))for(i=0;i<r.length;i++)r[i]!==a&&r[i]instanceof t&&s(r[i]);else r instanceof t&&a!==r&&s(r)}},S.hashnav={onHashCange:function(e,a){var t=document.location.hash.replace("#",""),s=S.slides.eq(S.activeIndex).attr("data-hash");t!==s&&S.slideTo(S.wrapper.children("."+S.params.slideClass+'[data-hash="'+t+'"]').index());
},attachEvents:function(e){var t=e?"off":"on";a(window)[t]("hashchange",S.hashnav.onHashCange)},setHash:function(){if(S.hashnav.initialized&&S.params.hashnav)if(S.params.replaceState&&window.history&&window.history.replaceState)window.history.replaceState(null,null,"#"+S.slides.eq(S.activeIndex).attr("data-hash")||"");else{var e=S.slides.eq(S.activeIndex),a=e.attr("data-hash")||e.attr("data-history");document.location.hash=a||""}},init:function(){if(S.params.hashnav&&!S.params.history){S.hashnav.initialized=!0;var e=document.location.hash.replace("#","");if(e){for(var a=0,t=0,s=S.slides.length;t<s;t++){var i=S.slides.eq(t),r=i.attr("data-hash")||i.attr("data-history");if(r===e&&!i.hasClass(S.params.slideDuplicateClass)){var n=i.index();S.slideTo(n,a,S.params.runCallbacksOnInit,!0)}}S.params.hashnavWatchState&&S.hashnav.attachEvents()}}},destroy:function(){S.params.hashnavWatchState&&S.hashnav.attachEvents(!0)}},S.history={init:function(){if(S.params.history){if(!window.history||!window.history.pushState)return S.params.history=!1,void(S.params.hashnav=!0);S.history.initialized=!0,this.paths=this.getPathValues(),(this.paths.key||this.paths.value)&&(this.scrollToSlide(0,this.paths.value,S.params.runCallbacksOnInit),S.params.replaceState||window.addEventListener("popstate",this.setHistoryPopState))}},setHistoryPopState:function(){S.history.paths=S.history.getPathValues(),S.history.scrollToSlide(S.params.speed,S.history.paths.value,!1)},getPathValues:function(){var e=window.location.pathname.slice(1).split("/"),a=e.length,t=e[a-2],s=e[a-1];return{key:t,value:s}},setHistory:function(e,a){if(S.history.initialized&&S.params.history){var t=S.slides.eq(a),s=this.slugify(t.attr("data-history"));window.location.pathname.includes(e)||(s=e+"/"+s),S.params.replaceState?window.history.replaceState(null,null,s):window.history.pushState(null,null,s)}},slugify:function(e){return e.toString().toLowerCase().replace(/\s+/g,"-").replace(/[^\w\-]+/g,"").replace(/\-\-+/g,"-").replace(/^-+/,"").replace(/-+$/,"")},scrollToSlide:function(e,a,t){if(a)for(var s=0,i=S.slides.length;s<i;s++){var r=S.slides.eq(s),n=this.slugify(r.attr("data-history"));if(n===a&&!r.hasClass(S.params.slideDuplicateClass)){var o=r.index();S.slideTo(o,e,t)}}else S.slideTo(0,e,t)}},S.disableKeyboardControl=function(){S.params.keyboardControl=!1,a(document).off("keydown",d)},S.enableKeyboardControl=function(){S.params.keyboardControl=!0,a(document).on("keydown",d)},S.mousewheel={event:!1,lastScrollTime:(new window.Date).getTime()},S.params.mousewheelControl&&(S.mousewheel.event=navigator.userAgent.indexOf("firefox")>-1?"DOMMouseScroll":u()?"wheel":"mousewheel"),S.disableMousewheelControl=function(){if(!S.mousewheel.event)return!1;var e=S.container;return"container"!==S.params.mousewheelEventsTarged&&(e=a(S.params.mousewheelEventsTarged)),e.off(S.mousewheel.event,c),!0},S.enableMousewheelControl=function(){if(!S.mousewheel.event)return!1;var e=S.container;return"container"!==S.params.mousewheelEventsTarged&&(e=a(S.params.mousewheelEventsTarged)),e.on(S.mousewheel.event,c),!0},S.parallax={setTranslate:function(){S.container.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(){h(this,S.progress)}),S.slides.each(function(){var e=a(this);e.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(){var a=Math.min(Math.max(e[0].progress,-1),1);h(this,a)})})},setTransition:function(e){"undefined"==typeof e&&(e=S.params.speed),S.container.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function(){var t=a(this),s=parseInt(t.attr("data-swiper-parallax-duration"),10)||e;0===e&&(s=0),t.transition(s)})}},S.zoom={scale:1,currentScale:1,isScaling:!1,gesture:{slide:void 0,slideWidth:void 0,slideHeight:void 0,image:void 0,imageWrap:void 0,zoomMax:S.params.zoomMax},image:{isTouched:void 0,isMoved:void 0,currentX:void 0,currentY:void 0,minX:void 0,minY:void 0,maxX:void 0,maxY:void 0,width:void 0,height:void 0,startX:void 0,startY:void 0,touchesStart:{},touchesCurrent:{}},velocity:{x:void 0,y:void 0,prevPositionX:void 0,prevPositionY:void 0,prevTime:void 0},getDistanceBetweenTouches:function(e){if(e.targetTouches.length<2)return 1;var a=e.targetTouches[0].pageX,t=e.targetTouches[0].pageY,s=e.targetTouches[1].pageX,i=e.targetTouches[1].pageY,r=Math.sqrt(Math.pow(s-a,2)+Math.pow(i-t,2));return r},onGestureStart:function(e){var t=S.zoom;if(!S.support.gestures){if("touchstart"!==e.type||"touchstart"===e.type&&e.targetTouches.length<2)return;t.gesture.scaleStart=t.getDistanceBetweenTouches(e)}return t.gesture.slide&&t.gesture.slide.length||(t.gesture.slide=a(this),0===t.gesture.slide.length&&(t.gesture.slide=S.slides.eq(S.activeIndex)),t.gesture.image=t.gesture.slide.find("img, svg, canvas"),t.gesture.imageWrap=t.gesture.image.parent("."+S.params.zoomContainerClass),t.gesture.zoomMax=t.gesture.imageWrap.attr("data-swiper-zoom")||S.params.zoomMax,0!==t.gesture.imageWrap.length)?(t.gesture.image.transition(0),void(t.isScaling=!0)):void(t.gesture.image=void 0)},onGestureChange:function(e){var a=S.zoom;if(!S.support.gestures){if("touchmove"!==e.type||"touchmove"===e.type&&e.targetTouches.length<2)return;a.gesture.scaleMove=a.getDistanceBetweenTouches(e)}a.gesture.image&&0!==a.gesture.image.length&&(S.support.gestures?a.scale=e.scale*a.currentScale:a.scale=a.gesture.scaleMove/a.gesture.scaleStart*a.currentScale,a.scale>a.gesture.zoomMax&&(a.scale=a.gesture.zoomMax-1+Math.pow(a.scale-a.gesture.zoomMax+1,.5)),a.scale<S.params.zoomMin&&(a.scale=S.params.zoomMin+1-Math.pow(S.params.zoomMin-a.scale+1,.5)),a.gesture.image.transform("translate3d(0,0,0) scale("+a.scale+")"))},onGestureEnd:function(e){var a=S.zoom;!S.support.gestures&&("touchend"!==e.type||"touchend"===e.type&&e.changedTouches.length<2)||a.gesture.image&&0!==a.gesture.image.length&&(a.scale=Math.max(Math.min(a.scale,a.gesture.zoomMax),S.params.zoomMin),a.gesture.image.transition(S.params.speed).transform("translate3d(0,0,0) scale("+a.scale+")"),a.currentScale=a.scale,a.isScaling=!1,1===a.scale&&(a.gesture.slide=void 0))},onTouchStart:function(e,a){var t=e.zoom;t.gesture.image&&0!==t.gesture.image.length&&(t.image.isTouched||("android"===e.device.os&&a.preventDefault(),t.image.isTouched=!0,t.image.touchesStart.x="touchstart"===a.type?a.targetTouches[0].pageX:a.pageX,t.image.touchesStart.y="touchstart"===a.type?a.targetTouches[0].pageY:a.pageY))},onTouchMove:function(e){var a=S.zoom;if(a.gesture.image&&0!==a.gesture.image.length&&(S.allowClick=!1,a.image.isTouched&&a.gesture.slide)){a.image.isMoved||(a.image.width=a.gesture.image[0].offsetWidth,a.image.height=a.gesture.image[0].offsetHeight,a.image.startX=S.getTranslate(a.gesture.imageWrap[0],"x")||0,a.image.startY=S.getTranslate(a.gesture.imageWrap[0],"y")||0,a.gesture.slideWidth=a.gesture.slide[0].offsetWidth,a.gesture.slideHeight=a.gesture.slide[0].offsetHeight,a.gesture.imageWrap.transition(0));var t=a.image.width*a.scale,s=a.image.height*a.scale;if(!(t<a.gesture.slideWidth&&s<a.gesture.slideHeight)){if(a.image.minX=Math.min(a.gesture.slideWidth/2-t/2,0),a.image.maxX=-a.image.minX,a.image.minY=Math.min(a.gesture.slideHeight/2-s/2,0),a.image.maxY=-a.image.minY,a.image.touchesCurrent.x="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,a.image.touchesCurrent.y="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY,!a.image.isMoved&&!a.isScaling){if(S.isHorizontal()&&Math.floor(a.image.minX)===Math.floor(a.image.startX)&&a.image.touchesCurrent.x<a.image.touchesStart.x||Math.floor(a.image.maxX)===Math.floor(a.image.startX)&&a.image.touchesCurrent.x>a.image.touchesStart.x)return void(a.image.isTouched=!1);if(!S.isHorizontal()&&Math.floor(a.image.minY)===Math.floor(a.image.startY)&&a.image.touchesCurrent.y<a.image.touchesStart.y||Math.floor(a.image.maxY)===Math.floor(a.image.startY)&&a.image.touchesCurrent.y>a.image.touchesStart.y)return void(a.image.isTouched=!1)}e.preventDefault(),e.stopPropagation(),a.image.isMoved=!0,a.image.currentX=a.image.touchesCurrent.x-a.image.touchesStart.x+a.image.startX,a.image.currentY=a.image.touchesCurrent.y-a.image.touchesStart.y+a.image.startY,a.image.currentX<a.image.minX&&(a.image.currentX=a.image.minX+1-Math.pow(a.image.minX-a.image.currentX+1,.8)),a.image.currentX>a.image.maxX&&(a.image.currentX=a.image.maxX-1+Math.pow(a.image.currentX-a.image.maxX+1,.8)),a.image.currentY<a.image.minY&&(a.image.currentY=a.image.minY+1-Math.pow(a.image.minY-a.image.currentY+1,.8)),a.image.currentY>a.image.maxY&&(a.image.currentY=a.image.maxY-1+Math.pow(a.image.currentY-a.image.maxY+1,.8)),a.velocity.prevPositionX||(a.velocity.prevPositionX=a.image.touchesCurrent.x),a.velocity.prevPositionY||(a.velocity.prevPositionY=a.image.touchesCurrent.y),a.velocity.prevTime||(a.velocity.prevTime=Date.now()),a.velocity.x=(a.image.touchesCurrent.x-a.velocity.prevPositionX)/(Date.now()-a.velocity.prevTime)/2,a.velocity.y=(a.image.touchesCurrent.y-a.velocity.prevPositionY)/(Date.now()-a.velocity.prevTime)/2,Math.abs(a.image.touchesCurrent.x-a.velocity.prevPositionX)<2&&(a.velocity.x=0),Math.abs(a.image.touchesCurrent.y-a.velocity.prevPositionY)<2&&(a.velocity.y=0),a.velocity.prevPositionX=a.image.touchesCurrent.x,a.velocity.prevPositionY=a.image.touchesCurrent.y,a.velocity.prevTime=Date.now(),a.gesture.imageWrap.transform("translate3d("+a.image.currentX+"px, "+a.image.currentY+"px,0)")}}},onTouchEnd:function(e,a){var t=e.zoom;if(t.gesture.image&&0!==t.gesture.image.length){if(!t.image.isTouched||!t.image.isMoved)return t.image.isTouched=!1,void(t.image.isMoved=!1);t.image.isTouched=!1,t.image.isMoved=!1;var s=300,i=300,r=t.velocity.x*s,n=t.image.currentX+r,o=t.velocity.y*i,l=t.image.currentY+o;0!==t.velocity.x&&(s=Math.abs((n-t.image.currentX)/t.velocity.x)),0!==t.velocity.y&&(i=Math.abs((l-t.image.currentY)/t.velocity.y));var p=Math.max(s,i);t.image.currentX=n,t.image.currentY=l;var d=t.image.width*t.scale,u=t.image.height*t.scale;t.image.minX=Math.min(t.gesture.slideWidth/2-d/2,0),t.image.maxX=-t.image.minX,t.image.minY=Math.min(t.gesture.slideHeight/2-u/2,0),t.image.maxY=-t.image.minY,t.image.currentX=Math.max(Math.min(t.image.currentX,t.image.maxX),t.image.minX),t.image.currentY=Math.max(Math.min(t.image.currentY,t.image.maxY),t.image.minY),t.gesture.imageWrap.transition(p).transform("translate3d("+t.image.currentX+"px, "+t.image.currentY+"px,0)")}},onTransitionEnd:function(e){var a=e.zoom;a.gesture.slide&&e.previousIndex!==e.activeIndex&&(a.gesture.image.transform("translate3d(0,0,0) scale(1)"),a.gesture.imageWrap.transform("translate3d(0,0,0)"),a.gesture.slide=a.gesture.image=a.gesture.imageWrap=void 0,a.scale=a.currentScale=1)},toggleZoom:function(e,t){var s=e.zoom;if(s.gesture.slide||(s.gesture.slide=e.clickedSlide?a(e.clickedSlide):e.slides.eq(e.activeIndex),s.gesture.image=s.gesture.slide.find("img, svg, canvas"),s.gesture.imageWrap=s.gesture.image.parent("."+e.params.zoomContainerClass)),s.gesture.image&&0!==s.gesture.image.length){var i,r,n,o,l,p,d,u,c,m,h,g,f,v,w,y,x,T;"undefined"==typeof s.image.touchesStart.x&&t?(i="touchend"===t.type?t.changedTouches[0].pageX:t.pageX,r="touchend"===t.type?t.changedTouches[0].pageY:t.pageY):(i=s.image.touchesStart.x,r=s.image.touchesStart.y),s.scale&&1!==s.scale?(s.scale=s.currentScale=1,s.gesture.imageWrap.transition(300).transform("translate3d(0,0,0)"),s.gesture.image.transition(300).transform("translate3d(0,0,0) scale(1)"),s.gesture.slide=void 0):(s.scale=s.currentScale=s.gesture.imageWrap.attr("data-swiper-zoom")||e.params.zoomMax,t?(x=s.gesture.slide[0].offsetWidth,T=s.gesture.slide[0].offsetHeight,n=s.gesture.slide.offset().left,o=s.gesture.slide.offset().top,l=n+x/2-i,p=o+T/2-r,c=s.gesture.image[0].offsetWidth,m=s.gesture.image[0].offsetHeight,h=c*s.scale,g=m*s.scale,f=Math.min(x/2-h/2,0),v=Math.min(T/2-g/2,0),w=-f,y=-v,d=l*s.scale,u=p*s.scale,d<f&&(d=f),d>w&&(d=w),u<v&&(u=v),u>y&&(u=y)):(d=0,u=0),s.gesture.imageWrap.transition(300).transform("translate3d("+d+"px, "+u+"px,0)"),s.gesture.image.transition(300).transform("translate3d(0,0,0) scale("+s.scale+")"))}},attachEvents:function(e){var t=e?"off":"on";if(S.params.zoom){var s=(S.slides,!("touchstart"!==S.touchEvents.start||!S.support.passiveListener||!S.params.passiveListeners)&&{passive:!0,capture:!1});S.support.gestures?(S.slides[t]("gesturestart",S.zoom.onGestureStart,s),S.slides[t]("gesturechange",S.zoom.onGestureChange,s),S.slides[t]("gestureend",S.zoom.onGestureEnd,s)):"touchstart"===S.touchEvents.start&&(S.slides[t](S.touchEvents.start,S.zoom.onGestureStart,s),S.slides[t](S.touchEvents.move,S.zoom.onGestureChange,s),S.slides[t](S.touchEvents.end,S.zoom.onGestureEnd,s)),S[t]("touchStart",S.zoom.onTouchStart),S.slides.each(function(e,s){a(s).find("."+S.params.zoomContainerClass).length>0&&a(s)[t](S.touchEvents.move,S.zoom.onTouchMove)}),S[t]("touchEnd",S.zoom.onTouchEnd),S[t]("transitionEnd",S.zoom.onTransitionEnd),S.params.zoomToggle&&S.on("doubleTap",S.zoom.toggleZoom)}},init:function(){S.zoom.attachEvents()},destroy:function(){S.zoom.attachEvents(!0)}},S._plugins=[];for(var N in S.plugins){var W=S.plugins[N](S,S.params[N]);W&&S._plugins.push(W)}return S.callPlugins=function(e){for(var a=0;a<S._plugins.length;a++)e in S._plugins[a]&&S._plugins[a][e](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])},S.emitterEventListeners={},S.emit=function(e){S.params[e]&&S.params[e](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);var a;if(S.emitterEventListeners[e])for(a=0;a<S.emitterEventListeners[e].length;a++)S.emitterEventListeners[e][a](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);S.callPlugins&&S.callPlugins(e,arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])},S.on=function(e,a){return e=g(e),S.emitterEventListeners[e]||(S.emitterEventListeners[e]=[]),S.emitterEventListeners[e].push(a),S},S.off=function(e,a){var t;if(e=g(e),"undefined"==typeof a)return S.emitterEventListeners[e]=[],S;if(S.emitterEventListeners[e]&&0!==S.emitterEventListeners[e].length){for(t=0;t<S.emitterEventListeners[e].length;t++)S.emitterEventListeners[e][t]===a&&S.emitterEventListeners[e].splice(t,1);return S}},S.once=function(e,a){e=g(e);var t=function(){a(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]),S.off(e,t)};return S.on(e,t),S},S.a11y={makeFocusable:function(e){return e.attr("tabIndex","0"),e},addRole:function(e,a){return e.attr("role",a),e},addLabel:function(e,a){return e.attr("aria-label",a),e},disable:function(e){return e.attr("aria-disabled",!0),e},enable:function(e){return e.attr("aria-disabled",!1),e},onEnterKey:function(e){13===e.keyCode&&(a(e.target).is(S.params.nextButton)?(S.onClickNext(e),S.isEnd?S.a11y.notify(S.params.lastSlideMessage):S.a11y.notify(S.params.nextSlideMessage)):a(e.target).is(S.params.prevButton)&&(S.onClickPrev(e),S.isBeginning?S.a11y.notify(S.params.firstSlideMessage):S.a11y.notify(S.params.prevSlideMessage)),a(e.target).is("."+S.params.bulletClass)&&a(e.target)[0].click())},liveRegion:a('<span class="'+S.params.notificationClass+'" aria-live="assertive" aria-atomic="true"></span>'),notify:function(e){var a=S.a11y.liveRegion;0!==a.length&&(a.html(""),a.html(e))},init:function(){S.params.nextButton&&S.nextButton&&S.nextButton.length>0&&(S.a11y.makeFocusable(S.nextButton),S.a11y.addRole(S.nextButton,"button"),S.a11y.addLabel(S.nextButton,S.params.nextSlideMessage)),S.params.prevButton&&S.prevButton&&S.prevButton.length>0&&(S.a11y.makeFocusable(S.prevButton),S.a11y.addRole(S.prevButton,"button"),S.a11y.addLabel(S.prevButton,S.params.prevSlideMessage)),a(S.container).append(S.a11y.liveRegion)},initPagination:function(){S.params.pagination&&S.params.paginationClickable&&S.bullets&&S.bullets.length&&S.bullets.each(function(){var e=a(this);S.a11y.makeFocusable(e),S.a11y.addRole(e,"button"),S.a11y.addLabel(e,S.params.paginationBulletMessage.replace(/{{index}}/,e.index()+1))})},destroy:function(){S.a11y.liveRegion&&S.a11y.liveRegion.length>0&&S.a11y.liveRegion.remove()}},S.init=function(){S.params.loop&&S.createLoop(),S.updateContainerSize(),S.updateSlidesSize(),S.updatePagination(),S.params.scrollbar&&S.scrollbar&&(S.scrollbar.set(),S.params.scrollbarDraggable&&S.scrollbar.enableDraggable()),"slide"!==S.params.effect&&S.effects[S.params.effect]&&(S.params.loop||S.updateProgress(),S.effects[S.params.effect].setTranslate()),S.params.loop?S.slideTo(S.params.initialSlide+S.loopedSlides,0,S.params.runCallbacksOnInit):(S.slideTo(S.params.initialSlide,0,S.params.runCallbacksOnInit),0===S.params.initialSlide&&(S.parallax&&S.params.parallax&&S.parallax.setTranslate(),S.lazy&&S.params.lazyLoading&&(S.lazy.load(),S.lazy.initialImageLoaded=!0))),S.attachEvents(),S.params.observer&&S.support.observer&&S.initObservers(),S.params.preloadImages&&!S.params.lazyLoading&&S.preloadImages(),S.params.zoom&&S.zoom&&S.zoom.init(),S.params.autoplay&&S.startAutoplay(),S.params.keyboardControl&&S.enableKeyboardControl&&S.enableKeyboardControl(),S.params.mousewheelControl&&S.enableMousewheelControl&&S.enableMousewheelControl(),S.params.hashnavReplaceState&&(S.params.replaceState=S.params.hashnavReplaceState),S.params.history&&S.history&&S.history.init(),S.params.hashnav&&S.hashnav&&S.hashnav.init(),S.params.a11y&&S.a11y&&S.a11y.init(),S.emit("onInit",S)},S.cleanupStyles=function(){S.container.removeClass(S.classNames.join(" ")).removeAttr("style"),S.wrapper.removeAttr("style"),S.slides&&S.slides.length&&S.slides.removeClass([S.params.slideVisibleClass,S.params.slideActiveClass,S.params.slideNextClass,S.params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-column").removeAttr("data-swiper-row"),S.paginationContainer&&S.paginationContainer.length&&S.paginationContainer.removeClass(S.params.paginationHiddenClass),S.bullets&&S.bullets.length&&S.bullets.removeClass(S.params.bulletActiveClass),S.params.prevButton&&a(S.params.prevButton).removeClass(S.params.buttonDisabledClass),S.params.nextButton&&a(S.params.nextButton).removeClass(S.params.buttonDisabledClass),S.params.scrollbar&&S.scrollbar&&(S.scrollbar.track&&S.scrollbar.track.length&&S.scrollbar.track.removeAttr("style"),S.scrollbar.drag&&S.scrollbar.drag.length&&S.scrollbar.drag.removeAttr("style"))},S.destroy=function(e,a){S.detachEvents(),S.stopAutoplay(),S.params.scrollbar&&S.scrollbar&&S.params.scrollbarDraggable&&S.scrollbar.disableDraggable(),S.params.loop&&S.destroyLoop(),a&&S.cleanupStyles(),S.disconnectObservers(),S.params.zoom&&S.zoom&&S.zoom.destroy(),S.params.keyboardControl&&S.disableKeyboardControl&&S.disableKeyboardControl(),S.params.mousewheelControl&&S.disableMousewheelControl&&S.disableMousewheelControl(),S.params.a11y&&S.a11y&&S.a11y.destroy(),S.params.history&&!S.params.replaceState&&window.removeEventListener("popstate",S.history.setHistoryPopState),S.params.hashnav&&S.hashnav&&S.hashnav.destroy(),S.emit("onDestroy"),e!==!1&&(S=null)},S.init(),S}};t.prototype={isSafari:function(){var e=navigator.userAgent.toLowerCase();return e.indexOf("safari")>=0&&e.indexOf("chrome")<0&&e.indexOf("android")<0}(),isUiWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),isArray:function(e){return"[object Array]"===Object.prototype.toString.apply(e)},browser:{ie:window.navigator.pointerEnabled||window.navigator.msPointerEnabled,ieTouch:window.navigator.msPointerEnabled&&window.navigator.msMaxTouchPoints>1||window.navigator.pointerEnabled&&window.navigator.maxTouchPoints>1,lteIE9:function(){var e=document.createElement("div");return e.innerHTML="<!--[if lte IE 9]><i></i><![endif]-->",1===e.getElementsByTagName("i").length}()},device:function(){var e=navigator.userAgent,a=e.match(/(Android);?[\s\/]+([\d.]+)?/),t=e.match(/(iPad).*OS\s([\d_]+)/),s=e.match(/(iPod)(.*OS\s([\d_]+))?/),i=!t&&e.match(/(iPhone\sOS)\s([\d_]+)/);return{ios:t||i||s,android:a}}(),support:{touch:window.Modernizr&&Modernizr.touch===!0||function(){return!!("ontouchstart"in window||window.DocumentTouch&&document instanceof DocumentTouch)}(),transforms3d:window.Modernizr&&Modernizr.csstransforms3d===!0||function(){var e=document.createElement("div").style;return"webkitPerspective"in e||"MozPerspective"in e||"OPerspective"in e||"MsPerspective"in e||"perspective"in e}(),flexbox:function(){for(var e=document.createElement("div").style,a="alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "),t=0;t<a.length;t++)if(a[t]in e)return!0}(),observer:function(){return"MutationObserver"in window||"WebkitMutationObserver"in window}(),passiveListener:function(){var e=!1;try{var a=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("testPassiveListener",null,a)}catch(e){}return e}(),gestures:function(){return"ongesturestart"in window}()},plugins:{}};for(var s=(function(){var e=function(e){var a=this,t=0;for(t=0;t<e.length;t++)a[t]=e[t];return a.length=e.length,this},a=function(a,t){var s=[],i=0;if(a&&!t&&a instanceof e)return a;if(a)if("string"==typeof a){var r,n,o=a.trim();if(o.indexOf("<")>=0&&o.indexOf(">")>=0){var l="div";for(0===o.indexOf("<li")&&(l="ul"),0===o.indexOf("<tr")&&(l="tbody"),0!==o.indexOf("<td")&&0!==o.indexOf("<th")||(l="tr"),0===o.indexOf("<tbody")&&(l="table"),0===o.indexOf("<option")&&(l="select"),n=document.createElement(l),n.innerHTML=a,i=0;i<n.childNodes.length;i++)s.push(n.childNodes[i])}else for(r=t||"#"!==a[0]||a.match(/[ .<>:~]/)?(t||document).querySelectorAll(a):[document.getElementById(a.split("#")[1])],i=0;i<r.length;i++)r[i]&&s.push(r[i])}else if(a.nodeType||a===window||a===document)s.push(a);else if(a.length>0&&a[0].nodeType)for(i=0;i<a.length;i++)s.push(a[i]);return new e(s)};return e.prototype={addClass:function(e){if("undefined"==typeof e)return this;for(var a=e.split(" "),t=0;t<a.length;t++)for(var s=0;s<this.length;s++)this[s].classList.add(a[t]);return this},removeClass:function(e){for(var a=e.split(" "),t=0;t<a.length;t++)for(var s=0;s<this.length;s++)this[s].classList.remove(a[t]);return this},hasClass:function(e){return!!this[0]&&this[0].classList.contains(e)},toggleClass:function(e){for(var a=e.split(" "),t=0;t<a.length;t++)for(var s=0;s<this.length;s++)this[s].classList.toggle(a[t]);return this},attr:function(e,a){if(1===arguments.length&&"string"==typeof e)return this[0]?this[0].getAttribute(e):void 0;for(var t=0;t<this.length;t++)if(2===arguments.length)this[t].setAttribute(e,a);else for(var s in e)this[t][s]=e[s],this[t].setAttribute(s,e[s]);return this},removeAttr:function(e){for(var a=0;a<this.length;a++)this[a].removeAttribute(e);return this},data:function(e,a){if("undefined"!=typeof a){for(var t=0;t<this.length;t++){var s=this[t];s.dom7ElementDataStorage||(s.dom7ElementDataStorage={}),s.dom7ElementDataStorage[e]=a}return this}if(this[0]){var i=this[0].getAttribute("data-"+e);return i?i:this[0].dom7ElementDataStorage&&e in this[0].dom7ElementDataStorage?this[0].dom7ElementDataStorage[e]:void 0}},transform:function(e){for(var a=0;a<this.length;a++){var t=this[a].style;t.webkitTransform=t.MsTransform=t.msTransform=t.MozTransform=t.OTransform=t.transform=e}return this},transition:function(e){"string"!=typeof e&&(e+="ms");for(var a=0;a<this.length;a++){var t=this[a].style;t.webkitTransitionDuration=t.MsTransitionDuration=t.msTransitionDuration=t.MozTransitionDuration=t.OTransitionDuration=t.transitionDuration=e}return this},on:function(e,t,s,i){function r(e){var i=e.target;if(a(i).is(t))s.call(i,e);else for(var r=a(i).parents(),n=0;n<r.length;n++)a(r[n]).is(t)&&s.call(r[n],e)}var n,o,l=e.split(" ");for(n=0;n<this.length;n++)if("function"==typeof t||t===!1)for("function"==typeof t&&(s=arguments[1],i=arguments[2]||!1),o=0;o<l.length;o++)this[n].addEventListener(l[o],s,i);else for(o=0;o<l.length;o++)this[n].dom7LiveListeners||(this[n].dom7LiveListeners=[]),this[n].dom7LiveListeners.push({listener:s,liveListener:r}),this[n].addEventListener(l[o],r,i);return this},off:function(e,a,t,s){for(var i=e.split(" "),r=0;r<i.length;r++)for(var n=0;n<this.length;n++)if("function"==typeof a||a===!1)"function"==typeof a&&(t=arguments[1],s=arguments[2]||!1),this[n].removeEventListener(i[r],t,s);else if(this[n].dom7LiveListeners)for(var o=0;o<this[n].dom7LiveListeners.length;o++)this[n].dom7LiveListeners[o].listener===t&&this[n].removeEventListener(i[r],this[n].dom7LiveListeners[o].liveListener,s);return this},once:function(e,a,t,s){function i(n){t(n),r.off(e,a,i,s)}var r=this;"function"==typeof a&&(a=!1,t=arguments[1],s=arguments[2]),r.on(e,a,i,s)},trigger:function(e,a){for(var t=0;t<this.length;t++){var s;try{s=new window.CustomEvent(e,{detail:a,bubbles:!0,cancelable:!0})}catch(t){s=document.createEvent("Event"),s.initEvent(e,!0,!0),s.detail=a}this[t].dispatchEvent(s)}return this},transitionEnd:function(e){function a(r){if(r.target===this)for(e.call(this,r),t=0;t<s.length;t++)i.off(s[t],a)}var t,s=["webkitTransitionEnd","transitionend","oTransitionEnd","MSTransitionEnd","msTransitionEnd"],i=this;if(e)for(t=0;t<s.length;t++)i.on(s[t],a);return this},width:function(){return this[0]===window?window.innerWidth:this.length>0?parseFloat(this.css("width")):null},outerWidth:function(e){return this.length>0?e?this[0].offsetWidth+parseFloat(this.css("margin-right"))+parseFloat(this.css("margin-left")):this[0].offsetWidth:null},height:function(){return this[0]===window?window.innerHeight:this.length>0?parseFloat(this.css("height")):null},outerHeight:function(e){return this.length>0?e?this[0].offsetHeight+parseFloat(this.css("margin-top"))+parseFloat(this.css("margin-bottom")):this[0].offsetHeight:null},offset:function(){if(this.length>0){var e=this[0],a=e.getBoundingClientRect(),t=document.body,s=e.clientTop||t.clientTop||0,i=e.clientLeft||t.clientLeft||0,r=window.pageYOffset||e.scrollTop,n=window.pageXOffset||e.scrollLeft;return{top:a.top+r-s,left:a.left+n-i}}return null},css:function(e,a){var t;if(1===arguments.length){if("string"!=typeof e){for(t=0;t<this.length;t++)for(var s in e)this[t].style[s]=e[s];return this}if(this[0])return window.getComputedStyle(this[0],null).getPropertyValue(e)}if(2===arguments.length&&"string"==typeof e){for(t=0;t<this.length;t++)this[t].style[e]=a;return this}return this},each:function(e){for(var a=0;a<this.length;a++)e.call(this[a],a,this[a]);return this},html:function(e){if("undefined"==typeof e)return this[0]?this[0].innerHTML:void 0;for(var a=0;a<this.length;a++)this[a].innerHTML=e;return this},text:function(e){if("undefined"==typeof e)return this[0]?this[0].textContent.trim():null;for(var a=0;a<this.length;a++)this[a].textContent=e;return this},is:function(t){if(!this[0])return!1;var s,i;if("string"==typeof t){var r=this[0];if(r===document)return t===document;if(r===window)return t===window;if(r.matches)return r.matches(t);if(r.webkitMatchesSelector)return r.webkitMatchesSelector(t);if(r.mozMatchesSelector)return r.mozMatchesSelector(t);if(r.msMatchesSelector)return r.msMatchesSelector(t);for(s=a(t),i=0;i<s.length;i++)if(s[i]===this[0])return!0;return!1}if(t===document)return this[0]===document;if(t===window)return this[0]===window;if(t.nodeType||t instanceof e){for(s=t.nodeType?[t]:t,i=0;i<s.length;i++)if(s[i]===this[0])return!0;return!1}return!1},index:function(){if(this[0]){for(var e=this[0],a=0;null!==(e=e.previousSibling);)1===e.nodeType&&a++;return a}},eq:function(a){if("undefined"==typeof a)return this;var t,s=this.length;return a>s-1?new e([]):a<0?(t=s+a,new e(t<0?[]:[this[t]])):new e([this[a]])},append:function(a){var t,s;for(t=0;t<this.length;t++)if("string"==typeof a){var i=document.createElement("div");for(i.innerHTML=a;i.firstChild;)this[t].appendChild(i.firstChild)}else if(a instanceof e)for(s=0;s<a.length;s++)this[t].appendChild(a[s]);else this[t].appendChild(a);return this},prepend:function(a){var t,s;for(t=0;t<this.length;t++)if("string"==typeof a){var i=document.createElement("div");for(i.innerHTML=a,s=i.childNodes.length-1;s>=0;s--)this[t].insertBefore(i.childNodes[s],this[t].childNodes[0])}else if(a instanceof e)for(s=0;s<a.length;s++)this[t].insertBefore(a[s],this[t].childNodes[0]);else this[t].insertBefore(a,this[t].childNodes[0]);return this},insertBefore:function(e){for(var t=a(e),s=0;s<this.length;s++)if(1===t.length)t[0].parentNode.insertBefore(this[s],t[0]);else if(t.length>1)for(var i=0;i<t.length;i++)t[i].parentNode.insertBefore(this[s].cloneNode(!0),t[i])},insertAfter:function(e){for(var t=a(e),s=0;s<this.length;s++)if(1===t.length)t[0].parentNode.insertBefore(this[s],t[0].nextSibling);else if(t.length>1)for(var i=0;i<t.length;i++)t[i].parentNode.insertBefore(this[s].cloneNode(!0),t[i].nextSibling)},next:function(t){return new e(this.length>0?t?this[0].nextElementSibling&&a(this[0].nextElementSibling).is(t)?[this[0].nextElementSibling]:[]:this[0].nextElementSibling?[this[0].nextElementSibling]:[]:[])},nextAll:function(t){var s=[],i=this[0];if(!i)return new e([]);for(;i.nextElementSibling;){var r=i.nextElementSibling;t?a(r).is(t)&&s.push(r):s.push(r),i=r}return new e(s)},prev:function(t){return new e(this.length>0?t?this[0].previousElementSibling&&a(this[0].previousElementSibling).is(t)?[this[0].previousElementSibling]:[]:this[0].previousElementSibling?[this[0].previousElementSibling]:[]:[])},prevAll:function(t){var s=[],i=this[0];if(!i)return new e([]);for(;i.previousElementSibling;){var r=i.previousElementSibling;t?a(r).is(t)&&s.push(r):s.push(r),i=r}return new e(s)},parent:function(e){for(var t=[],s=0;s<this.length;s++)e?a(this[s].parentNode).is(e)&&t.push(this[s].parentNode):t.push(this[s].parentNode);return a(a.unique(t))},parents:function(e){for(var t=[],s=0;s<this.length;s++)for(var i=this[s].parentNode;i;)e?a(i).is(e)&&t.push(i):t.push(i),i=i.parentNode;return a(a.unique(t))},find:function(a){for(var t=[],s=0;s<this.length;s++)for(var i=this[s].querySelectorAll(a),r=0;r<i.length;r++)t.push(i[r]);return new e(t)},children:function(t){for(var s=[],i=0;i<this.length;i++)for(var r=this[i].childNodes,n=0;n<r.length;n++)t?1===r[n].nodeType&&a(r[n]).is(t)&&s.push(r[n]):1===r[n].nodeType&&s.push(r[n]);return new e(a.unique(s))},remove:function(){for(var e=0;e<this.length;e++)this[e].parentNode&&this[e].parentNode.removeChild(this[e]);return this},add:function(){var e,t,s=this;for(e=0;e<arguments.length;e++){var i=a(arguments[e]);for(t=0;t<i.length;t++)s[s.length]=i[t],s.length++}return s}},a.fn=e.prototype,a.unique=function(e){for(var a=[],t=0;t<e.length;t++)a.indexOf(e[t])===-1&&a.push(e[t]);return a},a}()),i=["jQuery","Zepto","Dom7"],r=0;r<i.length;r++)window[i[r]]&&e(window[i[r]]);var n;n="undefined"==typeof s?window.Dom7||window.Zepto||window.jQuery:s,n&&("transitionEnd"in n.fn||(n.fn.transitionEnd=function(e){function a(r){if(r.target===this)for(e.call(this,r),t=0;t<s.length;t++)i.off(s[t],a)}var t,s=["webkitTransitionEnd","transitionend","oTransitionEnd","MSTransitionEnd","msTransitionEnd"],i=this;if(e)for(t=0;t<s.length;t++)i.on(s[t],a);return this}),"transform"in n.fn||(n.fn.transform=function(e){for(var a=0;a<this.length;a++){var t=this[a].style;t.webkitTransform=t.MsTransform=t.msTransform=t.MozTransform=t.OTransform=t.transform=e}return this}),"transition"in n.fn||(n.fn.transition=function(e){"string"!=typeof e&&(e+="ms");for(var a=0;a<this.length;a++){var t=this[a].style;t.webkitTransitionDuration=t.MsTransitionDuration=t.msTransitionDuration=t.MozTransitionDuration=t.OTransitionDuration=t.transitionDuration=e}return this}),"outerWidth"in n.fn||(n.fn.outerWidth=function(e){return this.length>0?e?this[0].offsetWidth+parseFloat(this.css("margin-right"))+parseFloat(this.css("margin-left")):this[0].offsetWidth:null})),window.Swiper=t}(),"undefined"!=typeof module?module.exports=window.Swiper:"function"==typeof define&&define.amd&&define([],function(){"use strict";return window.Swiper});
//# sourceMappingURL=maps/swiper.min.js.map

function pricingSlider_() {
    var e = new Swiper(".swiper-container-pricing",{
        pagination: ".swiper-pagination",
        paginationClickable: !0,
        nextButton: ".swiper-button-next",
        prevButton: ".swiper-button-prev",
        loop: true,
        autoplay: 6e3,
        effect: "fade",
        speed: 800,
        fade: {
            crossFade: !1
        }
    })
}
function pricingSlider(id) {
    var query = $('#'+id + " .swiper-container-pricing");
    query.addClass('swiper');
    var e = new Swiper(query[0], {
        pagination: ".swiper-pagination",
        paginationClickable: true,
        nextButton: ".swiper-button-next",
        prevButton: ".swiper-button-prev",
        effect: "fade",
        grabCursor: true,
        fade: {
          crossFade: false
        },
        loop: true,
        autoplay: false
    })
    return e;
}
function detailsSlider(id) {
//    var query = $("[data-id=" + id + "] .swiper-container-details");
    var query = $(".swiper-container-details");
    query.addClass('swiper')
    var e = new Swiper(query[0], {
        pagination: ".swiper-pagination",
        paginationClickable: true,
        nextButton: ".swiper-button-next",
        prevButton: ".swiper-button-prev",
        effect: "fade",
        grabCursor: true,
        lazyLoading: true,
        fade: {
          crossFade: false
        },
        loop: true,
        autoplay: 6e3
    })
    $('img', query).removeClass('load')
    return e;
}
function testimonialSlider2() {
    var e = new Swiper(".swiper-container-testimonial-2",{
        pagination: ".swiper-pagination-testimonial-2",
        paginationClickable: !0,
        nextButton: ".swiper-button-next",
        prevButton: ".swiper-button-prev"
    })
}
function teamSliderGross() {
    var e = new Swiper(".swiper-container-team-gross",{
        pagination: ".swiper-pagination-team-gross",
        paginationClickable: !0,
        nextButton: ".swiper-button-next",
        prevButton: ".swiper-button-prev"
    })
}
function teamSlider() {
    var e = new Swiper(".swiper-container-team",{
        slidesPerView: 8,
        spaceBetween: 0,
        breakpoints: {
            1200: {
                slidesPerView: 5,
                spaceBetween: 0
            },
            768: {
                slidesPerView: 4,
                spaceBetween: 0
            },
            640: {
                slidesPerView: 2,
                spaceBetween: 0
            },
            320: {
                slidesPerView: 1,
                spaceBetween: 0
            }
        }
    })
}

jQuery(document).ready(function($) {
    $(".category-open").on("click", function() {
        $(this).toggleClass("open");
        $(".menu-category-menu-container").toggleClass("open");
    });
    $('.scroll').on('click', function(e) {
        var href = $(this).attr('href');
        $('html, body').animate({
            scrollTop: $(href).offset().top - 140
        }, 'slow');
        e.preventDefault();
    });
    $(".scroll").on("click", function() {
        $(".scroll").removeClass("active");
        $(this).addClass("active");
    });
    $(".open-menu").on("click", function() {
        $(".outer-wrapper").toggleClass("has-push-right");
        $(".menu-push-right").toggleClass("is-active");
        $("body").toggleClass("menu-open");
    });
    $(".menu-push-to-close").on("click", function() {
        $(".outer-wrapper").removeClass("has-push-right");
        $(".menu-push-right").removeClass("is-active");
        $("body").removeClass("menu-open");
    });
    $(".menu-seitenmenue-unten-container .menu-item-has-children").append("<span class='open-sub-menu'></span>");
    $(".open-sub-menu").on("click", function() {
        $(this).prev(".sub-menu").toggleClass("open");
        $(this).parent(".menu-item-has-children").toggleClass("open");
    });
    $(".collapse.in").next(".more-link").addClass("open");
    $(".more-link").on("click", function() {
        $(this).toggleClass("open");
    });
    $("#seminar-form").nextAll("#seminar-form").css("display", "none");
});
$(window).scroll(function() {
    var scroll = $(window).scrollTop();
    if (scroll >= 1) {
        $("header").addClass("fixed");
    } else {
        $("header").removeClass("fixed");
    }
});
$(function() {
    // name your elements here
    var stickyElement = '.sticky-element'
      , // the element you want to make sticky
    bottomElement = 'footer.mobile'; // .fake-footer
    // the bottom element where you want the sticky element to stop (usually the footer) 
    // make sure the element exists on the page before trying to initalize
    if ($(stickyElement).length) {
        $(stickyElement).each(function() {
            // let's save some messy code in clean variables
            // when should we start affixing? (the amount of pixels to the top from the element)
            var fromTop = $(this).offset().top - 140
              , // where is the bottom of the element?
            fromBottom = $(document).height() - ($(this).offset().top + $(this).outerHeight())
              , // where should we stop? (the amount of pixels from the top where the bottom element is)
            // also add the outer height mismatch to the height of the element to account for padding and borders
            stopOn = $(document).height() - ($(bottomElement).offset().top) + ($(this).outerHeight() - $(this).height());
            // if the element doesn't need to get sticky, then skip it so it won't mess up your layout
            if ((fromBottom - stopOn) > 200) {
                // let's put a sticky width on the element and assign it to the top
                $(this).css('width', $(this).width()).css('top', 0).css('position', '');
                // assign the affix to the element
                $(this).affix({
                    offset: {
                        // make it stick where the top pixel of the element is
                        top: fromTop,
                        // make it stop where the top pixel of the bottom element is
                        bottom: stopOn
                    }// when the affix get's called then make sure the position is the default (fixed) and it's at the top
                }).on('affix.bs.affix', function() {
                    $(this).css('top', 140).css('position', '');
                });
            }
            // trigger the scroll event so it always activates 
            $(window).trigger('scroll');
        });
    }
});

(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), indexPath = expand(path, './index'), module, fn;
      module   = cache[path] || cache[indexPath]
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = indexPath]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module ' + name + ' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^..?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
    this.require.modules = modules;
    this.require.cache   = cache;
  }
  return this.require.define;
}).call(this)({
  
  "spine/index": function(exports, require, module) { module.exports = require('./lib/spine'); },"spine/lib/spine": function(exports, require, module) { // Generated by CoffeeScript 1.10.0

/*
Spine.js MVC library
Released under the MIT License
 */

(function() {
  var $, Controller, Events, Log, Model, Module, Spine, createObject, makeArray, moduleKeywords,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Events = {
    bind: function(ev, callback) {
      var base, evs, j, len, name;
      evs = ev.split(' ');
      if (!this.hasOwnProperty('_callbacks')) {
        this._callbacks || (this._callbacks = {});
      }
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        (base = this._callbacks)[name] || (base[name] = []);
        this._callbacks[name].push(callback);
      }
      return this;
    },
    one: function(ev, callback) {
      var handler;
      return this.bind(ev, handler = function() {
        this.unbind(ev, handler);
        return callback.apply(this, arguments);
      });
    },
    trigger: function() {
      var args, callback, ev, j, len, list, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ev = args.shift();
      list = (ref = this._callbacks) != null ? ref[ev] : void 0;
      if (!list) {
        return;
      }
      for (j = 0, len = list.length; j < len; j++) {
        callback = list[j];
        if (callback.apply(this, args) === false) {
          break;
        }
      }
      return true;
    },
    listenTo: function(obj, ev, callback) {
      obj.bind(ev, callback);
      this.listeningTo || (this.listeningTo = []);
      this.listeningTo.push({
        obj: obj,
        ev: ev,
        callback: callback
      });
      return this;
    },
    listenToOnce: function(obj, ev, callback) {
      var handler, listeningToOnce;
      listeningToOnce = this.listeningToOnce || (this.listeningToOnce = []);
      obj.bind(ev, handler = function() {
        var i, idx, j, len, lt;
        idx = -1;
        for (i = j = 0, len = listeningToOnce.length; j < len; i = ++j) {
          lt = listeningToOnce[i];
          if (lt.obj === obj) {
            if (lt.ev === ev && lt.callback === handler) {
              idx = i;
            }
          }
        }
        obj.unbind(ev, handler);
        if (idx !== -1) {
          listeningToOnce.splice(idx, 1);
        }
        return callback.apply(this, arguments);
      });
      listeningToOnce.push({
        obj: obj,
        ev: ev,
        callback: handler
      });
      return this;
    },
    stopListening: function(obj, events, callback) {
      var e, ev, evts, idx, j, k, l, len, len1, len2, len3, listeningTo, lt, m, n, ref, ref1, ref2;
      if (arguments.length === 0) {
        ref = [this.listeningTo, this.listeningToOnce];
        for (j = 0, len = ref.length; j < len; j++) {
          listeningTo = ref[j];
          if (!(listeningTo != null ? listeningTo.length : void 0)) {
            continue;
          }
          for (k = 0, len1 = listeningTo.length; k < len1; k++) {
            lt = listeningTo[k];
            lt.obj.unbind(lt.ev, lt.callback);
          }
        }
        this.listeningTo = void 0;
        this.listeningToOnce = void 0;
      } else if (obj) {
        events = events ? events.split(' ') : [void 0];
        ref1 = [this.listeningTo, this.listeningToOnce];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          listeningTo = ref1[l];
          if (!listeningTo) {
            continue;
          }
          for (m = 0, len3 = events.length; m < len3; m++) {
            ev = events[m];
            for (idx = n = ref2 = listeningTo.length - 1; ref2 <= 0 ? n <= 0 : n >= 0; idx = ref2 <= 0 ? ++n : --n) {
              lt = listeningTo[idx];
              if (lt.obj !== obj) {
                continue;
              }
              if (callback && lt.callback !== callback) {
                continue;
              }
              if ((!ev) || (ev === lt.ev)) {
                lt.obj.unbind(lt.ev, lt.callback);
                if (idx !== -1) {
                  listeningTo.splice(idx, 1);
                }
              } else if (ev) {
                evts = lt.ev.split(' ');
                if (indexOf.call(evts, ev) >= 0) {
                  evts = (function() {
                    var len4, p, results;
                    results = [];
                    for (p = 0, len4 = evts.length; p < len4; p++) {
                      e = evts[p];
                      if (e !== ev) {
                        results.push(e);
                      }
                    }
                    return results;
                  })();
                  lt.ev = $.trim(evts.join(' '));
                  lt.obj.unbind(ev, lt.callback);
                }
              }
            }
          }
        }
      }
      return this;
    },
    unbind: function(ev, callback) {
      var cb, evs, i, j, k, len, len1, list, name, ref;
      if (arguments.length === 0) {
        this._callbacks = {};
        return this;
      }
      if (!ev) {
        return this;
      }
      evs = ev.split(' ');
      for (j = 0, len = evs.length; j < len; j++) {
        name = evs[j];
        list = (ref = this._callbacks) != null ? ref[name] : void 0;
        if (!list) {
          continue;
        }
        if (!callback) {
          delete this._callbacks[name];
          continue;
        }
        for (i = k = 0, len1 = list.length; k < len1; i = ++k) {
          cb = list[i];
          if (!(cb === callback)) {
            continue;
          }
          list = list.slice();
          list.splice(i, 1);
          this._callbacks[name] = list;
          break;
        }
      }
      return this;
    }
  };

  Events.on = Events.bind;

  Events.off = Events.unbind;

  Log = {
    trace: true,
    logPrefix: '(App)',
    log: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!this.trace) {
        return;
      }
      if (this.logPrefix) {
        args.unshift(this.logPrefix);
      }
      if (typeof console !== "undefined" && console !== null) {
        if (typeof console.log === "function") {
          console.log.apply(console, args);
        }
      }
      return this;
    }
  };

  moduleKeywords = ['included', 'extended'];

  Module = (function() {
    Module.include = function(obj) {
      var key, ref, value;
      if (!obj) {
        throw new Error('include(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((ref = obj.included) != null) {
        ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, ref, value;
      if (!obj) {
        throw new Error('extend(obj) requires obj');
      }
      for (key in obj) {
        value = obj[key];
        if (indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((ref = obj.extended) != null) {
        ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      return (function(_this) {
        return function() {
          return func.apply(_this, arguments);
        };
      })(this);
    };

    Module.prototype.proxy = function(func) {
      return (function(_this) {
        return function() {
          return func.apply(_this, arguments);
        };
      })(this);
    };

    function Module() {
      if (typeof this.init === "function") {
        this.init.apply(this, arguments);
      }
    }

    return Module;

  })();

  Model = (function(superClass) {
    extend(Model, superClass);

    Model.extend(Events);

    Model.include(Events);

    Model.records = [];

    Model.irecords = {};

    Model.attributes = [];

    Model.configure = function() {
      var attributes, name;
      name = arguments[0], attributes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.className = name;
      this.deleteAll();
      if (attributes.length) {
        this.attributes = attributes;
      }
      this.attributes && (this.attributes = makeArray(this.attributes));
      this.attributes || (this.attributes = []);
      this.unbind();
      return this;
    };

    Model.toString = function() {
      return this.className + "(" + (this.attributes.join(", ")) + ")";
    };

    Model.find = function(id, notFound) {
      var ref;
      if (notFound == null) {
        notFound = this.notFound;
      }
      return ((ref = this.irecords[id]) != null ? ref.clone() : void 0) || (typeof notFound === "function" ? notFound(id) : void 0);
    };

    Model.findAll = function(ids, notFound) {
      var id, j, len, results;
      results = [];
      for (j = 0, len = ids.length; j < len; j++) {
        id = ids[j];
        if (this.find(id, notFound)) {
          results.push(this.find(id));
        }
      }
      return results;
    };

    Model.notFound = function(id) {
      return null;
    };

    Model.exists = function(id) {
      return Boolean(this.irecords[id]);
    };

    Model.addRecord = function(record, idx) {
      var root;
      if (root = this.irecords[record.id || record.cid]) {
        root.refresh(record);
      } else {
        record.id || (record.id = record.cid);
        this.irecords[record.id] = this.irecords[record.cid] = record;
        if (idx !== void 0) {
          this.records.splice(idx, 0, record);
        } else {
          this.records.push(record);
        }
      }
      return record;
    };

    Model.refresh = function(values, options) {
      var j, len, record, records, result;
      if (options == null) {
        options = {};
      }
      if (options.clear) {
        this.deleteAll();
      }
      records = this.fromJSON(values);
      if (!Array.isArray(records)) {
        records = [records];
      }
      for (j = 0, len = records.length; j < len; j++) {
        record = records[j];
        this.addRecord(record);
      }
      this.sort();
      result = this.cloneArray(records);
      this.trigger('refresh', result, options);
      return result;
    };

    Model.select = function(callback) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        if (callback(record)) {
          results.push(record.clone());
        }
      }
      return results;
    };

    Model.findByAttribute = function(name, value) {
      var j, len, record, ref;
      ref = this.records;
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        if (record[name] === value) {
          return record.clone();
        }
      }
      return null;
    };

    Model.findAllByAttribute = function(name, value) {
      return this.select(function(item) {
        return item[name] === value;
      });
    };

    Model.each = function(callback) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        results.push(callback(record.clone()));
      }
      return results;
    };

    Model.all = function() {
      return this.cloneArray(this.records);
    };

    Model.slice = function(begin, end) {
      if (begin == null) {
        begin = 0;
      }
      return this.cloneArray(this.records.slice(begin, end));
    };

    Model.first = function(end) {
      var ref;
      if (end == null) {
        end = 1;
      }
      if (end > 1) {
        return this.cloneArray(this.records.slice(0, end));
      } else {
        return (ref = this.records[0]) != null ? ref.clone() : void 0;
      }
    };

    Model.last = function(begin) {
      var ref;
      if (typeof begin === 'number') {
        return this.cloneArray(this.records.slice(-begin));
      } else {
        return (ref = this.records[this.records.length - 1]) != null ? ref.clone() : void 0;
      }
    };

    Model.count = function() {
      return this.records.length;
    };

    Model.deleteAll = function() {
      this.records = [];
      return this.irecords = {};
    };

    Model.destroyAll = function(options) {
      var j, len, record, ref, results;
      ref = this.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        results.push(record.destroy(options));
      }
      return results;
    };

    Model.update = function(id, atts, options) {
      return this.find(id).updateAttributes(atts, options);
    };

    Model.create = function(atts, options) {
      var record;
      record = new this(atts);
      return record.save(options);
    };

    Model.destroy = function(id, options) {
      var ref;
      return (ref = this.find(id)) != null ? ref.destroy(options) : void 0;
    };

    Model.change = function(callbackOrParams) {
      if (typeof callbackOrParams === 'function') {
        return this.bind('change', callbackOrParams);
      } else {
        return this.trigger.apply(this, ['change'].concat(slice.call(arguments)));
      }
    };

    Model.fetch = function(callbackOrParams) {
      if (typeof callbackOrParams === 'function') {
        return this.bind('fetch', callbackOrParams);
      } else {
        return this.trigger.apply(this, ['fetch'].concat(slice.call(arguments)));
      }
    };

    Model.toJSON = function() {
      return this.records;
    };

    Model.beforeFromJSON = function(objects) {
      return objects;
    };

    Model.fromJSON = function(objects) {
      var j, len, results, value;
      if (!objects) {
        return;
      }
      if (typeof objects === 'string') {
        objects = JSON.parse(objects);
      }
      objects = this.beforeFromJSON(objects);
      if (Array.isArray(objects)) {
        results = [];
        for (j = 0, len = objects.length; j < len; j++) {
          value = objects[j];
          if (value instanceof this) {
            results.push(value);
          } else {
            results.push(new this(value));
          }
        }
        return results;
      } else {
        if (objects instanceof this) {
          return objects;
        }
        return new this(objects);
      }
    };

    Model.fromForm = function() {
      var ref;
      return (ref = new this).fromForm.apply(ref, arguments);
    };

    Model.sort = function() {
      if (this.comparator) {
        this.records.sort(this.comparator);
      }
      return this;
    };

    Model.cloneArray = function(array) {
      var j, len, results, value;
      results = [];
      for (j = 0, len = array.length; j < len; j++) {
        value = array[j];
        results.push(value.clone());
      }
      return results;
    };

    Model.idCounter = 0;

    Model.uid = function(prefix) {
      var uid;
      if (prefix == null) {
        prefix = '';
      }
      uid = prefix + this.idCounter++;
      if (this.exists(uid)) {
        uid = this.uid(prefix);
      }
      return uid;
    };

    function Model(atts) {
      Model.__super__.constructor.apply(this, arguments);
      if ((this.constructor.uuid != null) && typeof this.constructor.uuid === 'function') {
        this.cid = this.constructor.uuid();
        if (!this.id) {
          this.id = this.cid;
        }
      } else {
        this.cid = (atts != null ? atts.cid : void 0) || this.constructor.uid('c-');
      }
      if (atts) {
        this.load(atts);
      }
    }

    Model.prototype.isNew = function() {
      return !this.exists();
    };

    Model.prototype.isValid = function() {
      return !this.validate();
    };

    Model.prototype.validate = function() {};

    Model.prototype.load = function(atts) {
      var key, value;
      if (atts.id) {
        this.id = atts.id;
      }
      for (key in atts) {
        value = atts[key];
        if (key === '_callbacks') {
          continue;
        }
        if (typeof this[key] === 'function') {
          if (typeof value === 'function') {
            continue;
          }
          this[key](value);
        } else {
          this[key] = value;
        }
      }
      return this;
    };

    Model.prototype.attributes = function() {
      var j, key, len, ref, result;
      result = {};
      ref = this.constructor.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        if (key in this) {
          if (typeof this[key] === 'function') {
            result[key] = this[key]();
          } else {
            result[key] = this[key];
          }
        }
      }
      if (this.id) {
        result.id = this.id;
      }
      return result;
    };

    Model.prototype.eql = function(rec) {
      return rec && rec.constructor === this.constructor && ((rec.cid === this.cid) || (rec.id && rec.id === this.id));
    };

    Model.prototype.save = function(options) {
      var error, record;
      if (options == null) {
        options = {};
      }
      if (options.validate !== false) {
        error = this.validate();
        if (error) {
          this.trigger('error', this, error);
          return false;
        }
      }
      this.trigger('beforeSave', this, options);
      record = this.isNew() ? this.create(options) : this.update(options);
      this.stripCloneAttrs();
      this.trigger('save', record, options);
      return record;
    };

    Model.prototype.stripCloneAttrs = function() {
      var key, value;
      if (this.hasOwnProperty('cid')) {
        return;
      }
      for (key in this) {
        if (!hasProp.call(this, key)) continue;
        value = this[key];
        if (indexOf.call(this.constructor.attributes, key) >= 0) {
          delete this[key];
        }
      }
      return this;
    };

    Model.prototype.updateAttribute = function(name, value, options) {
      var atts;
      atts = {};
      atts[name] = value;
      return this.updateAttributes(atts, options);
    };

    Model.prototype.updateAttributes = function(atts, options) {
      this.load(atts);
      return this.save(options);
    };

    Model.prototype.changeID = function(id) {
      var records;
      if (id === this.id) {
        return;
      }
      records = this.constructor.irecords;
      records[id] = records[this.id];
      if (this.cid !== this.id) {
        delete records[this.id];
      }
      return this.id = id;
    };

    Model.prototype.remove = function(options) {
      var i, j, len, record, records;
      if (options == null) {
        options = {};
      }
      records = this.constructor.records.slice(0);
      for (i = j = 0, len = records.length; j < len; i = ++j) {
        record = records[i];
        if (!(this.eql(record))) {
          continue;
        }
        records.splice(i, 1);
        break;
      }
      this.constructor.records = records;
      if (options.clear) {
        delete this.constructor.irecords[this.id];
        return delete this.constructor.irecords[this.cid];
      }
    };

    Model.prototype.destroy = function(options) {
      if (options == null) {
        options = {};
      }
      if (options.clear == null) {
        options.clear = true;
      }
      this.trigger('beforeDestroy', this, options);
      this.remove(options);
      this.destroyed = true;
      this.trigger('destroy', this, options);
      this.trigger('change', this, 'destroy', options);
      if (this.listeningTo) {
        this.stopListening();
      }
      this.unbind();
      return this;
    };

    Model.prototype.dup = function(newRecord) {
      var atts, record;
      if (newRecord == null) {
        newRecord = true;
      }
      atts = this.attributes();
      if (newRecord) {
        delete atts.id;
      } else {
        atts.cid = this.cid;
      }
      record = new this.constructor(atts);
      if (!newRecord) {
        this._callbacks && (record._callbacks = this._callbacks);
      }
      return record;
    };

    Model.prototype.clone = function() {
      return createObject(this);
    };

    Model.prototype.reload = function() {
      var original;
      if (this.isNew()) {
        return this;
      }
      original = this.constructor.find(this.id);
      this.load(original.attributes());
      return original;
    };

    Model.prototype.refresh = function(atts) {
      atts = this.constructor.fromJSON(atts);
      if (atts.id && this.id !== atts.id) {
        this.changeID(atts.id);
      }
      this.constructor.irecords[this.id].load(atts);
      this.trigger('refresh', this);
      this.trigger('change', this, 'refresh');
      return this;
    };

    Model.prototype.toJSON = function() {
      return this.attributes();
    };

    Model.prototype.toString = function() {
      return "<" + this.constructor.className + " (" + (JSON.stringify(this)) + ")>";
    };

    Model.prototype.fromForm = function(form) {
      var checkbox, j, k, key, l, len, len1, len2, name, name1, ref, ref1, ref2, result;
      result = {};
      ref = $(form).find('[type=checkbox]:not([value])');
      for (j = 0, len = ref.length; j < len; j++) {
        checkbox = ref[j];
        result[checkbox.name] = $(checkbox).prop('checked');
      }
      ref1 = $(form).find('[type=checkbox][name$="[]"]');
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        checkbox = ref1[k];
        name = checkbox.name.replace(/\[\]$/, '');
        result[name] || (result[name] = []);
        if ($(checkbox).prop('checked')) {
          result[name].push(checkbox.value);
        }
      }
      ref2 = $(form).serializeArray();
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        key = ref2[l];
        result[name1 = key.name] || (result[name1] = key.value);
      }
      return this.load(result);
    };

    Model.prototype.exists = function() {
      return this.constructor.exists(this.id);
    };

    Model.prototype.update = function(options) {
      var clone, records;
      this.trigger('beforeUpdate', this, options);
      records = this.constructor.irecords;
      records[this.id].load(this.attributes());
      this.constructor.sort();
      clone = records[this.id].clone();
      clone.trigger('update', clone, options);
      clone.trigger('change', clone, 'update', options);
      return clone;
    };

    Model.prototype.create = function(options) {
      var clone, record;
      this.trigger('beforeCreate', this, options);
      this.id || (this.id = this.cid);
      record = this.dup(false);
      this.constructor.addRecord(record, options.idx);
      this.constructor.sort();
      clone = record.clone();
      clone.trigger('create', clone, options);
      clone.trigger('change', clone, 'create', options);
      return clone;
    };

    Model.prototype.bind = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.bind.apply(record, arguments);
    };

    Model.prototype.one = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.one.apply(record, arguments);
    };

    Model.prototype.unbind = function() {
      var record;
      record = this.constructor.irecords[this.id] || this;
      return Events.unbind.apply(record, arguments);
    };

    Model.prototype.trigger = function() {
      var ref;
      Events.trigger.apply(this, arguments);
      if (arguments[0] === 'refresh') {
        return true;
      }
      return (ref = this.constructor).trigger.apply(ref, arguments);
    };

    return Model;

  })(Module);

  Model.prototype.on = Model.prototype.bind;

  Model.prototype.off = Model.prototype.unbind;

  Controller = (function(superClass) {
    extend(Controller, superClass);

    Controller.include(Events);

    Controller.include(Log);

    Controller.prototype.eventSplitter = /^(\S+)\s*(.*)$/;

    Controller.prototype.tag = 'div';

    function Controller(options) {
      this.release = bind(this.release, this);
      var context, key, parent_prototype, ref, value;
      this.options = options;
      ref = this.options;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
      if (!this.el) {
        this.el = document.createElement(this.tag);
      }
      this.el = $(this.el);
      if (this.className) {
        this.el.addClass(this.className);
      }
      if (this.attributes) {
        this.el.attr(this.attributes);
      }
      if (!this.events) {
        this.events = this.constructor.events;
      }
      if (!this.elements) {
        this.elements = this.constructor.elements;
      }
      context = this;
      while (parent_prototype = context.constructor.__super__) {
        if (parent_prototype.events) {
          this.events = $.extend({}, parent_prototype.events, this.events);
        }
        if (parent_prototype.elements) {
          this.elements = $.extend({}, parent_prototype.elements, this.elements);
        }
        context = parent_prototype;
      }
      if (this.events) {
        this.delegateEvents(this.events);
      }
      if (this.elements) {
        this.refreshElements();
      }
      Controller.__super__.constructor.apply(this, arguments);
    }

    Controller.prototype.release = function() {
      this.trigger('release', this);
      this.el.remove();
      this.unbind();
      return this.stopListening();
    };

    Controller.prototype.$ = function(selector) {
      return this.el.find(selector);
    };

    Controller.prototype.delegateEvents = function(events) {
      var eventName, key, match, method, results, selector;
      results = [];
      for (key in events) {
        method = events[key];
        if (typeof method === 'function') {
          method = (function(_this) {
            return function(method) {
              return function() {
                method.apply(_this, arguments);
                return true;
              };
            };
          })(this)(method);
        } else {
          if (!this[method]) {
            throw new Error(method + " doesn't exist");
          }
          method = (function(_this) {
            return function(method) {
              return function() {
                _this[method].apply(_this, arguments);
                return true;
              };
            };
          })(this)(method);
        }
        match = key.match(this.eventSplitter);
        eventName = match[1];
        selector = match[2];
        if (selector === '') {
          results.push(this.el.bind(eventName, method));
        } else {
          results.push(this.el.on(eventName, selector, method));
        }
      }
      return results;
    };

    Controller.prototype.refreshElements = function() {
      var key, ref, results, value;
      ref = this.elements;
      results = [];
      for (key in ref) {
        value = ref[key];
        results.push(this[value] = this.$(key));
      }
      return results;
    };

    Controller.prototype.delay = function(func, timeout) {
      return setTimeout(this.proxy(func), timeout || 0);
    };

    Controller.prototype.html = function(element) {
      this.el.html(element.el || element);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.append = function() {
      var e, elements, ref;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      elements = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = elements.length; j < len; j++) {
          e = elements[j];
          results.push(e.el || e);
        }
        return results;
      })();
      (ref = this.el).append.apply(ref, elements);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.appendTo = function(element) {
      this.el.appendTo(element.el || element);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.prepend = function() {
      var e, elements, ref;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      elements = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = elements.length; j < len; j++) {
          e = elements[j];
          results.push(e.el || e);
        }
        return results;
      })();
      (ref = this.el).prepend.apply(ref, elements);
      this.refreshElements();
      return this.el;
    };

    Controller.prototype.replace = function(element) {
      var previous, ref, ref1;
      element = element.el || element;
      if (typeof element === "string") {
        element = $.trim(element);
      }
      ref1 = [this.el, $(((ref = $.parseHTML(element)) != null ? ref[0] : void 0) || element)], previous = ref1[0], this.el = ref1[1];
      previous.replaceWith(this.el);
      this.delegateEvents(this.events);
      this.refreshElements();
      return this.el;
    };

    return Controller;

  })(Module);

  $ = (typeof window !== "undefined" && window !== null ? window.jQuery : void 0) || (typeof window !== "undefined" && window !== null ? window.Zepto : void 0) || function(element) {
    return element;
  };

  createObject = Object.create || function(o) {
    var Func;
    Func = function() {};
    Func.prototype = o;
    return new Func();
  };

  makeArray = function(args) {
    return Array.prototype.slice.call(args, 0);
  };

  Spine = this.Spine = {};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine;
  }

  Spine.version = '1.6.2';

  Spine.$ = $;

  Spine.Events = Events;

  Spine.Log = Log;

  Spine.Module = Module;

  Spine.Controller = Controller;

  Spine.Model = Model;

  Module.extend.call(Spine, Events);

  Module.create = Module.sub = Controller.create = Controller.sub = Model.sub = function(instances, statics) {
    var Result;
    Result = (function(superClass) {
      extend(Result, superClass);

      function Result() {
        return Result.__super__.constructor.apply(this, arguments);
      }

      return Result;

    })(this);
    if (instances) {
      Result.include(instances);
    }
    if (statics) {
      Result.extend(statics);
    }
    if (typeof Result.unbind === "function") {
      Result.unbind();
    }
    return Result;
  };

  Model.setup = function(name, attributes) {
    var Instance;
    if (attributes == null) {
      attributes = [];
    }
    Instance = (function(superClass) {
      extend(Instance, superClass);

      function Instance() {
        return Instance.__super__.constructor.apply(this, arguments);
      }

      return Instance;

    })(this);
    Instance.configure.apply(Instance, [name].concat(slice.call(attributes)));
    return Instance;
  };

  Spine.Class = Module;

}).call(this);

//# sourceMappingURL=spine.js.map
 },"spine/lib/ajax": function(exports, require, module) { // Generated by CoffeeScript 1.10.0
(function() {
  var $, Ajax, Base, Collection, Extend, GenerateURL, Include, Model, Queue, Singleton, Spine,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  Queue = $({});

  Ajax = {
    getURL: function(object) {
      if (object.className != null) {
        return this.generateURL(object);
      } else {
        return this.generateURL(object, encodeURIComponent(object.id));
      }
    },
    getCollectionURL: function(object) {
      return this.generateURL(object);
    },
    getScope: function(object) {
      return (typeof object.scope === "function" ? object.scope() : void 0) || object.scope;
    },
    getCollection: function(object) {
      if (object.url !== object.generateURL) {
        if (typeof object.url === 'function') {
          return object.url();
        } else {
          return object.url;
        }
      } else if (object.className != null) {
        return object.className.toLowerCase() + 's';
      }
    },
    generateURL: function() {
      var args, collection, object, path, scope;
      object = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      collection = Ajax.getCollection(object) || Ajax.getCollection(object.constructor);
      scope = Ajax.getScope(object) || Ajax.getScope(object.constructor);
      args.unshift(collection);
      args.unshift(scope);
      path = args.join('/');
      path = path.replace(/(\/\/)/g, "/");
      path = path.replace(/^\/|\/$/g, "");
      if (path.indexOf("../") !== 0) {
        return Model.host + "/" + path;
      } else {
        return path;
      }
    },
    enabled: true,
    disable: function(callback) {
      var e, error1;
      if (this.enabled) {
        this.enabled = false;
        try {
          return callback();
        } catch (error1) {
          e = error1;
          throw e;
        } finally {
          this.enabled = true;
        }
      } else {
        return callback();
      }
    },
    queue: function(request) {
      if (request) {
        return Queue.queue(request);
      } else {
        return Queue.queue();
      }
    },
    clearQueue: function() {
      return this.queue([]);
    },
    config: {
      loadMethod: 'GET',
      updateMethod: 'PUT',
      createMethod: 'POST',
      destroyMethod: 'DELETE'
    }
  };

  Base = (function() {
    function Base() {}

    Base.prototype.defaults = {
      dataType: 'json',
      processData: false,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      }
    };

    Base.prototype.queue = Ajax.queue;

    Base.prototype.ajax = function(params, defaults) {
      return $.ajax(this.ajaxSettings(params, defaults));
    };

    Base.prototype.ajaxQueue = function(params, defaults, record) {
      var deferred, jqXHR, parallel, promise, request, settings;
      jqXHR = null;
      deferred = $.Deferred();
      promise = deferred.promise();
      if (!Ajax.enabled) {
        return promise;
      }
      settings = this.ajaxSettings(params, defaults);
      parallel = settings.parallel !== void 0 ? settings.parallel : settings.type === 'GET';
      request = function(next) {
        var ref, reject, resolve;
        if ((record != null ? record.id : void 0) != null) {
          if (settings.url == null) {
            settings.url = Ajax.getURL(record);
          }
          if ((ref = settings.data) != null) {
            ref.id = record.id;
          }
        }
        if (typeof settings.data !== 'string' && settings.processData !== true) {
          settings.data = JSON.stringify(settings.data);
        }
        resolve = function() {
          return deferred.resolve.apply(this, slice.call(arguments).concat([settings]));
        };
        reject = function() {
          return deferred.reject.apply(this, slice.call(arguments).concat([settings]));
        };
        jqXHR = $.ajax(settings);
        jqXHR.done(resolve);
        jqXHR.fail(reject);
        jqXHR.then(next, next);
        if (parallel) {
          return Queue.dequeue();
        }
      };
      promise.abort = function(statusText) {
        var index;
        if (jqXHR) {
          return jqXHR.abort(statusText);
        }
        index = $.inArray(request, this.queue());
        if (index > -1) {
          this.queue().splice(index, 1);
        }
        deferred.rejectWith(settings.context || settings, [promise, statusText, '']);
        return promise;
      };
      this.queue(request);
      return promise;
    };

    Base.prototype.ajaxSettings = function(params, defaults) {
      return $.extend({}, this.defaults, defaults, params);
    };

    return Base;

  })();

  Collection = (function(superClass) {
    extend(Collection, superClass);

    function Collection(model) {
      this.model = model;
      this.failResponse = bind(this.failResponse, this);
      this.recordsResponse = bind(this.recordsResponse, this);
    }

    Collection.prototype.find = function(id, params, options) {
      var record;
      if (options == null) {
        options = {};
      }
      record = new this.model({
        id: id
      });
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url || Ajax.getURL(record),
        parallel: options.parallel
      }).done(this.recordsResponse(options)).fail(this.failResponse(options));
    };

    Collection.prototype.all = function(params, options) {
      if (options == null) {
        options = {};
      }
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url || Ajax.getURL(this.model),
        parallel: options.parallel
      }).done(this.recordsResponse(options)).fail(this.failResponse(options));
    };

    Collection.prototype.fetch = function(params, options) {
      var id;
      if (params == null) {
        params = {};
      }
      if (options == null) {
        options = {};
      }
      if (id = params.id) {
        delete params.id;
        return this.find(id, params, options).done((function(_this) {
          return function(record) {
            return _this.model.refresh(record, options);
          };
        })(this));
      } else {
        return this.all(params, options).done((function(_this) {
          return function(records) {
            return _this.model.refresh(records, options);
          };
        })(this));
      }
    };

    Collection.prototype.recordsResponse = function(options) {
      return (function(_this) {
        return function(data, status, xhr, settings) {
          var ref;
          _this.model.trigger('ajaxSuccess', null, status, xhr, settings);
          return (ref = options.done) != null ? ref.call(_this.model, settings) : void 0;
        };
      })(this);
    };

    Collection.prototype.failResponse = function(options) {
      return (function(_this) {
        return function(xhr, statusText, error, settings) {
          var ref;
          _this.model.trigger('ajaxError', null, xhr, statusText, error, settings);
          return (ref = options.fail) != null ? ref.call(_this.model, settings) : void 0;
        };
      })(this);
    };

    return Collection;

  })(Base);

  Singleton = (function(superClass) {
    extend(Singleton, superClass);

    function Singleton(record1) {
      this.record = record1;
      this.failResponse = bind(this.failResponse, this);
      this.recordResponse = bind(this.recordResponse, this);
      this.model = this.record.constructor;
    }

    Singleton.prototype.reload = function(params, options) {
      if (options == null) {
        options = {};
      }
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    Singleton.prototype.create = function(params, options) {
      if (options == null) {
        options = {};
      }
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.createMethod,
        contentType: 'application/json',
        data: this.record.toJSON(),
        url: options.url || Ajax.getCollectionURL(this.record),
        parallel: options.parallel
      }).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    Singleton.prototype.update = function(params, options) {
      if (options == null) {
        options = {};
      }
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.updateMethod,
        contentType: 'application/json',
        data: this.record.toJSON(),
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    Singleton.prototype.destroy = function(params, options) {
      if (options == null) {
        options = {};
      }
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.destroyMethod,
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    Singleton.prototype.recordResponse = function(options) {
      return (function(_this) {
        return function(data, status, xhr, settings) {
          var ref;
          if ((data != null) && Object.getOwnPropertyNames(data).length && !_this.record.destroyed) {
            _this.record.refresh(data, {
              ajax: false
            });
          }
          _this.record.trigger('ajaxSuccess', _this.record, _this.model.fromJSON(data), status, xhr, settings);
          return (ref = options.done) != null ? ref.call(_this.record, settings) : void 0;
        };
      })(this);
    };

    Singleton.prototype.failResponse = function(options) {
      return (function(_this) {
        return function(xhr, statusText, error, settings) {
          var ref;
          switch (settings.type) {
            case 'POST':
              _this.createFailed();
              break;
            case 'DELETE':
              _this.destroyFailed();
          }
          _this.record.trigger('ajaxError', _this.record, xhr, statusText, error, settings);
          return (ref = options.fail) != null ? ref.call(_this.record, settings) : void 0;
        };
      })(this);
    };

    Singleton.prototype.createFailed = function() {
      return this.record.remove({
        clear: true
      });
    };

    Singleton.prototype.destroyFailed = function() {
      this.record.destroyed = false;
      return this.record.constructor.refresh(this.record);
    };

    return Singleton;

  })(Base);

  Model.host = '';

  GenerateURL = {
    include: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      args.unshift(encodeURIComponent(this.id));
      return Ajax.generateURL.apply(Ajax, [this].concat(slice.call(args)));
    },
    extend: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return Ajax.generateURL.apply(Ajax, [this].concat(slice.call(args)));
    }
  };

  Include = {
    ajax: function() {
      return new Singleton(this);
    },
    generateURL: GenerateURL.include,
    url: GenerateURL.include
  };

  Extend = {
    ajax: function() {
      return new Collection(this);
    },
    generateURL: GenerateURL.extend,
    url: GenerateURL.extend
  };

  Model.Ajax = {
    extended: function() {
      this.fetch(this.ajaxFetch);
      this.change(this.ajaxChange);
      this.extend(Extend);
      return this.include(Include);
    },
    ajaxFetch: function() {
      var ref;
      return (ref = this.ajax()).fetch.apply(ref, arguments);
    },
    ajaxChange: function(record, type, options) {
      var base;
      if (options == null) {
        options = {};
      }
      if (options.ajax === false) {
        return;
      }
      return typeof (base = record.ajax())[type] === "function" ? base[type](options.ajax, options) : void 0;
    }
  };

  Model.Ajax.Methods = {
    extended: function() {
      this.extend(Extend);
      return this.include(Include);
    }
  };

  Ajax.defaults = Base.prototype.defaults;

  Ajax.Base = Base;

  Ajax.Singleton = Singleton;

  Ajax.Collection = Collection;

  Spine.Ajax = Ajax;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Ajax;
  }

}).call(this);

//# sourceMappingURL=ajax.js.map
 },"spine/lib/route": function(exports, require, module) { // Generated by CoffeeScript 1.10.0
(function() {
  var $, Path, Route, Spine, escapeRegExp, hashStrip, namedParam, splatParam,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  hashStrip = /^#*/;

  namedParam = /:([\w\d]+)/g;

  splatParam = /\*([\w\d]+)/g;

  escapeRegExp = /[-[\]{}()+?.,\\^$|#\s]/g;

  Path = (function(superClass) {
    extend(Path, superClass);

    function Path(path, callback) {
      var match;
      this.names = [];
      this.path = path;
      this.callback = callback;
      if (typeof path === 'string') {
        namedParam.lastIndex = 0;
        while ((match = namedParam.exec(path)) !== null) {
          this.names.push(match[1]);
        }
        splatParam.lastIndex = 0;
        while ((match = splatParam.exec(path)) !== null) {
          this.names.push(match[1]);
        }
        path = path.replace(escapeRegExp, '\\$&').replace(namedParam, '([^\/]*)').replace(splatParam, '(.*?)');
        this.route = new RegExp("^" + path + "$");
      } else {
        this.route = path;
      }
    }

    Path.prototype.match = function(path, options) {
      var i, j, len, match, param, params;
      if (options == null) {
        options = {};
      }
      if (!(match = this.route.exec(path))) {
        return false;
      }
      options.match = match;
      params = match.slice(1);
      if (this.names.length) {
        for (i = j = 0, len = params.length; j < len; i = ++j) {
          param = params[i];
          options[this.names[i]] = param;
        }
      }
      Route.trigger('before', this);
      return this.callback.call(null, options) !== false;
    };

    return Path;

  })(Spine.Module);

  Route = (function(superClass) {
    var ref;

    extend(Route, superClass);

    Route.extend(Spine.Events);

    Route.historySupport = ((ref = window.history) != null ? ref.pushState : void 0) != null;

    Route.options = {
      trigger: true,
      history: false,
      shim: false,
      replace: false,
      redirect: false
    };

    Route.routers = [];

    Route.setup = function(options) {
      if (options == null) {
        options = {};
      }
      this.options = $.extend({}, this.options, options);
      if (this.options.history) {
        this.history = this.historySupport && this.options.history;
      }
      if (this.options.shim) {
        return;
      }
      if (this.history) {
        $(window).bind('popstate', this.change);
      } else {
        $(window).bind('hashchange', this.change);
      }
      return this.change();
    };

    Route.unbind = function() {
      var unbindResult;
      unbindResult = Spine.Events.unbind.apply(this, arguments);
      if (arguments.length > 0) {
        return unbindResult;
      }
      if (this.options.shim) {
        return;
      }
      if (this.history) {
        return $(window).unbind('popstate', this.change);
      } else {
        return $(window).unbind('hashchange', this.change);
      }
    };

    Route.navigate = function() {
      var args, lastArg, options, path, routes;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      options = {};
      lastArg = args[args.length - 1];
      if (typeof lastArg === 'object') {
        options = args.pop();
      } else if (typeof lastArg === 'boolean') {
        options.trigger = args.pop();
      }
      options = $.extend({}, this.options, options);
      path = args.join('/');
      if (this.path === path) {
        return;
      }
      this.path = path;
      if (options.trigger) {
        this.trigger('navigate', this.path);
        routes = this.matchRoutes(this.path, options);
        if (!routes.length) {
          if (typeof options.redirect === 'function') {
            return options.redirect.apply(this, [this.path, options]);
          } else {
            if (options.redirect === true) {
              this.redirect(this.path);
            }
          }
        }
      }
      if (options.shim) {
        return true;
      } else if (this.history && options.replace) {
        return history.replaceState({}, document.title, this.path);
      } else if (this.history) {
        return history.pushState({}, document.title, this.path);
      } else {
        return window.location.hash = this.path;
      }
    };

    Route.create = function() {
      var router;
      router = new this;
      this.routers.push(router);
      return router;
    };

    Route.add = function(path, callback) {
      return this.router.add(path, callback);
    };

    Route.prototype.add = function(path, callback) {
      var key, results, value;
      if (typeof path === 'object' && !(path instanceof RegExp)) {
        results = [];
        for (key in path) {
          value = path[key];
          results.push(this.add(key, value));
        }
        return results;
      } else {
        return this.routes.push(new Path(path, callback));
      }
    };

    Route.prototype.destroy = function() {
      var r;
      this.routes.length = 0;
      return this.constructor.routers = (function() {
        var j, len, ref1, results;
        ref1 = this.constructor.routers;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          r = ref1[j];
          if (r !== this) {
            results.push(r);
          }
        }
        return results;
      }).call(this);
    };

    Route.getPath = function() {
      var path;
      if (this.history) {
        path = window.location.pathname;
        if (path.substr(0, 1) !== '/') {
          path = '/' + path;
        }
      } else {
        path = window.location.hash;
        path = path.replace(hashStrip, '');
      }
      return path;
    };

    Route.getHost = function() {
      return window.location.protocol + "//" + window.location.host;
    };

    Route.change = function() {
      var path;
      path = Route.getPath();
      if (path === Route.path) {
        return;
      }
      Route.path = path;
      return Route.matchRoutes(Route.path);
    };

    Route.matchRoutes = function(path, options) {
      var j, len, match, matches, ref1, router;
      matches = [];
      ref1 = this.routers.concat([this.router]);
      for (j = 0, len = ref1.length; j < len; j++) {
        router = ref1[j];
        match = router.matchRoute(path, options);
        if (match) {
          matches.push(match);
        }
      }
      if (matches.length) {
        this.trigger('change', matches, path);
      }
      return matches;
    };

    Route.redirect = function(path) {
      return window.location = path;
    };

    function Route() {
      this.routes = [];
    }

    Route.prototype.matchRoute = function(path, options) {
      var j, len, ref1, route;
      ref1 = this.routes;
      for (j = 0, len = ref1.length; j < len; j++) {
        route = ref1[j];
        if (route.match(path, options)) {
          return route;
        }
      }
    };

    Route.prototype.trigger = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      args.splice(1, 0, this);
      return (ref1 = this.constructor).trigger.apply(ref1, args);
    };

    return Route;

  })(Spine.Module);

  Route.router = new Route;

  Spine.Controller.include({
    route: function(path, callback) {
      if (this.router instanceof Spine.Route) {
        return this.router.add(path, this.proxy(callback));
      } else {
        return Spine.Route.add(path, this.proxy(callback));
      }
    },
    routes: function(routes) {
      var key, results, value;
      results = [];
      for (key in routes) {
        value = routes[key];
        results.push(this.route(key, value));
      }
      return results;
    },
    navigate: function() {
      return Spine.Route.navigate.apply(Spine.Route, arguments);
    }
  });

  Route.Path = Path;

  Spine.Route = Route;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Route;
  }

}).call(this);

//# sourceMappingURL=route.js.map
 },"spine/lib/manager": function(exports, require, module) { // Generated by CoffeeScript 1.10.0
(function() {
  var $, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Spine.Manager = (function(superClass) {
    extend(Manager, superClass);

    Manager.include(Spine.Events);

    function Manager() {
      this.controllers = [];
      this.bind('change', this.change);
      this.add.apply(this, arguments);
    }

    Manager.prototype.add = function() {
      var cont, controllers, i, len, results;
      controllers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      results = [];
      for (i = 0, len = controllers.length; i < len; i++) {
        cont = controllers[i];
        results.push(this.addOne(cont));
      }
      return results;
    };

    Manager.prototype.addOne = function(controller) {
      controller.bind('active', (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this.trigger.apply(_this, ['change', controller].concat(slice.call(args)));
        };
      })(this));
      controller.bind('release', (function(_this) {
        return function() {
          var c;
          return _this.controllers = (function() {
            var i, len, ref, results;
            ref = this.controllers;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              c = ref[i];
              if (c !== controller) {
                results.push(c);
              }
            }
            return results;
          }).call(_this);
        };
      })(this));
      return this.controllers.push(controller);
    };

    Manager.prototype.deactivate = function() {
      return this.trigger.apply(this, ['change', false].concat(slice.call(arguments)));
    };

    Manager.prototype.change = function() {
      var args, cont, current, i, len, ref;
      current = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        cont = ref[i];
        if (cont !== current) {
          cont.deactivate.apply(cont, args);
        }
      }
      if (current) {
        return current.activate.apply(current, args);
      }
    };

    return Manager;

  })(Spine.Module);

  Spine.Controller.include({
    active: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (typeof args[0] === 'function') {
        this.bind('active', args[0]);
      } else {
        args.unshift('active');
        this.trigger.apply(this, args);
      }
      return this;
    },
    isActive: function() {
      return this.el.hasClass('active');
    },
    activate: function() {
      this.el.addClass('active');
      return this;
    },
    deactivate: function() {
      this.el.removeClass('active');
      return this;
    }
  });

  Spine.Stack = (function(superClass) {
    extend(Stack, superClass);

    Stack.prototype.controllers = {};

    Stack.prototype.routes = {};

    Stack.prototype.className = 'spine stack';

    function Stack() {
      this.release = bind(this.release, this);
      var fn, key, ref, ref1, ref2, value;
      Stack.__super__.constructor.apply(this, arguments);
      this.manager = new Spine.Manager;
      this.router = (ref = Spine.Route) != null ? ref.create() : void 0;
      ref1 = this.controllers;
      for (key in ref1) {
        value = ref1[key];
        if (this[key] != null) {
          throw Error("'@" + key + "' already assigned");
        }
        this[key] = new value({
          stack: this
        });
        this.add(this[key]);
      }
      ref2 = this.routes;
      fn = (function(_this) {
        return function(key, value) {
          var callback;
          if (typeof value === 'function') {
            callback = value;
          }
          callback || (callback = function() {
            var ref3;
            return (ref3 = _this[value]).active.apply(ref3, arguments);
          });
          return _this.route(key, callback);
        };
      })(this);
      for (key in ref2) {
        value = ref2[key];
        fn(key, value);
      }
      if (this["default"]) {
        this[this["default"]].active();
      }
    }

    Stack.prototype.add = function(controller) {
      this.manager.add(controller);
      return this.append(controller);
    };

    Stack.prototype.release = function() {
      var ref;
      if ((ref = this.router) != null) {
        ref.destroy();
      }
      return Stack.__super__.release.apply(this, arguments);
    };

    return Stack;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine.Manager;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports.Stack = Spine.Stack;
  }

}).call(this);

//# sourceMappingURL=manager.js.map
 },"spine/lib/local": function(exports, require, module) { // Generated by CoffeeScript 1.10.0
(function() {
  var Spine;

  Spine = this.Spine || require('spine');

  Spine.Model.Local = {
    extended: function() {
      var e, error, testLocalStorage;
      testLocalStorage = 'spine' + new Date().getTime();
      try {
        localStorage.setItem(testLocalStorage, testLocalStorage);
        localStorage.removeItem(testLocalStorage);
      } catch (error) {
        e = error;
        return;
      }
      this.change(this.saveLocal);
      return this.fetch(this.loadLocal);
    },
    saveLocal: function() {
      var result;
      result = JSON.stringify(this);
      return localStorage[this.className] = result;
    },
    loadLocal: function(options) {
      var result;
      if (options == null) {
        options = {};
      }
      if (!options.hasOwnProperty('clear')) {
        options.clear = true;
      }
      result = localStorage[this.className];
      return this.refresh(result || [], options);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine.Model.Local;
  }

}).call(this);

//# sourceMappingURL=local.js.map
 },"spine/lib/list": function(exports, require, module) { // Generated by CoffeeScript 1.10.0
(function() {
  var $, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Spine.List = (function(superClass) {
    extend(List, superClass);

    List.prototype.events = {
      'click .item': 'click'
    };

    List.prototype.selectFirst = false;

    function List() {
      this.change = bind(this.change, this);
      List.__super__.constructor.apply(this, arguments);
      this.bind('change', this.change);
    }

    List.prototype.template = function() {
      throw Error('Override template');
    };

    List.prototype.change = function(item) {
      var i, idx, index, len, ref;
      this.current = item;
      if (!this.current) {
        this.children().removeClass('active');
        return;
      }
      this.children().removeClass('active');
      ref = this.items;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        item = ref[idx];
        if (!(item === this.current)) {
          continue;
        }
        index = idx;
        break;
      }
      return $(this.children().get(index)).addClass('active');
    };

    List.prototype.render = function(items) {
      if (items) {
        this.items = items;
      }
      this.html(this.template(this.items));
      this.change(this.current);
      if (this.selectFirst) {
        if (!this.children('.active').length) {
          return this.children(':first').click();
        }
      }
    };

    List.prototype.children = function(sel) {
      return this.el.children(sel);
    };

    List.prototype.click = function(e) {
      var item;
      item = this.items[$(e.currentTarget).index()];
      this.trigger('change', item);
      return true;
    };

    return List;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Spine.List;
  }

}).call(this);

//# sourceMappingURL=list.js.map
 },"admin": function(exports, require, module) { (function() {
  var $, Category, CategoryEditView, Clipboard, Config, Drag, Extender, Flash, LoaderView, LoginView, Main, MainView, MissingView, ModalActionView, ModalSimpleView, Model, OverviewView, PhotosTrash, PreviewView, Product, ProductEditView, ProductsTrash, Root, Settings, ShowView, Sidebar, Spine, SpineDragItem, Toolbar, ToolbarView, TrustamiView, UploadEditView, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  User = require('models/user');

  Config = require('models/config');

  Drag = require('extensions/drag');

  Product = require('models/product');

  Root = require('models/root');

  PhotosTrash = require('models/photos_trash');

  ProductsTrash = require('models/products_trash');

  Category = require('models/category');

  Toolbar = require("models/toolbar");

  Settings = require('models/settings');

  Flash = require("models/flash");

  Clipboard = require("models/clipboard");

  ProductsTrash = require("models/products_trash");

  MainView = require("controllers/main_view");

  TrustamiView = require("controllers/trustami_view");

  LoginView = require("controllers/login_view");

  LoaderView = require("controllers/loader_view");

  Sidebar = require("controllers/sidebar");

  ShowView = require("controllers/show_view");

  ModalSimpleView = require("controllers/modal_simple_view");

  ModalActionView = require("controllers/modal_action_view");

  ToolbarView = require("controllers/toolbar_view");

  LoginView = require("controllers/login_view");

  ProductEditView = require("controllers/product_edit_view");

  UploadEditView = require("controllers/upload_edit_view");

  CategoryEditView = require("controllers/category_edit_view");

  OverviewView = require('controllers/overview_view');

  PreviewView = require('controllers/preview_view');

  MissingView = require("controllers/missing_view");

  Extender = require('extensions/controller_extender');

  SpineDragItem = require('models/drag_item');

  require('spine/lib/route');

  require('spine/lib/manager');

  require("extensions/manager");

  Main = (function(superClass) {
    extend(Main, superClass);

    Main.extend(Drag);

    Main.extend(Extender);

    Main.prototype.elements = {
      '#fileupload': 'uploader',
      '#preview': 'previewEl',
      '#main': 'mainEl',
      '#sidebar': 'sidebarEl',
      '#show': 'showEl',
      '#overview': 'overviewEl',
      '#sidebar .flickr': 'sidebarFlickrEl',
      '#missing': 'missingEl',
      '#ga': 'categoryEl',
      '#al': 'productEl',
      '#fu': 'uploadEl',
      '#loader': 'loaderEl',
      '#login': 'loginEl',
      '#modal-category': 'slideshowEl',
      '#modal-simple': 'modalSimpleEl',
      '#show .content': 'content',
      '.vdraggable': 'vDrag',
      '.hdraggable': 'hDrag',
      '.vdivide': 'vDragHandle',
      '.hdivide': 'hDragHandle',
      '.status-symbol img': 'statusIcon',
      '.status-text': 'statusText',
      '.status-symbol': 'statusSymbol',
      '.toolbar-three': 'trustamiEl'
    };

    Main.prototype.events = {
      'click [class*="-trigger-edit"]': 'activateEditor',
      'click': 'delegateFocus',
      'keyup': 'key',
      'keydown': 'key'
    };

    function Main() {
      Main.__super__.constructor.apply(this, arguments);
      this.version = "2.0.0";
      this.autoupload = true;
      this.useDragImage = false;
      this.intro = true;
      this.sidebarInitWidth = 430;
      Spine.dragItem = SpineDragItem.create();
      this.CONFIRM = {
        'REMOVE': function(options) {
          if (options.plural) {
            return '\nSollen ' + options.type + ' ' + $().brace(options.length) + ' wirklich entfernt werden?\n\n';
          } else {
            return '\nSoll ' + options.type + ' "' + options.name + '" wirklich entfernt werden?\n\n';
          }
        },
        'DELETE': function(options) {
          if (options.plural) {
            return '\nSollen ' + options.type + ' ' + $().brace(options.length) + ' in den Papierkorb verschoben werden?\n\n';
          } else {
            return '\nSoll ' + options.type + ' "' + options.name + '" in den Papierkorb verschoben werden?\n\n';
          }
        },
        'DESTROY': function(options) {
          if (options.plural) {
            return '\nSollen ' + options.type + ' ' + $().brace(options.length) + ' endgltig gelscht werden?\n\n';
          } else {
            return '\nSoll ' + options.type + ' "' + options.name + '" endgltig gelscht werden?\n\n';
          }
        },
        'REMOVE_AND_DELETE': function(options) {
          if (options.plural) {
            return '\nSollen ' + options.type + ' ' + $().brace(options.length) + ' entfernt und in den Papierkorb verschoben werden?\n\n';
          } else {
            return '\nSoll ' + options.type + ' "' + options.name + '" entfernt und in den Papierkorb verschoben werden?\n\n';
          }
        },
        'NOCAT': function(options) {
          return '\nKeine Kategorie ausgwhlt.\n\n';
        },
        'EMPTYTRASH': function(options) {
          return '\nSoll der Papierkorb geleert werden?\n\n';
        },
        'NO_FAVORITE_FOUND': function(options) {
          return '\nEs existiert kein Produkt des Tages \n\n';
        },
        'FAVORITE_IN_TRASH': function(options) {
          return '\nDas Produkt des Tages befindet sich im Papierkorb \n\n';
        },
        'DESTROY_CATEGORY': function(options) {
          return '\nSoll die Kategorie "' + options.name + '" entfernt werden?\n\n';
        },
        'DESTROY_CATEGORY_NOT_ALLOWED': function(options) {
          return '\nGeschtzte Kategorie!\n\n';
        },
        'NO_VALID_CATEGORY': function(options) {
          return '\nDiese Kategorie untersttzt diese Funktion nicht!\n\n';
        },
        'NO_FAVORITE_FOR_IGNORED': function(options) {
          return '\nAusgeblendeter Artikel kann kein Produkt des Tages sein!\n\n';
        },
        'NO_IGNORE_FOR_FAVORITE': function(options) {
          return '\nEin Produkt des Tages kann nicht ausgeblendet werden!\n\n';
        },
        'METHOD_NOT_SUPPORTED': function(options) {
          return '\nFunktion momentan nicht verfgbar!\n\n';
        },
        'NO_CAT_FOR_UPLOAD': function(options) {
          return '\nEs ist momentan kein Produkt ausgewhlt!\n\nUm den Upload abzuschliessen, markiere ein Produkt und klicke anschliessend unten auf "Start".\n\n';
        }
      };
      this.ALBUM_SINGLE_MOVE = this.createImage('/img/cursor_folder_1.png');
      this.ALBUM_DOUBLE_MOVE = this.createImage('/img/cursor_folder_3.png');
      this.IMAGE_SINGLE_MOVE = this.createImage('/img/cursor_images_1.png');
      this.IMAGE_DOUBLE_MOVE = this.createImage('/img/cursor_images_3.png');
      this.ignoredHashes = ['slideshow', 'preview', 'flickr', 'logout'];
      this.arr = ['false', 'fitness', 'outdoor', 'specials', 'tools', 'defense'];
      $(window).bind('hashchange', this.proxy(this.storeHash));
      User.bind('pinger', this.proxy(this.validate));
      Clipboard.fetch();
      Clipboard.destroyAll();
      Settings.one('refresh', this.proxy(this.refreshSettings));
      Settings.one('change', this.proxy(this.changeSettings));
      $('#modal-category').bind('hidden', this.proxy(this.hideSlideshow));
      this.modalView = new ModalSimpleView;
      this.trustamiView = new TrustamiView({
        el: this.trustamiEl
      });
      this.sidebar = new Sidebar({
        el: this.sidebarEl,
        externalClass: '.optSidebar'
      });
      this.loginView = new LoginView({
        el: this.loginEl
      });
      this.mainView = new MainView({
        el: this.mainEl
      });
      this.loaderView = new LoaderView({
        el: this.loaderEl
      });
      this.showView = new ShowView({
        el: this.showEl,
        activeControl: 'btnCategory',
        sidebar: this.sidebar,
        parent: this
      });
      this.overviewView = new OverviewView({
        el: this.overviewEl
      });
      this.previewView = new PreviewView({
        el: this.previewEl
      });
      this.missingView = new MissingView({
        el: this.missingEl
      });
      this.category = new CategoryEditView({
        el: this.categoryEl,
        externalClass: '.optCategory'
      });
      this.product = new ProductEditView({
        el: this.productEl,
        externalClass: '.optProduct'
      });
      this.upload = new UploadEditView({
        el: this.uploadEl,
        parent: this.showView,
        externalClass: '.optUpload'
      });
      this.slideshowView = this.showView.slideshowView;
      this.vmanager = new Spine.Manager(this.sidebar);
      this.vmanager.external = this.showView.toolbarOne;
      this.vmanager.initDrag(this.vDrag, {
        initSize: (function(_this) {
          return function() {
            return _this.sidebarInitWidth;
          };
        })(this),
        sleep: true,
        disabled: false,
        axis: 'x',
        min: function() {
          return 20;
        },
        tol: function() {
          return 50;
        },
        max: (function(_this) {
          return function() {
            return _this.el.width() / 2;
          };
        })(this),
        goSleep: (function(_this) {
          return function() {
            return _this.sidebar.inner.hide();
          };
        })(this),
        awake: (function(_this) {
          return function() {
            return _this.sidebar.inner.show();
          };
        })(this)
      });
      this.hmanager = new Spine.Manager(this.category, this.product, this.upload);
      this.hmanager.external = this.showView.toolbarOne;
      this.hmanager.initDrag(this.hDrag, {
        initSize: (function(_this) {
          return function() {
            return _this.el.height() * 0.4;
          };
        })(this),
        disabled: false,
        axis: 'y',
        min: function() {
          return 50;
        },
        sleep: true,
        max: (function(_this) {
          return function() {
            return _this.el.height() / 1.5;
          };
        })(this),
        goSleep: function() {},
        awake: function() {}
      });
      this.modal = {
        exists: false
      };
      this.appManager = new Spine.Manager(this.mainView, this.loaderView);
      this.contentManager = new Spine.Manager(this.overviewView, this.showView);
      this.hmanager.bind('awake', (function(_this) {
        return function() {
          return _this.showView.trigger('awake');
        };
      })(this));
      this.hmanager.bind('sleep', (function(_this) {
        return function() {
          return _this.showView.trigger('sleep');
        };
      })(this));
      this.hmanager.bind('change', this.proxy(this.changeEditCanvas));
      this.appManager.bind('change', this.proxy(this.changeMainCanvas));
      this.contentManager.bind('change', this.proxy(this.changeContentCanvas));
      Category.bind('current', this.proxy(this.changeBackground));
      this.bind('canvas', this.proxy(this.canvas));
      this.product.trigger('active');
      this.loaderView.trigger('active');
      this.initializeFileupload();
      this.initRoot();
      this.routes({
        '/category/:cid/:pid/iid/:iid': function(params) {
          var buffer;
          Model.Root.updateSelection(params.cid || []);
          Category.updateSelection(params.pid || []);
          Product.updateSelection(params.iid || []);
          buffer = Photo.renderBuffer();
          return this.showView.trigger('active', this.showView.photosView, buffer || Photo.buffer);
        },
        '/category/:cid/:pid/:iid': function(params) {
          var buffer;
          Model.Root.updateSelection(params.cid || []);
          if (params.pid === 'pid') {
            Category.updateSelection(params.iid || []);
            buffer = Product.renderBuffer();
            return this.showView.trigger('active', this.showView.productsView, buffer || Product.buffer);
          } else {
            Category.updateSelection(params.pid || []);
            Product.updateSelection(params.iid || []);
            buffer = Photo.renderBuffer();
            return this.showView.trigger('active', this.showView.photoView, buffer || Photo.buffer);
          }
        },
        '/category/:cid/:pid': function(params) {
          var buffer;
          if (params.cid === 'cid') {
            buffer = Category.renderBuffer();
            this.showView.trigger('active', this.showView.categoriesView, buffer || Category.buffer);
            return Model.Root.updateSelection(params.pid || []);
          } else {
            Model.Root.updateSelection(params.cid || []);
            Category.updateSelection(params.pid || []);
            Product.updateSelection([]);
            buffer = Photo.renderBuffer();
            return this.showView.trigger('active', this.showView.photosView, buffer || Photo.buffer);
          }
        },
        '/category/:cid': function(params) {
          var buffer;
          Model.Root.updateSelection(params.cid || []);
          Category.updateSelection();
          buffer = Product.renderBuffer();
          return this.showView.trigger('active', this.showView.productsView, buffer || Product.buffer);
        },
        '/category/*': function() {
          Root.updateSelection([]);
          return this.showView.trigger('active', this.showView.categoriesView);
        },
        '/overview/*': function() {
          return this.overviewView.trigger('active');
        },
        '/search/:sid': function(params) {
          this.sidebar.filter({}, params.sid);
          return this.showView.trigger('active', this.showView.productsView);
        },
        '/trash/products/:id': function(params) {
          var items;
          items = Product.filter(true, {
            func: 'selectDeleted'
          });
          return this.showView.trigger('active', this.showView.productsTrashView, items);
        },
        '/trash/photos/:id': function(params) {
          var items;
          items = Photo.filter(true, {
            func: 'selectDeleted'
          });
          return this.showView.trigger('active', this.showView.photosTrashView, items);
        },
        '/wait/*glob': function(params) {
          return this.showView.trigger('active', this.showView.waitView);
        },
        '/*glob': function(params) {
          return this.navigate('/overview', '');
        }
      });
      this.loadToolbars();
      this.defaultSettings = {
        welcomeScreen: false,
        test: true
      };
    }

    Main.prototype.initRoot = function() {
      var root;
      root = new Model.Root();
      root.save();
      return Model.Root.current(root);
    };

    Main.prototype.validate = function(user, json) {
      var intro, jsid, settings, usid, valid;
      valid = (usid = user.sessionid) && (jsid = json.sessionid) && (usid === jsid);
      if (!valid) {
        return User.logout();
      } else {
        this.user = User.user = user;
        user.tmi = json.tmi;
        user.save();
        settings = this.loadUserSettings(user.id);
        this.initLocation(settings);
        this.setInterval(10000);
        this.delay(this.setupView, 500);
        if ((intro = settings.intro) == null) {
          settings.updateAttributes({
            intro: !intro
          });
          intro = true;
        }
        return this.startScript(false);
      }
    };

    Main.prototype.isAdmin = function() {
      return window.location.pathname.indexOf('admin') !== -1;
    };

    Main.prototype.startScript = function(b) {
      setTimeout(function() {
        return App.sidebar.toggleDraghandle();
      }, 2500);
      setTimeout(function() {
        return App.showView.toggleDraghandle();
      }, 3500);
      if (!b) {
        return;
      }
      setTimeout(function() {
        return App.sidebar.toggleDraghandle();
      }, 4500);
      setTimeout(function() {
        return App.sidebar.toggleDraghandle();
      }, 5500);
      setTimeout(function() {
        return App.showView.toggleDraghandle();
      }, 6500);
      setTimeout(function() {
        return App.showView.toggleDraghandle();
      }, 7500);
      setTimeout(function() {
        return App.vDragHandle.addClass('fire puls');
      }, 9000);
      setTimeout(function() {
        return App.vDragHandle.removeClass('fire puls');
      }, 12000);
      setTimeout(function() {
        return App.hDragHandle.addClass('fire puls');
      }, 9000);
      setTimeout(function() {
        return App.hDragHandle.removeClass('fire puls');
      }, 12000);
      return setTimeout(function() {
        return alert('Intro abschalten ber Extras -> Intro-Quatsch');
      }, 13000);
    };

    Main.prototype.loadUserSettings = function(id) {
      var settings;
      Settings.fetch();
      if (!(settings = Settings.findByAttribute('user_id', id))) {
        Spine.trigger('show:wait', {
          small: true,
          header: false,
          body: '<h3>Welcome</h3><br>to<br><h4>HA Lehmann Admin</h4><h2>Beta</h2>',
          footer: false
        });
        settings = Settings.create({
          user_id: id,
          autoupload: this.autoupload,
          intro: this.intro
        });
      }
      return settings;
    };

    Main.prototype.initLocation = function(settings) {
      var h, hash;
      if (location.hash) {
        return;
      }
      hash = (h = settings.hash) ? h : '#/overview/';
      return this.navigate(hash);
    };

    Main.prototype.setInterval = function(time) {
      var callback, func;
      callback = (function(_this) {
        return function(json) {
          var sessionid, success;
          json = $.parseJSON(json);
          success = json.success;
          sessionid = json.sessionid;
          _this.user.sessionid = sessionid;
          return _this.user.save();
        };
      })(this);
      func = (function(_this) {
        return function() {
          return _this.user.isValid(callback);
        };
      })(this);
      if (this.user) {
        if (this.uuid) {
          clearInterval(this.uuid);
        }
        this.uuid = User.uuid();
        return this.uuid = setInterval(func, time);
      }
    };

    Main.prototype.test = function() {
      return console.log('Test');
    };

    Main.prototype.storeHash = function() {
      var hash, settings;
      if (!(settings = Settings.loadSettings())) {
        return;
      }
      hash = location.hash;
      if (!this.ignoredHashes.contains(hash)) {
        settings.previousHash = settings.hash;
      }
      settings.hash = hash;
      return settings.save();
    };

    Main.prototype.fullscreen = function() {
      return Spine.trigger('chromeless', true);
    };

    Main.prototype.changeBackground = function(cat) {
      var arr, c, i, len, res;
      arr = this.arr;
      res = this.getData(cat, arr);
      for (i = 0, len = arr.length; i < len; i++) {
        c = arr[i];
        this.el.removeClass(c);
      }
      return this.el.addClass(res);
    };

    Main.prototype.notify = function(text) {
      return this.modalView.render({
        small: true,
        body: function() {
          return require("views/notify")({
            text: text
          });
        }
      }).show();
    };

    Main.prototype.refreshSettings = function(records) {};

    Main.prototype.changeSettings = function(rec) {};

    Main.prototype.setupView = function() {
      this.log('setup View');
      Spine.unbind('uri:alldone');
      this.mainView.trigger('active');
      this.mainView.el.hide();
      return this.statusSymbol.fadeOut('slow', this.proxy(this.finalizeView));
    };

    Main.prototype.finalizeView = function() {
      this.loginView.render();
      return this.mainView.el.fadeIn(500);
    };

    Main.prototype.startPage = function() {
      var ref;
      return;
      if (!/^#\/category\//.test(location.hash)) {
        return this.navigate('/category', (ref = Category.first()) != null ? ref.id : void 0);
      }
    };

    Main.prototype.canvas = function(controller) {
      return controller.trigger('active');
    };

    Main.prototype.changeMainCanvas = function(controller) {};

    Main.prototype.changeContentCanvas = function(controller, b) {
      var _1, c, i, len, ref;
      this.controllers = (function() {
        var i, len, ref, results;
        ref = this.contentManager.controllers;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c !== controller) {
            results.push(c);
          }
        }
        return results;
      }).call(this);
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        c.el.removeClass('show');
      }
      _1 = (function(_this) {
        return function() {
          return controller.el.addClass('show');
        };
      })(this);
      return window.setTimeout((function(_this) {
        return function() {
          return _1();
        };
      })(this), 500);
    };

    Main.prototype.changeEditCanvas = function(controller) {};

    Main.prototype.initializeFileupload = function() {
      return this.uploader.fileupload({
        autoUpload: true,
        singleFileUploads: false,
        sequentialUploads: true,
        pasteZone: false,
        maxFileSize: 10000000,
        maxNumberOfFiles: 20,
        acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
        getFilesFromResponse: function(data) {
          var file, i, len, ref, res;
          res = [];
          ref = data.files;
          for (i = 0, len = ref.length; i < len; i++) {
            file = ref[i];
            res.push(file);
          }
          return res;
        }
      });
    };

    Main.prototype.loadToolbars = function() {
      return Toolbar.load();
    };

    Main.prototype.activateEditor = function(e) {
      var el, test;
      el = $(e.currentTarget);
      test = el.prop('class');
      if (/\bcat-trigger*/.test(test)) {
        this.category.trigger('active');
      } else if (/\bpro-trigger*/.test(test)) {
        this.product.trigger('active');
      } else if (/\bpho-trigger*/.test(test)) {
        this.upload.trigger('active');
      }
      e.stopPropagation();
      return e.preventDefault();
    };

    Main.prototype.getData = function(s) {
      var a, i, len, ref, ret, test;
      test = function(s, a) {
        var found, matcher;
        matcher = new RegExp(".*" + a + ".*", "g");
        return found = matcher.test(s);
      };
      ref = this.arr;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        if (test(s, a)) {
          ret = a;
        }
      }
      return ret;
    };

    Main.prototype.confirm = function(phrase, options) {
      var defaults, e;
      if (phrase == null) {
        phrase = 'kein Ausgabetext vorhanden';
      }
      if (options == null) {
        options = {};
      }
      defaults = {
        plural: false,
        mode: 'confirm'
      };
      options = $().extend(defaults, options);
      try {
        if (window[options.mode].call(null, this.CONFIRM[phrase](options))) {
          return true;
        }
      } catch (error) {
        e = error;
      }
    };

    Main.prototype.key = function(e) {
      var code, el, isFormfield, type;
      code = e.charCode || e.keyCode;
      type = e.type;
      el = $(document.activeElement);
      isFormfield = $().isFormElement(el);
      if (type !== 'keydown') {
        return;
      }
      switch (code) {
        case 8:
          if (!isFormfield) {
            return e.preventDefault();
          }
          break;
        case 9:
          if (!isFormfield) {
            this.sidebar.toggleDraghandle();
            return e.preventDefault();
          }
          break;
        case 13:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView);
            return e.preventDefault();
          }
          break;
        case 27:
          if (!isFormfield) {
            if (this.overviewView.isActive()) {
              this.delegateFocus(e, this.overviewView);
            } else {
              this.delegateFocus(e, this.showView);
            }
            return e.preventDefault();
          }
          break;
        case 32:
          if (!isFormfield) {
            if (this.overviewView.isActive()) {
              this.delegateFocus(e, this.overviewView);
            } else {
              this.delegateFocus(e, this.showView);
            }
            return e.preventDefault();
          }
          break;
        case 37:
          if (!isFormfield) {
            if (this.overviewView.isActive()) {
              this.delegateFocus(e, this.overviewView);
            } else {
              this.delegateFocus(e, this.showView.current);
            }
            return e.preventDefault();
          }
          break;
        case 38:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView.current);
            return e.preventDefault();
          }
          break;
        case 39:
          if (!isFormfield) {
            if (this.overviewView.isActive()) {
              this.delegateFocus(e, this.overviewView);
            } else {
              this.delegateFocus(e, this.showView.current);
            }
            return e.preventDefault();
          }
          break;
        case 40:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView.current);
            return e.preventDefault();
          }
          break;
        case 65:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView.current);
            return e.preventDefault();
          }
          break;
        case 73:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView.current);
            return e.preventDefault();
          }
          break;
        case 77:
          if (!isFormfield) {
            this.delegateFocus(e, this.showView);
            return e.preventDefault();
          }
          break;
        case 86:
          if (isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return e.stopPropagation();
            }
          }
      }
    };

    Main.prototype.delegateFocus = function(e, controller) {
      var el;
      if (controller == null) {
        controller = this.showView;
      }
      el = $(document.activeElement);
      if ($().isFormElement(el)) {
        return;
      }
      return controller.focus();
    };

    return Main;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Main;
  }

}).call(this);
 },"controllers/categories_header": function(exports, require, module) { (function() {
  var $, CategoriesHeader, CategoriesProduct, Category, Extender, Photo, Product, ProductsPhoto, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Extender = require('extensions/controller_extender');

  CategoriesHeader = (function(superClass) {
    extend(CategoriesHeader, superClass);

    CategoriesHeader.extend(Extender);

    function CategoriesHeader() {
      CategoriesHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Category.bind('change', this.proxy(this.render));
      Category.bind('refresh', this.proxy(this.render));
      Category.bind('change:current', this.proxy(this.render));
      Product.bind('change', this.proxy(this.render));
      Product.bind('change:collection', this.proxy(this.render));
      Photo.bind('refresh', this.proxy(this.render));
    }

    CategoriesHeader.prototype.render = function() {
      return this.html(this.template({
        model: Category,
        modelProduct: Product,
        modelPhoto: Photo,
        modelGas: CategoriesProduct,
        modelAps: ProductsPhoto,
        author: User.first().name
      }));
    };

    CategoriesHeader.prototype.count = function() {
      return Category.count();
    };

    CategoriesHeader.prototype.active = function() {
      return this.render();
    };

    CategoriesHeader.prototype.goUp = function(e) {
      this.navigate('/overview', '');
      e.preventDefault();
      return e.stopPropagation();
    };

    return CategoriesHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CategoriesHeader;
  }

}).call(this);
 },"controllers/categories_list": function(exports, require, module) { (function() {
  var $, CategoriesList, CategoriesProduct, Category, Drag, Extender, Photo, ProductsPhoto, Root, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Spine = require("spine");

  $ = Spine.$;

  Root = require("models/root");

  Category = require('models/category');

  Photo = require('models/photo');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Drag = require('extensions/drag');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  CategoriesList = (function(superClass) {
    extend(CategoriesList, superClass);

    CategoriesList.extend(Extender);

    CategoriesList.prototype.events = {
      'click .dropdown-toggle': 'dropdownToggle',
      'click .delete': 'deleteCategory',
      'click .zoom': 'zoom'
    };

    function CategoriesList() {
      CategoriesList.__super__.constructor.apply(this, arguments);
      Product.bind('change:collection', this.proxy(this.renderRelated));
      Category.bind('change', this.proxy(this.renderOne));
      Category.bind('destroy', this.proxy(this.testEmpty));
      CategoriesProduct.bind('change', this.proxy(this.renderOneRelated));
      Photo.bind('destroy', this.proxy(this.renderRelated));
      Product.bind('destroy', this.proxy(this.renderRelated));
      Root.bind('change:selection', this.proxy(this.exposeSelection));
    }

    CategoriesList.prototype.test = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return console.log(args);
    };

    CategoriesList.prototype.renderOneRelated = function(ga) {
      var category;
      category = Category.find(ga.category_id);
      if (category) {
        return this.updateTemplate(category);
      }
    };

    CategoriesList.prototype.renderRelated = function() {
      if (!this.parent.isActive()) {
        return;
      }
      this.log('renderRelated');
      return this.updateTemplates();
    };

    CategoriesList.prototype.renderOne = function(item, mode) {
      this.log('renderOne');
      switch (mode) {
        case 'create':
          this.wipe();
          this.append(this.template(item));
          this.reorder(item);
          this.delay(this.proxy(this.exposeSelection), 2000);
          break;
        case 'update':
          this.updateTemplate(item);
          $('.dropdown-toggle', this.el).dropdown();
          this.reorder(item);
          this.exposeSelection();
          break;
        case 'destroy':
          this.exposeSelection();
      }
      return this.el;
    };

    CategoriesList.prototype.render = function(items, mode) {
      var ref, ref1, ref2, s;
      if (!items.length) {
        s = (s = ((ref = this.model.record) != null ? ref.screenname : void 0) || (s = ((ref1 = this.model.record) != null ? ref1.name : void 0) || (s = (ref2 = this.model.record) != null ? ref2.title : void 0))) != null ? 'in ' + s + ' nichts los - kein Moos' : 'nichts los hier. Brutal...';
        this.renderEmpty(s);
        return this.el;
      }
      this.html(this.template(items));
      this.exposeSelection();
      $('.dropdown-toggle', this.el).dropdown();
      this.el.sortable('categories');
      return this.el;
    };

    CategoriesList.prototype.updateTemplates = function() {
      var category, j, len, ref, results;
      this.log('updateTemplates');
      ref = Category.records;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        category = ref[j];
        results.push(this.updateTemplate(category));
      }
      return results;
    };

    CategoriesList.prototype.updateTemplate = function(item) {
      var active, hot, innerEl, itemEl, style, tmplItem;
      itemEl = this.children().forItem(item);
      active = itemEl.hasClass('active');
      hot = itemEl.hasClass('hot');
      innerEl = $('.thumbnail', itemEl);
      style = innerEl.attr('style');
      tmplItem = innerEl.tmplItem();
      tmplItem.data = item;
      if (typeof tmplItem.update === "function") {
        tmplItem.update();
      }
      itemEl.attr('id', item.id);
      itemEl.toggleClass('active', active);
      itemEl.toggleClass('hot', hot);
      innerEl.attr('style', style);
      return this.el.sortable();
    };

    CategoriesList.prototype.reorder = function(item) {
      var children, id, idxAfterSort, idxBeforeSort, index, newEl, oldEl;
      id = item.id;
      index = function(id, list) {
        var i, itm, j, len;
        for (i = j = 0, len = list.length; j < len; i = ++j) {
          itm = list[i];
          if (itm.id === id) {
            return i;
          }
        }
        return i;
      };
      children = this.children();
      oldEl = this.children().forItem(item);
      idxBeforeSort = this.children().index(oldEl);
      idxAfterSort = index(id, Category.all().sort(Category.sortByOrder));
      newEl = $(children[idxAfterSort]);
      if (idxBeforeSort < idxAfterSort) {
        return newEl.after(oldEl);
      } else if (idxBeforeSort > idxAfterSort) {
        return newEl.before(oldEl);
      }
    };

    CategoriesList.prototype.dropdownToggle = function(e) {
      var el;
      e.preventDefault();
      e.stopPropagation();
      el = $(e.currentTarget);
      return el.dropdown();
    };

    CategoriesList.prototype.zoom = function(e) {
      var cid, item, pid, ref;
      item = e.type === 'click' ? $(e.currentTarget).item() : this.models.record;
      if (cid = item != null ? item.id : void 0) {
        this.navigate('/category', cid, pid = (pid = (ref = Category.record) != null ? ref.selectionList().first() : void 0) ? 'pid/' + pid : null);
      } else {
        this.navigate('/category', '');
      }
      e.stopPropagation();
      return e.preventDefault();
    };

    CategoriesList.prototype.back = function(e) {
      e.stopPropagation();
      e.preventDefault();
      return this.navigate('/overview', '');
    };

    CategoriesList.prototype.deleteCategory = function(e) {
      var el, item;
      e.stopPropagation();
      e.preventDefault();
      item = $(e.currentTarget).item();
      el = $(e.currentTarget).parents('.item');
      if (item) {
        return Spine.trigger('delete:category', item.id);
      }
    };

    return CategoriesList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CategoriesList;
  }

}).call(this);
 },"controllers/categories_view": function(exports, require, module) { (function() {
  var $, CategoriesList, CategoriesProduct, CategoriesView, Category, Drag, Extender, ProductsPhoto, Root, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Drag = require('extensions/drag');

  Root = require('models/root');

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  CategoriesList = require("controllers/categories_list");

  ProductsPhoto = require('models/products_photo');

  Extender = require('extensions/controller_extender');

  CategoriesView = (function(superClass) {
    extend(CategoriesView, superClass);

    CategoriesView.extend(Drag);

    CategoriesView.extend(Extender);

    CategoriesView.prototype.elements = {
      '.items': 'items'
    };

    CategoriesView.prototype.events = {
      'click': 'clearSelection',
      'click .item': 'click',
      'mousemove .item': 'infoUp',
      'mouseleave .item': 'infoBye',
      'dragend': 'dragend',
      'dragstart': 'dragstart',
      'drop       ': 'drop',
      'dragover   ': 'dragover',
      'dragenter  ': 'dragenter',
      'sortupdate': 'sortupdate'
    };

    CategoriesView.prototype.headerTemplate = function(items) {
      return $("#headerCategoryTemplate").tmpl(items);
    };

    CategoriesView.prototype.template = function(items) {
      return $("#categoriesTemplate").tmpl(items);
    };

    function CategoriesView() {
      this.infoBye = bind(this.infoBye, this);
      this.infoUp = bind(this.infoUp, this);
      CategoriesView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.list = new CategoriesList({
        el: this.items,
        template: this.template,
        parent: this
      });
      this.header.template = this.headerTemplate;
      this.viewport = this.list.el;
      Category.one('refresh', this.proxy(this.render));
      Category.bind('beforeSave', this.proxy(this.createProtected));
      Category.bind('beforeDestroy', this.proxy(this.beforeDestroy));
      Category.bind('destroy', this.proxy(this.destroy));
      Category.bind('refresh:category', this.proxy(this.render));
      this.bind('drag:start', this.proxy(this.dragStart));
      this.bind('drag:enter', this.proxy(this.dragEnter));
      this.bind('drag:over', this.proxy(this.dragOver));
      this.bind('drag:leave', this.proxy(this.dragLeave));
      this.bind('drag:drop', this.proxy(this.dragDrop));
    }

    CategoriesView.prototype.render = function(items) {
      items = Category.records.sort(Category.sortByOrder);
      return this.list.render(items);
    };

    CategoriesView.prototype.active = function(items) {
      App.showView.trigger('change:toolbarOne', ['Default']);
      App.showView.trigger('change:toolbarTwo', ['Trustami']);
      return this.render(items);
    };

    CategoriesView.prototype.click = function(e) {
      var item;
      item = $(e.currentTarget).item();
      return this.select(e, item.id);
    };

    CategoriesView.prototype.select = function(e, ids) {
      if (ids == null) {
        ids = [];
      }
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      this.navigate('/category', 'cid', ids[0]);
      this.model.updateSelection(ids);
      return e.stopPropagation();
    };

    CategoriesView.prototype.beforeDestroy = function(item) {
      if (!item.isValid()) {
        return;
      }
      return this.list.findModelElement(item).detach();
    };

    CategoriesView.prototype.destroy = function(item) {
      var ref;
      if (item) {
        if (((ref = Category.record) != null ? ref.id : void 0) === (item != null ? item.id : void 0)) {
          Category.current();
        }
        item.removeSelectionID();
        Root.removeFromSelection(item.id);
      }
      if (Category.count()) {
        if (!/^#\/category\//.test(location.hash)) {
          return this.navigate('/category', Category.first().id);
        }
      }
    };

    CategoriesView.prototype.newAttributes = function() {
      if (User.first()) {
        return {
          name: 'New Name',
          user_id: User.first().id,
          author: User.first().name
        };
      } else {
        return User.ping();
      }
    };

    CategoriesView.prototype.createProtected = function(item) {
      var key, ref, results, val;
      ref = Category["protected"];
      results = [];
      for (key in ref) {
        val = ref[key];
        if (!Category.findByAttribute('name', key)) {
          item.name = key;
          item.screenname = val.screenname;
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CategoriesView.prototype.sortupdate = function(e, o) {
      var cb;
      cb = (function(_this) {
        return function() {
          Category.trigger('change:collection', Category.record);
          return _this.render();
        };
      })(this);
      return this.list.children().each(function(index) {
        var item;
        item = $(this).item();
        if (item) {
          if (parseInt(item.order) !== index) {
            item.order = index;
            return item.save({
              done: cb,
              validate: false
            });
          }
        }
      });
    };

    CategoriesView.prototype.infoUp = function(e) {
      var el;
      el = $(e.currentTarget);
      return $('.glyphicon-set.fade', el).addClass('show').removeClass('fade');
    };

    CategoriesView.prototype.infoBye = function(e) {
      var el, set;
      el = $(e.currentTarget);
      return set = $('.glyphicon-set.fade', el).addClass('fade').removeClass('show');
    };

    return CategoriesView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CategoriesView;
  }

}).call(this);
 },"controllers/category_edit_view": function(exports, require, module) { (function() {
  var $, Category, CategoryEditView, Extender, KeyEnhancer, Root, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  KeyEnhancer = require('extensions/key_enhancer');

  Extender = require('extensions/controller_extender');

  Category = require("models/category");

  Root = require("models/root");

  CategoryEditView = (function(superClass) {
    extend(CategoryEditView, superClass);

    CategoryEditView.extend(Extender);

    CategoryEditView.prototype.elements = {
      '.content': 'content'
    };

    CategoryEditView.prototype.events = {
      'keyup': 'saveOnKeyup'
    };

    CategoryEditView.prototype.template = function(item) {
      return $('#editCategoryTemplate').tmpl(item);
    };

    function CategoryEditView() {
      CategoryEditView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Category.bind('current', this.proxy(this.change));
    }

    CategoryEditView.prototype.active = function() {
      return this.render();
    };

    CategoryEditView.prototype.change = function(item) {
      this.current = item;
      return this.render();
    };

    CategoryEditView.prototype.change_ = function(item) {
      this.current = item;
      return this.render();
    };

    CategoryEditView.prototype.render = function() {
      if (this.current) {
        this.content.html(this.template(this.current));
      } else {
        this.renderEmpty('Keine Kategorie ausgewhlt', 'content');
      }
      return this.el;
    };

    CategoryEditView.prototype.save = function(el) {
      var atts, category;
      this.log('save');
      if (category = Category.record) {
        atts = (typeof el.serializeForm === "function" ? el.serializeForm() : void 0) || this.el.serializeForm();
        return category.updateChangedAttributes(atts);
      }
    };

    CategoryEditView.prototype.saveOnKeyup = function(e) {
      var code;
      this.log('saveOnEnter');
      code = e.charCode || e.keyCode;
      switch (code) {
        case 32:
          e.stopPropagation();
          break;
        case 9:
          e.stopPropagation();
      }
      return this.save(this.el);
    };

    CategoryEditView.prototype.createCategory = function() {
      return Spine.trigger('create:category');
    };

    CategoryEditView.prototype.click = function(e) {};

    return CategoryEditView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CategoryEditView;
  }

}).call(this);
 },"controllers/flickr_view": function(exports, require, module) { (function() {
  var $, Extender, FlickrView, Settings, Spine, ToolbarView,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Spine = require('spine');

  $ = Spine.$;

  ToolbarView = require("controllers/toolbar_view");

  Settings = require("models/settings");

  Extender = require('extensions/controller_extender');

  FlickrView = (function(superClass) {
    extend(FlickrView, superClass);

    FlickrView.extend(Extender);

    FlickrView.prototype.elements = {
      '.links': 'links',
      '.content': 'content',
      '.toolbarOne': 'toolbarOneEl',
      '.toolbarTwo': 'toolbarTwoEl'
    };

    FlickrView.prototype.events = {
      'click button.close': 'close',
      'click .recent': 'navRecent',
      'click .inter': 'navInter',
      'click .links': 'click',
      'click .opt-Prev': 'prevPage',
      'click .opt-Next': 'nextPage'
    };

    FlickrView.prototype.template = function(items) {
      return $('#flickrTemplate').tmpl(items);
    };

    FlickrView.prototype.toolsTemplate = function(items) {
      return $("#toolsTemplate").tmpl(items);
    };

    FlickrView.prototype.introTemplate = function() {
      return $('#flickrIntroTemplate').tmpl();
    };

    function FlickrView() {
      this.doneResponse = bind(this.doneResponse, this);
      FlickrView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.type = 'recent';
      this.perpage = 100;
      this.spec = {
        recent: {
          min: 1,
          page: 1,
          pages: 5,
          per_page: this.perpage
        },
        inter: {
          min: 1,
          page: 1,
          pages: 5,
          per_page: this.perpage
        }
      };
      this.toolbar_one = new ToolbarView({
        el: this.toolbarOneEl,
        template: this.toolsTemplate
      });
      this.toolbar_two = new ToolbarView({
        el: this.toolbarTwoEl,
        template: this.toolsTemplate
      });
      this.bind('flickr:recent', this.proxy(this.recent));
      this.bind('flickr:inter', this.proxy(this.interestingness));
    }

    FlickrView.prototype.render = function(items) {
      if (items) {
        this.content.html(this.template(items));
      } else {
        this.content.html(this.introTemplate());
        this.toolbarOneEl.empty();
      }
      return this.changeToolbar(this.toolbar_two, ['Close']);
    };

    FlickrView.prototype.active = function() {
      if (arguments.length) {
        return this.setup(arguments[0], arguments[1]);
      } else {
        return this.render();
      }
    };

    FlickrView.prototype.url = function() {
      var protocol;
      protocol = window.location.protocol === 'https:' ? 'https://secure' : 'http://api';
      protocol = 'https://secure';
      return protocol + '.flickr.com/services/rest/';
    };

    FlickrView.prototype.data = {
      format: 'json',
      method: 'flickr.activity.userPhotos',
      api_key: '1cb992dd2b14ba97327aea602e3922e6'
    };

    FlickrView.prototype.setup = function(mode, page) {
      var options, toolsList_one, toolsList_two;
      this.log('setup');
      this.type = mode;
      switch (mode) {
        case 'recent':
          toolsList_one = ['FlickrRecent'];
          toolsList_two = ['Close'];
          options = {
            page: page || this.spec[mode].page,
            method: 'flickr.photos.getRecent'
          };
          this.changeToolbar(this.toolbar_one, toolsList_one);
          break;
        case 'inter':
          toolsList_one = ['FlickrInter'];
          toolsList_two = ['Close'];
          options = {
            page: page || this.spec[mode].page,
            method: 'flickr.interestingness.getList'
          };
          this.changeToolbar(this.toolbar_one, toolsList_one);
          break;
        default:
          return this.render();
      }
      options = $().extend(this.spec[mode], options);
      return this.ajax(options);
    };

    FlickrView.prototype.ajax = function(options) {
      var data;
      this.log('ajax');
      data = $().extend(this.data, options);
      return $.ajax({
        url: this.url(),
        data: data,
        dataType: 'jsonp',
        jsonp: 'jsoncallback'
      }).done(this.doneResponse).fail(this.failResponse);
    };

    FlickrView.prototype.doneResponse = function(result) {
      this.updateSpecs(result);
      return this.render(result.photos.photo);
    };

    FlickrView.prototype.failResponse = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.log(args);
    };

    FlickrView.prototype.changeToolbar = function(tb, list) {
      tb.change(list);
      return this.refreshElements();
    };

    FlickrView.prototype.click = function(e) {
      var links, options, target;
      e.stopPropagation();
      e.preventDefault();
      target = $(e.target).parent()[0];
      options = {
        index: target
      };
      links = $('a', this.links);
      return blueimp.Category(links, options);
    };

    FlickrView.prototype.prevPage = function(e) {
      var t, type;
      e.stopPropagation();
      e.preventDefault();
      type = this.type;
      this.spec[type].page = (t = (this.spec[type].page || 1) - 1) >= 1 ? t : 1;
      return this.navigate('/flickr', type, this.spec[type].page);
    };

    FlickrView.prototype.nextPage = function(e) {
      var t, type;
      e.stopPropagation();
      e.preventDefault();
      type = this.type;
      this.spec[type].page = (t = (this.spec[type].page || 1) + 1) <= this.spec[type].pages ? t : this.spec[type].pages;
      return this.navigate('/flickr', type, this.spec[type].page);
    };

    FlickrView.prototype.details = function(type) {
      var page, perpage;
      page = Number(this.spec[type].page);
      perpage = Number(this.spec[type].per_page);
      return {
        from: ((page - 1) * perpage) + 1,
        to: ((page - 1) * perpage) + perpage
      };
    };

    FlickrView.prototype.updateSpecs = function(res) {
      var type;
      type = this.type;
      $().extend(this.spec[type], res.photos);
      return delete this.spec[type].photo;
    };

    FlickrView.prototype.recent = function(page) {
      return this.setup('recent', page);
    };

    FlickrView.prototype.interestingness = function(page) {
      return this.setup('inter', page);
    };

    FlickrView.prototype.navRecent = function(e) {
      e.stopPropagation();
      e.preventDefault();
      return this.navigate('/flickr', 'recent/1');
    };

    FlickrView.prototype.navInter = function(e) {
      e.stopPropagation();
      e.preventDefault();
      return this.navigate('/flickr', 'inter/1');
    };

    FlickrView.prototype.close = function(e) {
      var previousHash;
      e.preventDefault();
      e.stopPropagation();
      if (previousHash = Settings.loadSettings().previousHash) {
        return location.hash = previousHash;
      } else {
        return this.navigate('/categories/');
      }
    };

    return FlickrView;

  })(Spine.Controller);

  module.exports = FlickrView;

}).call(this);
 },"controllers/homepage_list": function(exports, require, module) { (function() {
  var $, HomepageList, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  require('extensions/tmpl');

  HomepageList = (function(superClass) {
    extend(HomepageList, superClass);

    HomepageList.prototype.elements = {
      '.pricing__item': 'item'
    };

    HomepageList.prototype.events = {
      'click .pricing__item img': 'click'
    };

    HomepageList.prototype.template = function(item) {
      return $('#norbuPricingTemplate').tmpl(item);
    };

    function HomepageList() {
      HomepageList.__super__.constructor.apply(this, arguments);
    }

    HomepageList.prototype.render = function(items) {
      this.html(this.template(items));
      this.refreshElements();
      return this.el;
    };

    HomepageList.prototype.click = function(e) {
      var item;
      item = $(e.currentTarget).parents('.pricing__item').item();
      return this.navigate('/item', item.id);
    };

    return HomepageList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HomepageList;
  }

}).call(this);
 },"controllers/homepage_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, HomepageList, HomepageView, Spine, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  Extender = require('extensions/controller_extender');

  UriHelper = require('extensions/uri_helper');

  HomepageList = require('controllers/homepage_list');

  HomepageView = (function(superClass) {
    extend(HomepageView, superClass);

    HomepageView.prototype.elements = {
      '.items': 'items'
    };

    HomepageView.extend(Extender);

    HomepageView.extend(UriHelper);

    function HomepageView() {
      HomepageView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.list = new HomepageList({
        el: this.items,
        parent: this
      });
      Category.one('refresh', this.proxy(this.active));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
      Spine.bind('refresh:done', this.proxy(this.render));
    }

    HomepageView.prototype.active = function() {
      var cat;
      cat = Category.current(Category.findByAttribute('name', this.categoryName));
      return this.change(cat);
    };

    HomepageView.prototype.change = function(cat) {
      Spine.trigger('active:category', cat);
      this.current = cat;
      return this.render();
    };

    HomepageView.prototype.refreshOne = function() {
      return this.tracker = [Photo.one('refresh', this.proxy(this.untrackBinds)), Description.one('refresh', this.proxy(this.untrackBinds)), Product.one('refresh', this.proxy(this.untrackBinds)), Category.one('refresh', this.proxy(this.untrackBinds))];
    };

    HomepageView.prototype.untrackBinds = function(arr) {
      this.tracker.pop();
      if (!this.tracker.length) {
        return Spine.trigger('refresh:done');
      }
    };

    HomepageView.prototype.render = function() {
      var j, len, p, product, products, results;
      if (!this.current) {
        return;
      }
      products = Category.publishedProducts(this.current.id);
      this.list.render(products);
      results = [];
      for (j = 0, len = products.length; j < len; j++) {
        product = products[j];
        this.callDeferred(p = product.photos(), this.uriSettings(300, 300), this.proxy(this.callback));
        if (p.length > 1) {
          results.push(pricingSlider(product.id));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    HomepageView.prototype.callback = function(json, items) {
      var idx, j, jsn, key, len, res, result, results, ret, val;
      result = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = json.length; j < len; j++) {
          jsn = json[j];
          ret = (function() {
            var results1;
            results1 = [];
            for (key in jsn) {
              val = jsn[key];
              results1.push({
                src: val.src,
                id: key
              });
            }
            return results1;
          })();
          results.push(ret[0]);
        }
        return results;
      })();
      results = [];
      for (idx = j = 0, len = result.length; j < len; idx = ++j) {
        res = result[idx];
        results.push(this.snap(res, result.length, idx));
      }
      return results;
    };

    HomepageView.prototype.snap = function(res, l, i) {
      var img, imgEl;
      imgEl = $('#' + res.id + ' img', this.el);
      img = this.createImage();
      img.imgEl = imgEl;
      img.l = l;
      img.i = i;
      img.me = this;
      img.res = res;
      img.onload = this.onLoad;
      img.onerror = this.onError;
      return img.src = res.src;
    };

    HomepageView.prototype.onLoad = function() {
      this.imgEl.attr('src', this.src).removeClass('load').addClass('show');
      if (this.i === this.l - 1) {
        return this.me.log('all loaded');
      }
    };

    HomepageView.prototype.onError = function(e) {
      throw 'unable to load image (Homepage)';
    };

    return HomepageView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HomepageView;
  }

}).call(this);
 },"controllers/info": function(exports, require, module) { (function() {
  var $, Info, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Info = (function(superClass) {
    extend(Info, superClass);

    function Info() {
      this.position = bind(this.position, this);
      Info.__super__.constructor.apply(this, arguments);
      this.el.addClass('away').removeClass('show');
      this.parent = this.el.parent();
    }

    Info.prototype.render = function(item) {
      this.html(this.template(item));
      return this.el;
    };

    Info.prototype.up = function(e) {
      var bye, item, ref;
      bye = (function(_this) {
        return function() {
          return _this.bye();
        };
      })(this);
      item = $(e.currentTarget).item();
      clearTimeout(this.timer);
      clearTimeout(this.timer_);
      this.timer = setTimeout(bye, 2000);
      this.el.removeClass('away').addClass('show');
      if (!(this.current && ((ref = this.current) != null ? ref.id : void 0) === item.id)) {
        this.current = item;
        this.render(this.current);
      }
      return this.position(e);
    };

    Info.prototype.bye = function() {
      var stop;
      if (!this.current) {
        return;
      }
      stop = (function(_this) {
        return function() {
          return _this.stop();
        };
      })(this);
      this.el.removeClass('show');
      clearTimeout(this.timer_);
      return this.timer_ = setTimeout(stop, 200);
    };

    Info.prototype.stop = function() {
      this.el.addClass('away');
      return this.current = null;
    };

    Info.prototype.position = function(e) {
      var h, info_h, info_w, maxx, maxy, minx, posx, posy, s, t, w, x_offset, y_offset;
      info_h = this.el.innerHeight();
      info_w = this.el.innerWidth();
      w = $(window).width();
      h = $(window).height();
      t = $(window).scrollTop();
      s = this.parent.scrollTop();
      x_offset = 10;
      y_offset = 10;
      posx = e.pageX + x_offset - this.parent.offset().left;
      posy = e.pageY + y_offset - this.parent.offset().top + s;
      maxx = posx + info_w;
      minx = posx - info_w;
      maxy = posy + info_h;
      if (maxx >= w) {
        posx = e.pageX - info_w - x_offset;
      }
      if (maxy >= (h + t)) {
        posy = e.pageY - info_h - y_offset;
      }
      return this.el.css({
        top: posy + 'px',
        left: posx + 'px'
      });
    };

    return Info;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Info;
  }

}).call(this);
 },"controllers/loader_view": function(exports, require, module) { (function() {
  var $, Extender, LoaderView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Extender = require('extensions/controller_extender');

  LoaderView = (function(superClass) {
    extend(LoaderView, superClass);

    LoaderView.extend(Extender);

    function LoaderView() {
      LoaderView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    LoaderView.prototype.active = function() {};

    return LoaderView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = LoaderView;
  }

}).call(this);
 },"controllers/login_view": function(exports, require, module) { (function() {
  var $, LoginView, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  User = require('models/user');

  LoginView = (function(superClass) {
    extend(LoginView, superClass);

    LoginView.prototype.elements = {
      'button': 'logoutEl'
    };

    LoginView.prototype.events = {
      'click .opt-logout': 'logout',
      'click .opt-trace': 'toggleTrace'
    };

    function LoginView() {
      LoginView.__super__.constructor.apply(this, arguments);
    }

    LoginView.prototype.template = function() {
      return $('#loginTemplate').tmpl({
        user: User.first(),
        trace: !Spine.isProduction
      });
    };

    LoginView.prototype.logout = function() {
      return User.logout();
    };

    LoginView.prototype.toggleTrace = function() {
      Spine.isProduction = localStorage.isProduction = localStorage.isProduction === 'false';
      this.render();
      if (confirm('Entwickler Modus: ' + (Spine.isProduction ? 'Aus' : 'An') + '\n\Die Anwendung muss neu gestartet werden.\n\nFortfahren mit OK')) {
        $(window).off();
        return User.redirect('logout');
      }
    };

    LoginView.prototype.render = function() {
      return this.html(this.template());
    };

    return LoginView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = LoginView;
  }

}).call(this);
 },"controllers/main_view": function(exports, require, module) { (function() {
  var $, Extender, MainView, Model, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Extender = require('extensions/controller_extender');

  MainView = (function(superClass) {
    extend(MainView, superClass);

    MainView.extend(Extender);

    function MainView() {
      MainView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    MainView.prototype.active = function() {};

    return MainView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MainView;
  }

}).call(this);
 },"controllers/missing_view": function(exports, require, module) { (function() {
  var $, MissingView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  MissingView = (function(superClass) {
    extend(MissingView, superClass);

    MissingView.prototype.events = {
      'click .relocate': 'relocate'
    };

    MissingView.prototype.template = function(item) {
      return $("#missingViewTemplate").tmpl();
    };

    function MissingView() {
      MissingView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    MissingView.prototype.active = function() {
      return this.render();
    };

    MissingView.prototype.render = function(item) {
      return this.html(this.template());
    };

    MissingView.prototype.relocate = function(e) {
      e.preventDefault();
      return this.navigate('/overview', '');
    };

    return MissingView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MissingView;
  }

}).call(this);
 },"controllers/modal_2_button_view": function(exports, require, module) { (function() {
  var $, Modal2ButtonView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Modal2ButtonView = (function(superClass) {
    extend(Modal2ButtonView, superClass);

    Modal2ButtonView.prototype.elements = {
      '.modal-header': 'header',
      '.modal-body': 'body',
      '.modal-footer': 'footer'
    };

    Modal2ButtonView.prototype.events = {
      'click .btnAlt': 'close',
      'click .btnOk': 'yes'
    };

    Modal2ButtonView.prototype.template = function(item) {
      return $('#modal2ButtonTemplate').tmpl(item);
    };

    function Modal2ButtonView() {
      Modal2ButtonView.__super__.constructor.apply(this, arguments);
      this.el.modal({
        show: false
      });
      this.defaults = {
        header: 'Default Header Text',
        body: 'Default Body Text',
        footer: 'Default Footer Text'
      };
    }

    Modal2ButtonView.prototype.render = function() {
      this.html(this.template(this.options));
      return this.el;
    };

    Modal2ButtonView.prototype.show = function(options) {
      var el;
      this.options = $.extend(this.defaults, options);
      return el = this.render().modal('show');
    };

    Modal2ButtonView.prototype.yes = function(e) {
      return this.el.modal('hide');
    };

    Modal2ButtonView.prototype.close = function(e) {
      return this.el.modal('hide');
    };

    return Modal2ButtonView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Modal2ButtonView;
  }

}).call(this);
 },"controllers/modal_action_view": function(exports, require, module) { (function() {
  var $, ModalActionView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  ModalActionView = (function(superClass) {
    extend(ModalActionView, superClass);

    ModalActionView.prototype.elements = {
      '.modal-header': 'header',
      '.modal-body': 'body',
      '.modal-footer': 'footer'
    };

    ModalActionView.prototype.events = {
      'click .btnAlt': 'close',
      'click .btnOk': 'yes'
    };

    ModalActionView.prototype.template = function(item) {
      return $('#modalActionTemplate').tmpl(item);
    };

    function ModalActionView() {
      ModalActionView.__super__.constructor.apply(this, arguments);
      this.el = $('#modal-action')({
        show: false
      });
      this.defaults = {
        header: 'Default Header Text',
        body: 'Default Body Text',
        footer: 'Default Footer Text'
      };
      $('.nav-tabs').button();
    }

    ModalActionView.prototype.render = function() {
      this.html(this.template(this.options));
      return this.el;
    };

    ModalActionView.prototype.show = function(options) {
      var el;
      this.options = $.extend(this.defaults, options);
      return el = this.render().modal('show');
    };

    ModalActionView.prototype.yes = function(e) {};

    ModalActionView.prototype.close = function(e) {};

    return ModalActionView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ModalActionView;
  }

}).call(this);
 },"controllers/modal_simple_view": function(exports, require, module) { (function() {
  var $, ModalSimpleView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  ModalSimpleView = (function(superClass) {
    extend(ModalSimpleView, superClass);

    ModalSimpleView.prototype.elements = {
      '.modal-header': 'header',
      '.modal-body': 'body',
      '.modal-footer': 'footer'
    };

    ModalSimpleView.prototype.events = {
      'click .opt-ShowAllProducts': 'allProducts',
      'click .opt-AddPhotos': 'addPhotos',
      'click .opt-CreateProduct': 'createProduct',
      'click .close': 'close',
      'hidden.bs.modal': 'hiddenmodal',
      'show.bs.modal': 'showmodal',
      'shown.bs.modal': 'shownmodal',
      'keydown': 'keydown'
    };

    ModalSimpleView.prototype.template = function(item) {
      return $('#modalSimpleTemplate').tmpl(item);
    };

    function ModalSimpleView() {
      var modalOptions, renderOptions;
      ModalSimpleView.__super__.constructor.apply(this, arguments);
      this.el = $('#modal-simple');
      modalOptions = {
        keyboard: true,
        show: false
      };
      renderOptions = {
        css: 'default',
        small: true,
        header: 'Default Header',
        body: 'Default Body Text',
        footer: {
          footerButtonText: 'schliessen'
        }
      };
      this.renderOptions = this.renderOptions ? $.extend(renderOptions, this.renderOptions) : renderOptions;
      if (this.modalOptions) {
        $.extend(modalOptions, this.modalOptions);
      }
      this.el.modal(modalOptions);
    }

    ModalSimpleView.prototype.render = function() {
      this.html(this.template(this.renderOptions));
      return this.el;
    };

    ModalSimpleView.prototype.show = function() {
      return this.render().modal('show');
    };

    ModalSimpleView.prototype.close = function(e) {
      return this.el.modal('hide');
    };

    ModalSimpleView.prototype.allProducts = function() {
      return this.navigate('/category', '');
    };

    ModalSimpleView.prototype.addPhotos = function(e) {
      return Spine.trigger('photos:add');
    };

    ModalSimpleView.prototype.createProduct = function() {
      return Spine.trigger('create:product');
    };

    ModalSimpleView.prototype.hiddenmodal = function() {
      return this.log('hiddenmodal...');
    };

    ModalSimpleView.prototype.showmodal = function() {
      return this.log('showmodal...');
    };

    ModalSimpleView.prototype.shownmodal = function() {
      return this.log('shownmodal...');
    };

    ModalSimpleView.prototype.keydown = function(e) {
      var code;
      this.log('keydown');
      code = e.charCode || e.keyCode;
      this.log(code);
      switch (code) {
        case 32:
          return e.stopPropagation();
        case 9:
          return e.stopPropagation();
        case 27:
          return e.stopPropagation();
        case 13:
          this.close();
          return e.stopPropagation();
      }
    };

    return ModalSimpleView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ModalSimpleView;
  }

}).call(this);
 },"controllers/overview_header": function(exports, require, module) { (function() {
  var $, OverviewHeader, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  OverviewHeader = (function(superClass) {
    extend(OverviewHeader, superClass);

    function OverviewHeader() {
      OverviewHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    OverviewHeader.prototype.template = function() {
      return $('#overviewHeaderTemplate').tmpl();
    };

    OverviewHeader.prototype.render = function() {
      return this.html(this.template());
    };

    OverviewHeader.prototype.active = function() {
      return this.render();
    };

    return OverviewHeader;

  })(Spine.Controller);

  module.exports = OverviewHeader;

}).call(this);
 },"controllers/overview_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Description, Extender, OverviewView, Photo, Product, Recent, Settings, Spine, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Recent = require('models/recent');

  Photo = require('models/photo');

  Product = require('models/product');

  CategoriesProduct = require('models/categories_product');

  Description = require('models/product');

  Settings = require('models/settings');

  Extender = require('extensions/controller_extender');

  UriHelper = require('extensions/uri_helper');

  require('extensions/tmpl');

  OverviewView = (function(superClass) {
    extend(OverviewView, superClass);

    OverviewView.extend(UriHelper);

    OverviewView.extend(Extender);

    OverviewView.prototype.elements = {
      '#overview-carousel': 'carousel',
      '.recents .carousel-item': 'recentsItems',
      '.recents .item': 'recentsItem',
      '.summary': 'summary'
    };

    OverviewView.prototype.events = {
      'click button.close': 'close',
      'click .item': 'showPhoto',
      'keyup': 'keyup',
      'click .opt-ShowProductsTrash': 'showProductsTrash',
      'click .opt-ShowUnpublishedProducts': 'showUnpublishedProducts',
      'click .opt-ShowUnusedProducts': 'showUnusedProducts',
      'click .opt-ShowAllCategories:not(.disabled)': 'showCategories',
      'click .opt-ShowAllProducts:not(.disabled)': 'showProductMasters',
      'click .opt-ShowAllPhotos:not(.disabled)': 'showPhotoMasters'
    };

    OverviewView.prototype.template = function(photos, products) {
      return $("#overviewTemplate").tmpl({
        photos: photos,
        summary: {
          categories: Category.all(),
          photos: Photo.all(),
          products: Product.filter(true),
          published: CategoriesProduct.publishedProductsAll(true),
          unpublished: CategoriesProduct.unpublishedProducts(true),
          others: CategoriesProduct.otherProducts(true),
          trashed: Product.filter(true, {
            func: 'selectDeleted'
          })
        },
        counter: function() {
          var li;
          li = [];
          li = li.concat([li.length, li.length + 1]);
          return li;
        }
      });
    };

    OverviewView.prototype.toolsTemplate = function(items) {
      return $("#toolsTemplate").tmpl(items);
    };

    function OverviewView() {
      OverviewView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.el.data({
        current: Recent
      });
      this.max = 42;
      this.bind('render:toolbar', this.proxy(this.renderToolbar));
      this.carouselOptions = {
        keyboard: true,
        paused: true
      };
      this.carousel.data('bs.carousel');
      this.carousel.carousel(this.carouselOptions);
      Recent.bind('refresh', this.proxy(this.render));
    }

    OverviewView.prototype.active = function() {
      return this.loadRecent();
    };

    OverviewView.prototype.loadRecent = function() {
      return Recent.loadRecent(this.max, this.proxy(this.parse));
    };

    OverviewView.prototype.parse = function(json) {
      var i, item, len, recents;
      recents = [];
      for (i = 0, len = json.length; i < len; i++) {
        item = json[i];
        recents.push(item['Photo']);
      }
      return Recent.refresh(recents, {
        clear: true
      });
    };

    OverviewView.prototype.renderAux = function() {
      return this.loadRecent();
    };

    OverviewView.prototype.render = function(tests) {
      var i, items, len, photo, photos, products, test;
      items = [];
      for (i = 0, len = tests.length; i < len; i++) {
        test = tests[i];
        if (photo = Photo.find(test.id)) {
          items.push(photo);
        }
      }
      products = this.getProducts();
      this.html(this.template(items, products));
      this.callDeferred(items, this.uriSettings(70, 70), this.proxy(this.callbackRecents));
      photos = this.getProductPhotos();
      return this.callDeferred(photos, this.uriSettings(300, 300), this.proxy(this.callbackPreview));
    };

    OverviewView.prototype.showProductsTrash = function() {
      return this.navigate('/trash/products', '');
    };

    OverviewView.prototype.showUnpublishedProducts = function(e) {
      e.preventDefault();
      return Product.trigger('show:unpublished');
    };

    OverviewView.prototype.showUnusedProducts = function(e) {
      e.preventDefault();
      return Product.trigger('show:unused');
    };

    OverviewView.prototype.callbackRecents = function(json) {
      var i, id, img, jsn, len, photoEl, results, src;
      results = [];
      for (i = 0, len = json.length; i < len; i++) {
        jsn = json[i];
        for (id in jsn) {
          id;
        }
        src = jsn[id].src;
        photoEl = $('[data-id=' + id + ']', this.recentsItems);
        img = new Image;
        img.me = this;
        img.element = photoEl;
        img.src = src;
        results.push(img.onload = this.imageLoad);
      }
      return results;
    };

    OverviewView.prototype.callbackPreview = function(json, items) {
      var i, jsn, key, len, res, result, results, ret, val;
      result = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = json.length; i < len; i++) {
          jsn = json[i];
          ret = (function() {
            var results1;
            results1 = [];
            for (key in jsn) {
              val = jsn[key];
              results1.push({
                src: val.src,
                id: key
              });
            }
            return results1;
          })();
          results.push(ret[0]);
        }
        return results;
      })();
      results = [];
      for (i = 0, len = result.length; i < len; i++) {
        res = result[i];
        results.push(this.snap(res));
      }
      return results;
    };

    OverviewView.prototype.snap = function(res) {
      var img, imgEl;
      imgEl = $('[data-image-id=' + res.id + '] img', this.el);
      img = this.createImage();
      img.imgEl = imgEl;
      img.me = this;
      img.res = res;
      img.onload = this.onLoad;
      img.onerror = this.onError;
      return img.src = res.src;
    };

    OverviewView.prototype.onLoad = function() {
      this.imgEl.attr('src', this.src);
      return this.imgEl.addClass('show');
    };

    OverviewView.prototype.onError = function(e) {
      return this.me.log('image could not be loaded');
    };

    OverviewView.prototype.getProducts = function() {
      var i, item, len, ref, results;
      ref = Product.records;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        results.push({
          product: item,
          descriptions: Description.filterSortByOrder(item.id),
          photo: Product.photos(item.id).first()
        });
      }
      return results;
    };

    OverviewView.prototype.getProductPhotos = function() {
      var photos;
      photos = [];
      $('[data-image-id]', this.el).each(function(index) {
        var item;
        if (item = $(this).item()) {
          return photos.push(item);
        }
      });
      return photos;
    };

    OverviewView.prototype.imageLoad = function() {
      var css;
      this.me.log('loaded');
      css = 'url(' + this.src + ')';
      return this.element.css({
        'backgroundImage': css,
        'backgroundPosition': 'center, center'
      });
    };

    OverviewView.prototype.showPhoto = function(e) {
      var index;
      return;
      return index = this.recentsItem.index($(e.currentTarget));
    };

    OverviewView.prototype.error = function(xhr, statusText, error) {
      this.log(xhr);
      return this.record.trigger('ajaxError', xhr, statusText, error);
    };

    OverviewView.prototype.showCategories = function() {
      var cid, ref;
      return this.navigate('/category', cid = (cid = (ref = Category.record) != null ? ref.id : void 0) ? 'cid/' + cid : null);
    };

    OverviewView.prototype.showProductMasters = function() {
      return this.navigate('/category', '');
    };

    OverviewView.prototype.showPhotoMasters = function() {
      return this.navigate('/category', '/');
    };

    OverviewView.prototype.close = function(e) {
      var first, previousHash, ref;
      previousHash = Model.Settings.loadSettings().previousHash;
      if (previousHash !== location.hash) {
        console.log(previousHash);
        console.log(location.hash);
        this.navigate(previousHash || ((first = (ref = Category.first()) != null ? ref.id : void 0) ? '/category/' + first : '#/categories'));
      }
      e.preventDefault();
      return e.stopPropagation();
    };

    OverviewView.prototype.keyup = function(e) {
      var code, paused;
      code = e.charCode || e.keyCode;
      this.log('keyup', code);
      this.carousel.data('bs.carousel') || this.carousel.carousel(this.carouselOptions);
      switch (code) {
        case 27:
          return this.close(e);
        case 32:
          paused = this.carousel.data('bs.carousel').paused;
          if (paused) {
            this.carousel.carousel('next');
            return this.carousel.carousel('cycle');
          } else {
            return this.carousel.carousel('pause');
          }
          break;
        case 39:
          return this.carousel.carousel('next');
        case 37:
          return this.carousel.carousel('prev');
      }
    };

    return OverviewView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = OverviewView;
  }

}).call(this);
 },"controllers/photo_edit_view": function(exports, require, module) { (function() {
  var $, Extender, KeyEnhancer, Photo, PhotoEditView, ProductsPhoto, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Photo = require('models/photo');

  KeyEnhancer = require('extensions/key_enhancer');

  Extender = require('extensions/controller_extender');

  ProductsPhoto = require('models/products_photo');

  PhotoEditView = (function(superClass) {
    extend(PhotoEditView, superClass);

    PhotoEditView.extend(Extender);

    PhotoEditView.prototype.elements = {
      '.content': 'content'
    };

    PhotoEditView.prototype.events = {
      'click': 'click',
      'keyup': 'saveOnKeyup'
    };

    PhotoEditView.prototype.template = function(item) {
      return $('#editPhotoTemplate').tmpl(item);
    };

    function PhotoEditView() {
      this.saveOnKeyup = bind(this.saveOnKeyup, this);
      PhotoEditView.__super__.constructor.apply(this, arguments);
      this.current = false;
      this.bind('active', this.proxy(this.active));
      Photo.bind('current', this.proxy(this.change));
    }

    PhotoEditView.prototype.change = function(item) {
      this.current = item;
      return this.render();
    };

    PhotoEditView.prototype.render = function() {
      var info;
      if (this.current) {
        this.content.html(this.template(this.current));
      } else {
        if (!(Product.selectionList().length && !Product.count())) {
          info = '<label class="invite"><span class="enlightened">Kein Foto ausgewhlt</span></label>';
        }
        this.content.html($("#noSelectionTemplate").tmpl({
          type: info || ''
        }));
      }
      return this.el;
    };

    PhotoEditView.prototype.save = function(el) {
      var atts;
      if (this.current) {
        atts = (typeof el.serializeForm === "function" ? el.serializeForm() : void 0) || this.el.serializeForm();
        return this.current.updateChangedAttributes(atts);
      }
    };

    PhotoEditView.prototype.saveOnKeyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      switch (code) {
        case 32:
          e.stopPropagation();
          break;
        case 9:
          e.stopPropagation();
      }
      return this.save(this.el);
    };

    PhotoEditView.prototype.click = function(e) {};

    return PhotoEditView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotoEditView;
  }

}).call(this);
 },"controllers/photo_header": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, PhotoHeader, Product, ProductsPhoto, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Product = require('models/product');

  Category = require('models/category');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  Extender = require('extensions/controller_extender');

  PhotoHeader = (function(superClass) {
    extend(PhotoHeader, superClass);

    PhotoHeader.extend(Extender);

    PhotoHeader.prototype.events = {
      'click .gal': 'backToCategories',
      'click .alb': 'backToProducts',
      'click .pho': 'backToPhotos'
    };

    PhotoHeader.prototype.template = function(item) {
      return $("#headerPhotoTemplate").tmpl(item);
    };

    function PhotoHeader() {
      PhotoHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Photo.bind('current', this.proxy(this.render));
      Category.bind('change', this.proxy(this.render));
      Product.bind('change', this.proxy(this.render));
      Photo.bind('change', this.proxy(this.render));
    }

    PhotoHeader.prototype.render = function() {
      return this.html(this.template({
        model: Product,
        category: Category.record,
        product: Product.record,
        photo: Photo.record,
        modelProduct: Product,
        modelPhoto: Photo,
        modelGas: CategoriesProduct,
        modelAps: ProductsPhoto,
        count: this.count(),
        author: User.first().name,
        zoomed: true
      }));
    };

    PhotoHeader.prototype.count = function() {
      if (Product.record) {
        return ProductsPhoto.filter(Product.record.id, {
          associationForeignKey: 'product_id'
        }).length;
      } else {
        return Photo.count();
      }
    };

    PhotoHeader.prototype.active = function() {
      return this.render();
    };

    PhotoHeader.prototype.backToCategories = function(e) {
      this.navigate('/category', '');
      return e.preventDefault();
    };

    PhotoHeader.prototype.backToProducts = function(e) {
      var ref;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '');
      return e.preventDefault();
    };

    PhotoHeader.prototype.backToPhotos = function(e) {
      var ref, ref1;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? ref1.selectionList().first() : void 0) || '');
      return e.preventDefault();
    };

    PhotoHeader.prototype.goUp = function(e) {
      var ref;
      this.navigate('/category', Category.record.id || '', ((ref = Category.record) != null ? ref.selectionList().first() : void 0) || '');
      return e.preventDefault();
    };

    PhotoHeader.prototype.drop = function(e) {
      e.stopPropagation();
      return e.preventDefault();
    };

    return PhotoHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotoHeader;
  }

}).call(this);
 },"controllers/photo_list": function(exports, require, module) { (function() {
  var $, Extender, PhotoList, Product, ProductsPhoto, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Product = require('models/product');

  Extender = require('extensions/controller_extender');

  ProductsPhoto = require('models/products_photo');

  require('extensions/tmpl');

  PhotoList = (function(superClass) {
    extend(PhotoList, superClass);

    PhotoList.extend(Extender);

    PhotoList.prototype.events = {
      'click .rotate-cw': 'rotateCW',
      'click .rotate-ccw': 'rotateCCW',
      'click .zoom': 'zoom',
      'click .rotate': 'rotate'
    };

    function PhotoList() {
      PhotoList.__super__.constructor.apply(this, arguments);
      ProductsPhoto.bind('beforeDestroy', this.proxy(this.back));
    }

    PhotoList.prototype.rotateCW = function(e) {
      var item;
      item = $(e.currentTarget).item();
      Spine.trigger('rotate', item, -90);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotoList.prototype.rotateCCW = function(e) {
      var item;
      item = $(e.currentTarget).item();
      Spine.trigger('rotate', item, 90);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotoList.prototype.back = function() {
      var iid, ref, ref1, ref2;
      return this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', iid = (iid = (ref2 = Product.record) != null ? typeof ref2.selectionList === "function" ? ref2.selectionList().first() : void 0 : void 0) ? 'iid/' + iid : null);
    };

    PhotoList.prototype.zoom = function(e) {};

    PhotoList.prototype.rotate = function(e) {
      return this.rotate(e);
    };

    return PhotoList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotoList;
  }

}).call(this);
 },"controllers/photo_view": function(exports, require, module) { (function() {
  var $, Drag, Extender, Info, PhotoList, PhotoView, Product, ProductsPhoto, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Product = require('models/product');

  ProductsPhoto = require('models/products_photo');

  PhotoList = require('controllers/photo_list');

  Info = require('controllers/info');

  Drag = require('extensions/drag');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  PhotoView = (function(superClass) {
    extend(PhotoView, superClass);

    PhotoView.extend(Drag);

    PhotoView.extend(Extender);

    PhotoView.prototype.elements = {
      '.hoverinfo': 'infoEl',
      '.items': 'itemsEl',
      '.item': 'item'
    };

    PhotoView.prototype.events = {
      'mousemove  .item': 'infoUp',
      'mouseleave .item': 'infoBye',
      'dragstart  .item': 'stopInfo',
      'dragstart .item': 'dragstart',
      'drop .item': 'drop',
      'click .dropdown-toggle': 'dropdownToggle',
      'click .delete': 'deletePhoto'
    };

    PhotoView.prototype.template = function(item) {
      return $('#photoTemplate').tmpl(item);
    };

    PhotoView.prototype.infoTemplate = function(item) {
      return $('#photoInfoTemplate').tmpl(item);
    };

    function PhotoView() {
      this.stopInfo = bind(this.stopInfo, this);
      this.infoBye = bind(this.infoBye, this);
      this.infoUp = bind(this.infoUp, this);
      this.callback = bind(this.callback, this);
      PhotoView.__super__.constructor.apply(this, arguments);
      this.currentId = 0;
      this.bind('active', this.proxy(this.active));
      this.list = new PhotoList({
        el: this.itemsEl,
        parent: this
      });
      this.list.listener = this.parent.photosView.list;
      this.type = 'Photo';
      this.info = new Info({
        el: this.infoEl,
        template: this.infoTemplate
      });
      this.viewport = this.itemsEl;
      Photo.one('refresh', this.proxy(this.refresh));
      Product.bind('change:collection', this.proxy(this.refresh));
      Photo.bind('change:current', this.proxy(this.changeNavigation));
    }

    PhotoView.prototype.change = function(a, b) {
      var changed;
      changed = !(this.currentId === b[0]);
      if (changed) {
        this.log(b[0]);
        this.currentId = b[0];
        return this.render(Photo.find(b));
      }
    };

    PhotoView.prototype.changeNavigation = function(rec, changed) {
      var ref, ref1;
      if (!this.isActive()) {
        return;
      }
      if (changed) {
        return this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', rec.id);
      }
    };

    PhotoView.prototype.render = function(item) {
      if (item == null) {
        item = Photo.record;
      }
      this.itemsEl.html(this.template(item));
      $('.dropdown-toggle', this.el).dropdown();
      this.uri(item);
      return this.el;
    };

    PhotoView.prototype.active = function() {
      App.showView.trigger('change:toolbarOne', ['Default']);
      App.showView.trigger('change:toolbarTwo', ['Trustami']);
      return this.render();
    };

    PhotoView.prototype.refresh = function() {
      return this.render();
    };

    PhotoView.prototype.params = function() {
      return {
        width: 600,
        height: 451,
        square: 2,
        force: false
      };
    };

    PhotoView.prototype.uri = function(item, mode) {
      if (mode == null) {
        mode = 'html';
      }
      this.log('uri');
      return Photo.uri(this.params(), (function(_this) {
        return function(xhr, record) {
          return _this.callback(xhr, item);
        };
      })(this), [item]);
    };

    PhotoView.prototype.callback = function(json, item) {
      var img, jsn, searchJSON;
      this.log('callback');
      img = new Image;
      img.onload = this.imageLoad;
      searchJSON = function(id) {
        var i, itm, len;
        for (i = 0, len = json.length; i < len; i++) {
          itm = json[i];
          if (itm[id]) {
            return itm[id];
          }
        }
      };
      jsn = searchJSON(item.id);
      if (jsn) {
        img.tmb = $('.thumbnail', this.el);
        img.container = this.itemsEl.removeClass('in');
        return img.src = jsn.src;
      }
    };

    PhotoView.prototype.imageLoad = function() {
      var container, h, img, tmb, w;
      tmb = this.tmb;
      container = this.container;
      w = this.width;
      h = this.height;
      if (h > w) {
        this.height = '100%';
        this.width = 'auto';
      }
      img = $(this);
      tmb.html(img);
      return container.addClass('show');
    };

    PhotoView.prototype.dropdownToggle = function(e) {
      var el;
      el = $(e.currentTarget);
      el.dropdown('toggle');
      e.preventDefault();
      return e.stopPropagation();
    };

    PhotoView.prototype.deletePhoto = function(e) {
      var item, ref;
      item = $(e.currentTarget).item();
      if ((item != null ? (ref = item.constructor) != null ? ref.className : void 0 : void 0) !== 'Photo') {
        return;
      }
      Spine.trigger('delete:photos', [item.id], this.proxy(this.list.back));
      this.stopInfo(e);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotoView.prototype.infoUp = function(e) {
      var el;
      this.info.up(e);
      el = $('.glyphicon-set', $(e.currentTarget)).addClass('show').removeClass('fade');
      return e.preventDefault();
    };

    PhotoView.prototype.infoBye = function(e) {
      var el;
      this.info.bye();
      el = $('.glyphicon-set', $(e.currentTarget)).addClass('fade').removeClass('show');
      return e.preventDefault();
    };

    PhotoView.prototype.stopInfo = function(e) {
      return this.info.bye();
    };

    return PhotoView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotoView;
  }

}).call(this);
 },"controllers/photos_add_list": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, Model, Photo, PhotoExtender, PhotosAddList, Product, ProductsPhoto, Spine, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  Extender = require('extensions/controller_extender');

  PhotoExtender = require('extensions/photo_extender');

  UriHelper = require('extensions/uri_helper');

  require('extensions/tmpl');

  PhotosAddList = (function(superClass) {
    extend(PhotosAddList, superClass);

    PhotosAddList.extend(UriHelper);

    PhotosAddList.extend(Extender);

    PhotosAddList.extend(PhotoExtender);

    PhotosAddList.prototype.elements = {
      '.thumbnail': 'thumbEl'
    };

    function PhotosAddList() {
      PhotosAddList.__super__.constructor.apply(this, arguments);
    }

    PhotosAddList.prototype.render = function(items) {
      var sorted;
      if (items.length) {
        sorted = items.sort(Product.sortByReverseOrder);
        this.html(this.template(items));
        this.proxy(this.size(App.showView.sOutValue));
        this.callDeferred(sorted, this.uriSettings(300, 300), this.proxy(this.callback));
      } else {
        this.html('<span class="enlightened">Es gibt nichts hinzuzufgen.</span>');
      }
      return this.el;
    };

    PhotosAddList.prototype.exposeSelection = function(selection) {
      var el, i, id, len, results;
      this.deselect();
      results = [];
      for (i = 0, len = selection.length; i < len; i++) {
        id = selection[i];
        el = $('#' + id, this.el);
        results.push(el.addClass("active hot"));
      }
      return results;
    };

    return PhotosAddList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosAddList;
  }

}).call(this);
 },"controllers/photos_add_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Drag, Extender, Info, PhotosAddList, PhotosAddView, Product, ProductsPhoto, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  Drag = require('extensions/drag');

  User = require("models/user");

  Product = require('models/product');

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Info = require('controllers/info');

  PhotosAddList = require('controllers/photos_add_list');

  User = require('models/user');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  PhotosAddView = (function(superClass) {
    extend(PhotosAddView, superClass);

    PhotosAddView.extend(Extender);

    PhotosAddView.prototype.elements = {
      '.modal-footer': 'footer',
      '.items': 'itemsEl'
    };

    PhotosAddView.prototype.events = {
      'click .item': 'click',
      'click .opt-modalAddExecute:not(.disabled)': 'add',
      'click .opt-modalSelectInv:not(.disabled)': 'selectInv',
      'click .opt-modalSelectAll:not(.disabled)': 'selectAll',
      'keyup': 'keyup'
    };

    PhotosAddView.prototype.template = function(items) {
      return $('#addTemplate').tmpl({
        title: 'Select Photos',
        type: 'photos',
        disabled: true,
        contains: !!this.items.length,
        container: Product.record
      });
    };

    PhotosAddView.prototype.subTemplate = function(items, options) {
      return $("#photosTemplate").tmpl(items, options);
    };

    PhotosAddView.prototype.footerTemplate = function(selection) {
      return $('#footerTemplate').tmpl({
        disabled: !selection.length,
        contains: !!this.items.length
      });
    };

    function PhotosAddView() {
      PhotosAddView.__super__.constructor.apply(this, arguments);
      this.el = $('#modal-view');
      this.thumbSize = 100;
      this.visible = false;
      this.modal = this.el.modal({
        show: this.visible,
        backdrop: true
      });
      this.modal.bind('show.bs.modal', this.proxy(this.modalShow));
      this.modal.bind('shown.bs.modal', this.proxy(this.modalShown));
      this.modal.bind('hide.bs.modal', this.proxy(this.modalHide));
      this.list = new PhotosAddList({
        template: this.subTemplate,
        parent: this.parent
      });
      Spine.bind('photos:add', this.proxy(this.show));
      window.test = this;
    }

    PhotosAddView.prototype.render = function(items) {
      this.html(this.template(this.items = items));
      this.selectionList = [];
      if (!this.eventsDelegated) {
        this.eventsDelegated = this.delegateEvents(this.events);
      }
      this.list.el = this.itemsEl;
      this.list.render(items);
      return this.el;
    };

    PhotosAddView.prototype.renderFooter = function(list) {
      return this.footer.html(this.footerTemplate(list));
    };

    PhotosAddView.prototype.show = function() {
      var list, product, records;
      product = Product.record;
      list = ProductsPhoto.photos(product.id).toId();
      records = Photo.filter(list, {
        func: 'idExcludeSelect'
      });
      return this.render(records, product).modal("show");
    };

    PhotosAddView.prototype.hide = function() {
      return this.el.modal('hide');
    };

    PhotosAddView.prototype.modalShow = function(e) {
      Spine.trigger('slider:change', this.thumbSize);
      return this.preservedList = Product.selectionList().slice(0);
    };

    PhotosAddView.prototype.modalShown = function(e) {
      return this.log('shown');
    };

    PhotosAddView.prototype.modalHide = function(e) {
      return Spine.trigger('slider:change', App.showView.sOutValue);
    };

    PhotosAddView.prototype.click = function(e) {
      var item;
      e.stopPropagation();
      e.preventDefault();
      item = $(e.currentTarget).item();
      return this.select(item.id, !this.isMeta(e));
    };

    PhotosAddView.prototype.select = function(items, cumul) {
      var i, item, len, list;
      if (items == null) {
        items = [];
      }
      if (!Array.isArray(items)) {
        items = [items];
      }
      if (cumul) {
        list = this.selectionList.slice(0);
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          list.addRemove(item);
        }
      } else {
        list = items.slice(0);
      }
      this.selectionList = list.slice(0);
      this.renderFooter(list);
      return this.list.exposeSelection(list);
    };

    PhotosAddView.prototype.selectAll = function(e) {
      var list;
      list = this.all();
      this.select(list);
      return e.stopPropagation();
    };

    PhotosAddView.prototype.selectInv = function(e) {
      var list;
      list = this.all();
      this.select(list, true);
      return e.stopPropagation();
    };

    PhotosAddView.prototype.all = function() {
      var items, list, root;
      root = this.itemsEl;
      items = root.children('.item');
      list = [];
      items.each(function(index, el) {
        var item;
        item = $(this).item();
        return list.unshift(item.id);
      });
      return list;
    };

    PhotosAddView.prototype.add = function() {
      var photos;
      photos = Photo.toRecords(this.selectionList);
      return Photo.trigger('create:join', photos, Product.record, this.proxy(this.hide));
    };

    PhotosAddView.prototype.keyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      this.log('PhotosAddView:keyupCode: ' + code);
      switch (code) {
        case 65:
          if (e.metaKey || e.ctrlKey) {
            this.selectAll(e);
            e.stopPropagation();
            return e.preventDefault();
          }
          break;
        case 73:
          if (e.metaKey || e.ctrlKey) {
            this.selectInv(e);
            e.preventDefault();
            return e.stopPropagation();
          }
      }
    };

    return PhotosAddView;

  })(Spine.Controller);

  module.exports = PhotosAddView;

}).call(this);
 },"controllers/photos_header": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, Photo, PhotosHeader, Product, ProductsPhoto, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  User = require('models/user');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Extender = require('extensions/controller_extender');

  PhotosHeader = (function(superClass) {
    extend(PhotosHeader, superClass);

    PhotosHeader.extend(Extender);

    PhotosHeader.prototype.events = {
      'click .gal': 'backToCategories',
      'click .alb': 'backToProducts'
    };

    PhotosHeader.prototype.template = function(item) {
      return $("#headerPhotosTemplate").tmpl(item);
    };

    function PhotosHeader() {
      PhotosHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Photo.bind('current', this.proxy(this.render));
    }

    PhotosHeader.prototype.backToCategories = function(e) {
      this.log('backToCategories');
      this.navigate('/category', '');
      return e.preventDefault();
    };

    PhotosHeader.prototype.backToProducts = function(e) {
      var ref;
      this.log('backToProducts');
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '');
      return e.preventDefault();
    };

    PhotosHeader.prototype.goUp = function(e) {
      this.navigate('/category', Category.record.id || '');
      e.preventDefault();
      return e.stopPropagation();
    };

    PhotosHeader.prototype.change = function() {
      return this.render();
    };

    PhotosHeader.prototype.render = function() {
      return this.html(this.template({
        model: Product,
        category: Category.record,
        product: Product.record,
        photo: Photo.record,
        modelProduct: Product,
        modelPhoto: Photo,
        modelGas: CategoriesProduct,
        modelAps: ProductsPhoto,
        count: this.count(),
        author: User.first().name
      }));
    };

    PhotosHeader.prototype.count = function() {
      if (Product.record) {
        return ProductsPhoto.filter(Product.record.id, {
          associationForeignKey: 'product_id'
        }).length;
      } else {
        return Photo.filter();
      }
    };

    PhotosHeader.prototype.active = function() {
      return this.render();
    };

    return PhotosHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosHeader;
  }

}).call(this);
 },"controllers/photos_list": function(exports, require, module) { (function() {
  var $, Drag, Extender, Photo, PhotoExtender, PhotosList, Product, ProductsPhoto, Spine, ToolbarView, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Photo = require('models/photo');

  Product = require('models/product');

  ProductsPhoto = require('models/products_photo');

  ToolbarView = require("controllers/toolbar_view");

  Extender = require('extensions/controller_extender');

  Drag = require('extensions/drag');

  UriHelper = require('extensions/uri_helper');

  PhotoExtender = require('extensions/photo_extender');

  require('extensions/tmpl');

  PhotosList = (function(superClass) {
    extend(PhotosList, superClass);

    PhotosList.extend(Drag);

    PhotosList.extend(Extender);

    PhotosList.extend(PhotoExtender);

    PhotosList.extend(UriHelper);

    PhotosList.prototype.elements = {
      '.thumbnail': 'thumbEl',
      '.toolbar': 'toolbarEl'
    };

    PhotosList.prototype.events = {
      'click .opt-AddPhotos': 'addPhotos',
      'click .dropdown-toggle': 'dropdownToggle',
      'click .delete': 'deletePhoto',
      'click .zoom': 'zoom',
      'click .rotate-cw': 'rotateCW',
      'click .rotate-ccw': 'rotateCCW',
      'click .original': 'original'
    };

    PhotosList.prototype.selectFirst = true;

    function PhotosList() {
      PhotosList.__super__.constructor.apply(this, arguments);
      this.toolbar = new ToolbarView({
        el: this.toolbarEl
      });
      this.add = this.html;
      Spine.bind('slider:start', this.proxy(this.sliderStart));
      Spine.bind('slider:change', this.proxy(this.size));
      Spine.bind('rotate', this.proxy(this.rotate));
      Product.bind('ajaxError', Product.errorHandler);
      Product.bind('change:selection', this.proxy(this.exposeSelection));
      ProductsPhoto.bind('change', this.proxy(this.changeRelated));
    }

    PhotosList.prototype.changeRelated = function(item, mode) {
      var el;
      if (!Product.record) {
        return;
      }
      if (Product.record.id !== item['product_id']) {
        return;
      }
      if (!(item = Photo.find(item['photo_id']))) {
        return;
      }
      this.log('changeRelated');
      switch (mode) {
        case 'create':
          this.wipe();
          this.el.prepend(this.template(item));
          this.refreshElements();
          this.size(App.showView.sOutValue);
          this.el.sortable('destroy').sortable('photo');
          $('.dropdown-toggle', this.el).dropdown();
          this.callDeferred([item], this.uriSettings(300, 300), this.proxy(this.callback));
          break;
        case 'destroy':
          el = this.findModelElement(item);
          el.detach();
          break;
        case 'update':
          this.updateTemplate(item);
          this.el.sortable('destroy').sortable('photo');
      }
      this.refreshElements();
      return this.el;
    };

    PhotosList.prototype.render = function(items, mode) {
      var ref, ref1, ref2, s, sorted;
      if (items == null) {
        items = [];
      }
      if (mode == null) {
        mode = 'html';
      }
      this.log('PhotosList::render ' + mode);
      if (!items.length) {
        s = (s = ((ref = this.model.record) != null ? ref.screenname : void 0) || (s = ((ref1 = this.model.record) != null ? ref1.name : void 0) || (s = (ref2 = this.model.record) != null ? ref2.title : void 0))) != null ? 'in ' + s + ' nichts los - kein Moos' : 'nichts los hier. Brutal...';
        this.renderEmpty(s);
        return this.el;
      }
      sorted = items.sort(Product.sortByReverseOrder);
      this[mode](this.template(sorted));
      this.proxy(this.size(App.showView.sOutValue));
      this.exposeSelection();
      $('.dropdown-toggle', this.el).dropdown();
      this.callDeferred(sorted, this.uriSettings(300, 300), this.proxy(this.callback));
      return this.el;
    };

    PhotosList.prototype.renderAll = function() {
      var items, sorted;
      items = Photo.all();
      if (items.length) {
        this.activateRecord();
        this.html(this.template(sorted));
        this.el.sortable('destroy').sortable('photo');
        this.size(App.showView.sOutValue);
        sorted = Product.sortByReverseOrder(items);
      }
      return this.el;
    };

    PhotosList.prototype.photos = function(mode) {
      var product;
      if (mode === 'add' || !Product.record) {
        return Photo.all();
      } else if (product = Product.find(mode)) {
        return product.photos();
      } else if (Product.record) {
        return Product.record.photos();
      }
    };

    PhotosList.prototype.dropdownToggle = function(e) {
      var el;
      el = $(e.currentTarget);
      el.dropdown();
      e.preventDefault();
      return e.stopPropagation();
    };

    PhotosList.prototype.original = function(e) {
      var id;
      id = $(e.currentTarget).item().id;
      Product.selection[0].global.update([id]);
      this.navigate('/category', '/');
      e.preventDefault();
      return e.stopPropagation();
    };

    PhotosList.prototype.deletePhoto = function(e) {
      var item, ref;
      this.log('deletePhoto');
      item = $(e.currentTarget).item();
      if ((item != null ? (ref = item.constructor) != null ? ref.className : void 0 : void 0) !== 'Photo') {
        return;
      }
      Spine.trigger('delete:photos', [item.id]);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotosList.prototype.zoom = function(e) {
      var item, ref, ref1;
      item = e.type === 'click' ? $(e.currentTarget).item() : this.models.record;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', item.id || null);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotosList.prototype.back = function(e) {
      var pid, ref, ref1;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', pid = (pid = (ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) ? 'pid/' + pid : null);
      e.preventDefault();
      return e.stopPropagation();
    };

    PhotosList.prototype.initSelectable = function() {
      var options;
      options = {
        helper: 'clone'
      };
      return this.el.selectable();
    };

    PhotosList.prototype.addPhotos = function(e) {
      e.stopPropagation();
      e.preventDefault();
      return Spine.trigger('photos:add');
    };

    PhotosList.prototype.sliderStart = function() {
      return this.refreshElements();
    };

    PhotosList.prototype.rotateCW = function(e) {
      var item;
      item = $(e.currentTarget).item();
      this.log(item);
      Spine.trigger('rotate', item, -90);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotosList.prototype.rotateCCW = function(e) {
      var item;
      item = $(e.currentTarget).item();
      this.log(item);
      Spine.trigger('rotate', item, 90);
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotosList.prototype.rotate = function(item, val) {
      var callback, i, ids, items, len, options;
      if (val == null) {
        val = 90;
      }
      if (item) {
        items = [item];
      } else {
        ids = Product.selectionList().slice(0);
        items = ids.length ? Photo.toRecords(ids.add(item != null ? item.id : void 0)) : void 0;
      }
      options = {
        val: val
      };
      callback = (function(_this) {
        return function(items) {
          var alb, albs, photo, products, res;
          products = [];
          res = (function() {
            var i, j, len, len1, results;
            results = [];
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              photo = Photo.find(item['Photo']['id']);
              photo.clearCache();
              albs = photo.products();
              for (j = 0, len1 = albs.length; j < len1; j++) {
                alb = albs[j];
                products.add(alb.id);
              }
              results.push(photo);
            }
            return results;
          })();
          _this.callDeferred(res, _this.uriSettings(300, 300), _this.proxy(_this.callback));
          products = Product.toRecords(products);
          Product.trigger('change:collection', products);
          return Photo.trigger('develop', items);
        };
      })(this);
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        $('#' + item.id + '>.thumbnail', this.el).removeClass('in');
      }
      Photo.develop('rotate', options, callback, items);
      return false;
    };

    return PhotosList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosList;
  }

}).call(this);
 },"controllers/photos_trash_header": function(exports, require, module) { (function() {
  var $, Category, Extender, PhotosTrashHeader, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Extender = require('extensions/controller_extender');

  PhotosTrashHeader = (function(superClass) {
    extend(PhotosTrashHeader, superClass);

    PhotosTrashHeader.extend(Extender);

    PhotosTrashHeader.prototype.template = function(items) {
      return $("#headerPhotosTrashTemplate").tmpl(items);
    };

    function PhotosTrashHeader() {
      PhotosTrashHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    PhotosTrashHeader.prototype.render = function(item) {
      return this.html(this.template(item));
    };

    PhotosTrashHeader.prototype.active = function() {
      return this.render();
    };

    return PhotosTrashHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosTrashHeader;
  }

}).call(this);
 },"controllers/photos_trash_view": function(exports, require, module) { (function() {
  var $, Controller, Drag, Extender, PhotoExtender, PhotosTrash, PhotosTrashView, Spine, UriHelper, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Drag = require('extensions/drag');

  User = require("models/user");

  PhotosTrash = require("models/photos_trash");

  Extender = require('extensions/controller_extender');

  PhotoExtender = require('extensions/photo_extender');

  UriHelper = require('extensions/uri_helper');

  PhotosTrashView = (function(superClass) {
    extend(PhotosTrashView, superClass);

    PhotosTrashView.extend(Drag);

    PhotosTrashView.extend(Extender);

    PhotosTrashView.extend(PhotoExtender);

    PhotosTrashView.extend(UriHelper);

    PhotosTrashView.prototype.elements = {
      '.items': 'items'
    };

    PhotosTrashView.prototype.events = {
      'click': 'clearSelection',
      'click .item': 'click',
      'click .dropdown-toggle': 'dropdownToggle',
      'click .opt-destroy': 'destroyPhoto',
      'click .opt-recover': 'recoverPhoto',
      'mousemove .item': 'in',
      'mouseleave .item': 'out',
      'dragstart ': 'dragstart',
      'dragend': 'dragend',
      'drop': 'drop',
      'dragover   ': 'dragover',
      'dragenter  ': 'dragenter',
      'keyup': 'keyup'
    };

    PhotosTrashView.prototype.template = function(items) {
      return $("#photosTrashTemplate").tmpl(items);
    };

    function PhotosTrashView() {
      this.out = bind(this.out, this);
      this["in"] = bind(this["in"], this);
      PhotosTrashView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Photo.bind('destroy:trash', this.proxy(this.destroy));
      PhotosTrash.bind('change:selection', this.proxy(this.exposeSelection));
      Photo.bind('beforeDestroy', this.proxy(this.beforeDestroy));
      Photo.bind('destroy:photos', this.proxy(this.destroyPhotos));
      Photo.bind('refresh', this.proxy(this.initTrash));
      Photo.bind('inbound:trash', this.proxy(this.inbound));
      Photo.bind('outbound:trash', this.proxy(this.outbound));
      Photo.bind('empty:trash', this.proxy(this.emptyTrash));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
    }

    PhotosTrashView.prototype.initTrash = function(items) {
      var i, item, len, results, trash;
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        if (!item.deleted) {
          continue;
        }
        trash = new PhotosTrash({
          id: item.id
        });
        trash.save();
        results.push(item.one('update destroy', this.proxy(this.watch)));
      }
      return results;
    };

    PhotosTrashView.prototype.refreshOne = function() {
      return Photo.one('refresh', this.proxy(this.refresh));
    };

    PhotosTrashView.prototype.refresh = function() {
      var items;
      items = Photo.filter(true, {
        func: 'selectDeleted'
      });
      return this.render(items);
    };

    PhotosTrashView.prototype.render = function(items) {
      this.items.html(this.template(items));
      this.proxy(this.size(App.showView.sOutValue));
      $('.dropdown-toggle', this.el).dropdown();
      this.callDeferred(items, this.uriSettings(300, 300), this.proxy(this.callback));
      return this.el;
    };

    PhotosTrashView.prototype.active = function(items) {
      this.render(items);
      App.showView.trigger('change:toolbarOne', ['Default', 'Help']);
      return App.showView.trigger('change:toolbarTwo', ['Speichern']);
    };

    PhotosTrashView.prototype.inbound = function(photos) {
      var i, len, photo;
      if (!Array.isArray(photos)) {
        photos = [photos];
      }
      for (i = 0, len = photos.length; i < len; i++) {
        photo = photos[i];
        photo.deleted = true;
        photo.save();
        Photo.trigger('trashed', photo);
      }
      return this.initTrash(photos);
    };

    PhotosTrashView.prototype.outbound = function(item) {};

    PhotosTrashView.prototype.watch = function(item) {
      var trash;
      if (!item.deleted || item.destroyed) {
        trash = PhotosTrash.find(item.id);
        console.log(trash);
        trash.destroy();
        Photo.trigger('outbound:trash');
        return this.remove(item);
      }
    };

    PhotosTrashView.prototype.dropdownToggle = function(e) {
      var el;
      el = $(e.currentTarget);
      el.dropdown();
      e.stopPropagation();
      return e.preventDefault();
    };

    PhotosTrashView.prototype.recoverPhoto = function(e) {
      var item;
      e.stopPropagation();
      item = $(e.currentTarget).item();
      item.deleted = false;
      return item.save();
    };

    PhotosTrashView.prototype.destroyPhoto = function(e) {
      var id, item;
      e.stopPropagation();
      item = $(e.currentTarget).item();
      if (id = item != null ? item.id : void 0) {
        return this.destroyPhotos(e, id);
      }
    };

    PhotosTrashView.prototype.destroyPhotos = function(e, ids, callback) {
      var i, len, photo, photos, res;
      if (ids == null) {
        ids = this.model.selectionList();
      }
      this.log('destroyPhotos');
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      photos = Photo.toRecords(ids);
      for (i = 0, len = photos.length; i < len; i++) {
        photo = photos[i];
        if (photo.deleted) {
          if (res || (res = App.confirm('DESTROY', this.humanize(photos)))) {
            Photo.trigger('destroy:trash', photo);
            continue;
          } else {
            break;
          }
        }
      }
      if (typeof callback === 'function') {
        return callback.call();
      }
    };

    PhotosTrashView.prototype.beforeDestroy = function(photo) {
      var i, len, photos, product, products, results;
      this.log('beforeDestroy');
      return;
      photo.unbind('released:fromTrash');
      photo.removeSelectionID();
      products = ProductsPhoto.products(photo.id);
      results = [];
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        product.removeFromSelection(photo.id);
        photo.removeSelectionID();
        photos = ProductsPhoto.photos(product.id).toId();
        results.push(Photo.trigger('destroy:join', photos, product));
      }
      return results;
    };

    PhotosTrashView.prototype.destroyPhotos_ = function(ids, callback) {
      var el, i, len, photo, photos, product;
      this.log('destroyPhoto');
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      this.stopInfo();
      ids = ids || Product.selectionList().slice(0);
      photos = Photo.toRecords(ids);
      for (i = 0, len = photos.length; i < len; i++) {
        photo = photos[i];
        el = this.list.findModelElement(photo);
        el.removeClass('in');
        if (product = Product.record) {
          this.destroyJoin({
            photos: [photo],
            product: product
          });
        } else {
          photo.destroy();
        }
      }
      if (typeof callback === 'function') {
        return callback.call();
      }
    };

    PhotosTrashView.prototype.destroy = function(items) {
      var i, item, len, results;
      this.log('destroy');
      if (!Array.isArray(items)) {
        items = [items];
      }
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        results.push(item.destroy());
      }
      return results;
    };

    PhotosTrashView.prototype.emptyTrash = function(items) {
      var i, item, len, results;
      if (App.confirm('EMPTYTRASH')) {
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          results.push(item.destroy());
        }
        return results;
      }
    };

    PhotosTrashView.prototype.click = function(e) {
      var item;
      item = $(e.currentTarget).item();
      this.select(e, item.id);
      return e.stopPropagation();
    };

    PhotosTrashView.prototype.select = function(e, ids) {
      var list;
      if (ids == null) {
        ids = [];
      }
      list = this.model.selectionList().slice(0);
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      if (this.isMeta(e)) {
        list.addRemove(ids);
      } else {
        list = ids.slice(0);
      }
      this.model.updateSelection(list);
      return e.stopPropagation();
    };

    PhotosTrashView.prototype.back = function(e) {
      var iid, ref, ref1, ref2;
      return this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', iid = (iid = (ref2 = Product.record) != null ? typeof ref2.selectionList === "function" ? ref2.selectionList().first() : void 0 : void 0) ? 'iid/' + iid : null);
    };

    PhotosTrashView.prototype["in"] = function(e) {
      var el;
      el = $(e.currentTarget);
      return $('.glyphicon-set.fade', el).addClass('show').removeClass('fade');
    };

    PhotosTrashView.prototype.out = function(e) {
      var el, set;
      el = $(e.currentTarget);
      return set = $('.glyphicon-set.fade', el).addClass('fade').removeClass('show');
    };

    PhotosTrashView.prototype.keyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      switch (code) {
        case 8:
          this.destroyPhotos(e);
          e.preventDefault();
          return e.stopPropagation();
      }
    };

    return PhotosTrashView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosTrashView;
  }

}).call(this);
 },"controllers/photos_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Controller, Drag, Extender, Info, Photo, PhotosList, PhotosView, Product, ProductsPhoto, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  Info = require('controllers/info');

  PhotosList = require('controllers/photos_list');

  Drag = require('extensions/drag');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  PhotosView = (function(superClass) {
    extend(PhotosView, superClass);

    PhotosView.extend(Drag);

    PhotosView.extend(Extender);

    PhotosView.prototype.elements = {
      '.hoverinfo': 'infoEl',
      '.items': 'itemsEl'
    };

    PhotosView.prototype.events = {
      'click': 'clearSelection',
      'click .item': 'click',
      'sortupdate .items': 'sortupdate',
      'dragstart .item': 'dragstart',
      'dragstart': 'stopInfo',
      'dragover .item': 'dragover',
      'drop': 'drop',
      'mousemove .item': 'infoUp',
      'mouseleave  .item': 'infoBye'
    };

    PhotosView.prototype.template = function(items) {
      return $('#photosTemplate').tmpl(items);
    };

    PhotosView.prototype.preloaderTemplate = function() {
      return $('#preloaderTemplate').tmpl();
    };

    PhotosView.prototype.headerTemplate = function(items) {
      return $("#headerPhotosTemplate").tmpl(items);
    };

    PhotosView.prototype.infoTemplate = function(item) {
      return $('#photoInfoTemplate').tmpl(item);
    };

    function PhotosView() {
      this.stopInfo = bind(this.stopInfo, this);
      PhotosView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.current = this.el.data('modelName').record;
      this.info = new Info({
        el: this.infoEl,
        template: this.infoTemplate
      });
      this.list = new PhotosList({
        el: this.itemsEl,
        template: this.template,
        parent: this
      });
      this.header.template = this.headerTemplate;
      this.viewport = this.list.el;
      this.bind('drag:drop', this.proxy(this.dragDrop));
      ProductsPhoto.bind('destroy', this.proxy(this.destroyProductsPhoto));
      ProductsPhoto.bind('beforeDestroy', this.proxy(this.beforeDestroyProductsPhoto));
      CategoriesProduct.bind('destroy', this.proxy(this.backToProductView));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
      Photo.bind('create', this.proxy(this.add));
      Photo.bind('create:join', this.proxy(this.createJoin));
      Photo.bind('destroy:join', this.proxy(this.destroyJoin));
      Photo.bind('ajaxError', Photo.errorHandler);
      Photo.bind('trashed', this.proxy(this.remove));
      Spine.bind('delete:photos', this.proxy(this.deletePhotos));
      Spine.bind('loading:done', this.proxy(this.refresh));
    }

    PhotosView.prototype.refreshOne = function() {
      return Product.one('refresh', this.proxy(this.refresh));
    };

    PhotosView.prototype.refresh = function() {
      return this.render(Photo.renderBuffer(true));
    };

    PhotosView.prototype.render = function(items, mode) {
      if (mode == null) {
        mode = 'html';
      }
      this.list.render(items);
      if (Product.record) {
        this.list.sortable('photo');
      }
      return this.el;
    };

    PhotosView.prototype.active = function(items, options) {
      var b1, b2;
      b1 = this.eql.call(this.parent);
      b2 = this.eql_();
      if (b1 && b2) {
        return;
      }
      App.showView.trigger('change:toolbarOne', ['Default', 'Slider', App.showView.initSlider]);
      App.showView.trigger('change:toolbarTwo', ['Trustami']);
      this.parent.scrollTo(this.models.record);
      return this.render(items);
    };

    PhotosView.prototype.update = function(items) {
      var i, item, len, results, tmplItem;
      if (!Product.record) {
        return;
      }
      this.list.children().each(function(index) {
        var ap, item, t;
        item = $(this).item();
        ap = ProductsPhoto.fromPhotoId(item.id);
        if (!ap) {
          return;
        }
        ap.order = index;
        ap.save({
          ajax: false
        });
        return t = c.update(item);
      });
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        results.push(tmplItem = this.list.update(item));
      }
      return results;
    };

    PhotosView.prototype.activateRecord = function(ids) {
      if (!ids) {
        ids = [];
      }
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      return Photo.current(ids[0]);
    };

    PhotosView.prototype.click = function(e) {
      var item;
      App.showView.trigger('change:toolbarOne');
      item = $(e.currentTarget).item();
      return this.select(e, item.id);
    };

    PhotosView.prototype.select = function(e, ids) {
      var list, ref, ref1;
      if (ids == null) {
        ids = [];
      }
      list = this.model.selectionList().slice(0);
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      if (!this.isMeta(e)) {
        list.addRemove(ids);
      } else {
        list = ids.slice(0);
      }
      if (list.length) {
        this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', Product.record.id || '', 'iid', list[0]);
      } else {
        this.navigate('/category', ((ref1 = Category.record) != null ? ref1.id : void 0) || '', Product.record.id || '');
      }
      this.model.updateSelection(list);
      return e.stopPropagation();
    };

    PhotosView.prototype.select_ = function(e, ids) {
      var isMeta, list;
      if (ids == null) {
        ids = [];
      }
      isMeta = e.metaKey || e.ctrlKey || e.shiftKey;
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      if (isMeta && e.type === 'click') {
        list = this.model.selectionList();
        list.addRemove(ids);
      } else {
        list = ids.slice(0);
      }
      this.model.updateSelection(list);
      return e.stopPropagation();
    };

    PhotosView.prototype.clearPhotoCache = function() {
      return Photo.clearCache();
    };

    PhotosView.prototype.beforeDestroyProductsPhoto = function(ap) {
      var product;
      product = Product.find(ap.product_id);
      return product.removeFromSelection(ap.photo_id);
    };

    PhotosView.prototype.destroy = function(item) {
      var el;
      el = this.list.findModelElement(item);
      el.detach();
      if (!Photo.count()) {
        return this.render();
      }
    };

    PhotosView.prototype.destroyProductsPhoto = function(ap) {
      var photos;
      photos = ProductsPhoto.photos(ap.product_id);
      if (!photos.length) {
        return this.render(null, 'html');
      }
    };

    PhotosView.prototype.deletePhoto_ = function(ids, callback) {
      return App.confirm('METHOD_NOT_SUPPORTED', {
        mode: 'alert'
      });
    };

    PhotosView.prototype.deletePhotos = function(ids, callback) {
      var i, j, len, len1, photo, photos, prod, prods, product, res1, res2, res3, res4, results;
      this.log('deletePhotos');
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      this.stopInfo();
      photos = Photo.toRecords(ids);
      results = [];
      for (i = 0, len = photos.length; i < len; i++) {
        photo = photos[i];
        if (photo.deleted) {
          Photo.trigger('destroy:photos', ids);
          break;
        }
        prods = ProductsPhoto.products(photo.id);
        if (!(product = Product.record)) {
          if (prods.length) {
            if (res1 || (res1 = App.confirm('REMOVE_AND_DELETE', this.humanize(photos)))) {
              for (j = 0, len1 = prods.length; j < len1; j++) {
                prod = prods[j];
                this.destroyJoin({
                  photos: photo,
                  product: prod
                });
              }
              Photo.trigger('inbound:trash', photo);
              continue;
            } else {
              break;
            }
          } else {
            if (res2 || (res2 = App.confirm('DELETE', this.humanize(photos)))) {
              Photo.trigger('inbound:trash', photo);
              continue;
            } else {
              break;
            }
          }
        } else {
          if (prods.length === 1) {
            if (res3 || (res3 = App.confirm('DELETE', this.humanize(photos)))) {
              this.destroyJoin({
                photos: photo,
                product: product
              });
              Photo.trigger('inbound:trash', photo);
              continue;
            } else {
              break;
            }
          } else {
            if (res4 || (res4 = App.confirm('REMOVE', this.humanize(photos)))) {
              this.destroyJoin({
                photos: photo,
                product: product
              });
              continue;
            } else {
              break;
            }
          }
        }
      }
      return results;
    };

    PhotosView.prototype.save = function(item) {};

    PhotosView.prototype.addProductsPhoto = function(ap) {
      var el, photo;
      if (photo = Photo.find(ap.photo_id)) {
        el = this.list.findModelElement(photo);
      }
      if (el.length) {
        return;
      }
      return this.add(photo);
    };

    PhotosView.prototype.add = function(photos) {
      if (!Array.isArray(photos)) {
        photos = [photos];
      }
      Product.updateSelection(photos.toId());
      if (!Product.record) {
        this.list.wipe();
        this.render(photos, 'append');
        return this.list.el.sortable('destroy').sortable('photos');
      }
    };

    PhotosView.prototype.createJoin = function(photos, target, cb) {
      Photo.createJoin(photos, target, cb);
      Photo.trigger('activate', photos.last());
      return target.updateSelection(photos.toId());
    };

    PhotosView.prototype.destroyJoin = function(options, callback) {
      var photos, product;
      this.log('destroyJoin');
      product = options.product;
      photos = options.photos;
      if (!Array.isArray(photos)) {
        photos = [photos];
      }
      if (!product) {
        return;
      }
      Photo.destroyJoin(photos, product, callback);
      return product.updateSelection();
    };

    PhotosView.prototype.sortupdate = function(e) {
      var f;
      this.log('sortupdate');
      f = this.list.children().length - 1;
      this.list.children().each(function(index) {
        var ap, idx, item;
        idx = f - index;
        item = $(this).item();
        if (item && Product.record) {
          ap = ProductsPhoto.fromPhotoId(item.id);
          if (ap && parseInt(ap.order) !== idx) {
            ap.order = idx;
            ap.silentUpdate();
          }
          return Product.record.invalid = true;
        }
      });
      return Product.record.save();
    };

    PhotosView.prototype.backToProductView = function(ga) {
      var category;
      if (!this.isActive()) {
        return;
      }
      if (category = Category.find(ga.category_id)) {
        return this.navigate('/category', category.id);
      }
    };

    PhotosView.prototype.infoUp = function(e) {
      var el;
      this.info.up(e);
      return el = $('.glyphicon-set', $(e.currentTarget)).addClass('show').removeClass('fade');
    };

    PhotosView.prototype.infoBye = function(e) {
      var el;
      this.info.bye(e);
      return el = $('.glyphicon-set', $(e.currentTarget)).addClass('fade').removeClass('show');
    };

    PhotosView.prototype.stopInfo = function(e) {
      return this.info.bye(e);
    };

    PhotosView.prototype.dragComplete = function() {
      return this.list.exposeSelection();
    };

    return PhotosView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PhotosView;
  }

}).call(this);
 },"controllers/preview_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Extender, Model, PreviewView, Product, ProductsPhoto, Spine, UriHelper,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Product = require('models/product');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  UriHelper = require('extensions/uri_helper');

  Extender = require('extensions/controller_extender');

  require('spine/lib/local');

  PreviewView = (function(superClass) {
    extend(PreviewView, superClass);

    PreviewView.extend(Extender);

    PreviewView.extend(UriHelper);

    PreviewView.prototype.elements = {
      '.preview': 'preview',
      '.items': 'items',
      '.inner': 'inner',
      '.expander': 'expander',
      '.content': 'contentEl'
    };

    PreviewView.prototype.events = {
      'click a[href]': 'followLink',
      'click .expander': 'expand',
      'click .item-content': 'expand'
    };

    PreviewView.prototype.template = function(item) {
      return $('#norbuPricingTemplate').tmpl(item);
    };

    function PreviewView() {
      this.callback = bind(this.callback, this);
      PreviewView.__super__.constructor.apply(this, arguments);
      Product.bind('create update destroy', this.proxy(this.change));
      Product.bind('current', this.proxy(this.change));
      Photo.bind('develop', this.proxy(this.developed));
      Description.bind('change', this.proxy(this.render));
      ProductsPhoto.bind('update destroy', this.proxy(this.changedRelatedPhoto));
      Category.bind('change:selection', this.proxy(this.dimmPreview));
      CategoriesProduct.bind('update', this.proxy(this.changeRelatedProduct));
      CategoriesProduct.bind('destroy', this.proxy(this.change));
      this.createDummy();
      this.render();
    }

    PreviewView.prototype.newAttributes = function() {
      return {
        title: 'Semper Fi',
        id: '12345',
        price: '1.000.000,00',
        subtitle: 'Keep smiling & semper fi'
      };
    };

    PreviewView.prototype.createDummy = function() {
      this.dummy = new Product(this.newAttributes());
      return this.dummy.save({
        ajax: false
      });
    };

    PreviewView.prototype.developed = function(photos) {
      var photo;
      photo = photos[0].Photo;
      return this.callDeferred(photo, this.uriSettings(300, 300), this.callback);
    };

    PreviewView.prototype.change = function(item) {
      if ((item != null ? item.destroyed : void 0) || !item) {
        this.current = this.dummy;
      } else {
        this.current = Product.record;
      }
      if (item.id === Product.record.id) {
        return this.render();
      }
    };

    PreviewView.prototype.changedRelatedPhoto = function(item) {
      item = Product.find(item.product_id);
      if (item !== this.current) {
        return this.change(item);
      }
    };

    PreviewView.prototype.changeRelatedProduct = function(item) {
      item = Product.find(item.product_id);
      return this.change(item);
    };

    PreviewView.prototype.render = function() {
      var p;
      if (!this.current) {
        return;
      }
      this.contentEl.html(this.template(this.current));
      this.callDeferred(p = this.current.photos(), this.uriSettings(300, 300), this.callback);
      if (p.length > 1) {
        return pricingSlider(this.current.id);
      }
    };

    PreviewView.prototype.callback = function(json, items) {
      var i, jsn, key, len, res, result, results, ret, val;
      result = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = json.length; i < len; i++) {
          jsn = json[i];
          ret = (function() {
            var results1;
            results1 = [];
            for (key in jsn) {
              val = jsn[key];
              results1.push({
                src: val.src,
                id: key
              });
            }
            return results1;
          })();
          results.push(ret[0]);
        }
        return results;
      })();
      results = [];
      for (i = 0, len = result.length; i < len; i++) {
        res = result[i];
        results.push(this.snap(res));
      }
      return results;
    };

    PreviewView.prototype.snap = function(res) {
      var img, imgEl;
      imgEl = $('#' + res.id + ' img', this.el);
      img = this.createImage();
      img.imgEl = imgEl;
      img["this"] = this;
      img.res = res;
      img.onload = this.onLoad;
      img.onerror = this.onError;
      return img.src = res.src;
    };

    PreviewView.prototype.onLoad = function() {
      return this.imgEl.attr('src', this.src).removeClass('load').addClass('show');
    };

    PreviewView.prototype.onError = function(e) {
      return this["this"].snap(this.res);
    };

    PreviewView.prototype.click = function(e) {
      if (parent.hasClass('open')) {
        return;
      }
      return this.exapand(e);
    };

    PreviewView.prototype.togglePreview = function() {
      return this.expander.click();
    };

    PreviewView.prototype.dimmPreview = function(sel) {
      var dimm;
      dimm = !!sel.length;
      return this.preview.toggleClass('over', dimm);
    };

    PreviewView.prototype.expand = function(e) {
      var parent;
      parent = $(e.target).closest('li');
      parent.toggleClass('open');
      return e.preventDefault();
    };

    return PreviewView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = PreviewView;
  }

}).call(this);
 },"controllers/product_edit_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Extender, KeyEnhancer, ProductEditView, Spine, SubEditViewDescription, SubEditViewProduct, SubNoProduct, ToolbarView,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  KeyEnhancer = require('extensions/key_enhancer');

  Extender = require('extensions/controller_extender');

  CategoriesProduct = require('models/categories_product');

  ToolbarView = require("controllers/toolbar_view");

  SubEditViewProduct = require('controllers/sub_edit_view_product');

  SubEditViewDescription = require('controllers/sub_edit_view_description');

  SubNoProduct = require('controllers/sub_no_product');

  ProductEditView = (function(superClass) {
    extend(ProductEditView, superClass);

    ProductEditView.extend(Extender);

    ProductEditView.prototype.elements = {
      '.content': 'content',
      '.product': 'productEl',
      '.description': 'descriptionEl',
      '.noproduct': 'noProductEl',
      'button.opt-EditorProduct': 'btnProduct',
      'button.opt-EditorDescription': 'btnDescription'
    };

    ProductEditView.prototype.events = {
      'click .opt-EditorProduct': 'changeViewProduct',
      'click .opt-EditorDescription': 'changeViewDescription'
    };

    function ProductEditView() {
      ProductEditView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.productView = new SubEditViewProduct({
        el: this.productEl,
        parent: this,
        btn: this.btnProduct
      });
      this.descriptionView = new SubEditViewDescription({
        el: this.descriptionEl,
        parent: this,
        btn: this.btnDescription
      });
      this.noProductView = new SubNoProduct({
        el: this.noProductEl,
        parent: this
      });
      this.manager = new Spine.Manager(this.productView, this.descriptionView, this.noProductView);
      this.activeController = this.productView;
      this.manager.bind('change', this.proxy(this.changedController));
      Product.bind('current', this.proxy(this.currentProduct));
      CategoriesProduct.bind('destroy, update', this.proxy(this.changeRelated));
      Product.bind('destroy', this.proxy(this.change));
    }

    ProductEditView.prototype.active = function() {
      return this.render();
    };

    ProductEditView.prototype.change = function(item) {
      if (item && (item != null ? item.destroyed : void 0)) {
        this.current = null;
      } else {
        this.current = item;
      }
      return this.render();
    };

    ProductEditView.prototype.changeRelated = function(item) {
      var product, ref;
      if (item.product_id !== ((ref = Product.record) != null ? ref.id : void 0)) {
        return;
      }
      product = Category.product(item.category_id, item.product_id);
      return this.change(product);
    };

    ProductEditView.prototype.currentProduct = function(item) {
      var cat, ref;
      if (item.id !== ((ref = Product.record) != null ? ref.id : void 0)) {
        return;
      }
      if (cat = Category.record) {
        item = Category.product(cat.id, item.id);
      }
      return this.change(item);
    };

    ProductEditView.prototype.changedController = function(controller) {
      var c, i, len, ref, ref1, ref2;
      ref = this.manager.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (c !== controller) {
          if ((ref1 = c.btn) != null) {
            ref1.removeClass('active');
          }
        }
      }
      return (ref2 = controller.btn) != null ? ref2.addClass('active') : void 0;
    };

    ProductEditView.prototype.render = function() {
      if (this.current) {
        this.activeController.trigger('active');
      } else {
        this.noProductView.trigger('active');
      }
      return this.el;
    };

    ProductEditView.prototype.changeViewProduct = function(e) {
      var el;
      el = $(e.currentTarget);
      this.activeController = this.productView;
      if (this.current) {
        return this.activeController.trigger('active', el);
      }
    };

    ProductEditView.prototype.changeViewDescription = function(e) {
      var el;
      el = $(e.currentTarget);
      this.activeController = this.descriptionView;
      if (this.current) {
        return this.activeController.trigger('active', el);
      }
    };

    ProductEditView.prototype.click = function(e) {};

    return ProductEditView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductEditView;
  }

}).call(this);
 },"controllers/products_add_list": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, Model, Photo, Product, ProductExtender, ProductsAddList, ProductsPhoto, Spine, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  Extender = require('extensions/controller_extender');

  ProductExtender = require('extensions/product_extender');

  UriHelper = require('extensions/uri_helper');

  require('extensions/tmpl');

  ProductsAddList = (function(superClass) {
    extend(ProductsAddList, superClass);

    ProductsAddList.extend(UriHelper);

    ProductsAddList.extend(Extender);

    ProductsAddList.extend(ProductExtender);

    function ProductsAddList() {
      ProductsAddList.__super__.constructor.apply(this, arguments);
    }

    ProductsAddList.prototype.render = function(items) {
      if (items.length) {
        this.html(this.template(items));
        this.renderBackgrounds(items);
      } else {
        this.renderEmpty('Es gibt nichts hinzuzufgen.');
      }
      return this.el;
    };

    ProductsAddList.prototype.exposeSelection = function(selection) {
      var el, i, id, len, results;
      this.deselect();
      results = [];
      for (i = 0, len = selection.length; i < len; i++) {
        id = selection[i];
        el = $('#' + id, this.el);
        results.push(el.addClass("active hot"));
      }
      return results;
    };

    return ProductsAddList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsAddList;
  }

}).call(this);
 },"controllers/products_add_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Controller, Drag, Extender, Info, Product, ProductsAddList, ProductsAddView, ProductsPhoto, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  Controller = Spine.Controller;

  Drag = require('extensions/drag');

  User = require("models/user");

  Product = require('models/product');

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Info = require('controllers/info');

  ProductsAddList = require('controllers/products_add_list');

  User = require('models/user');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  ProductsAddView = (function(superClass) {
    extend(ProductsAddView, superClass);

    ProductsAddView.extend(Extender);

    ProductsAddView.prototype.elements = {
      '.modal-footer': 'footer',
      '.items': 'itemsEl'
    };

    ProductsAddView.prototype.events = {
      'click .item': 'click',
      'click .opt-modalAddExecute:not(.disabled)': 'add',
      'click .opt-modalSelectInv:not(.disabled)': 'selectInv',
      'click .opt-modalSelectAll:not(.disabled)': 'selectAll',
      'click .close': 'hide',
      'keyup': 'keyup'
    };

    ProductsAddView.prototype.template = function(items) {
      return $('#addTemplate').tmpl({
        title: 'Select products',
        type: 'products',
        disabled: true,
        contains: !!items.length,
        container: Category.record
      });
    };

    ProductsAddView.prototype.subTemplate = function(items, options) {
      return $("#productsTemplate").tmpl(items, options);
    };

    ProductsAddView.prototype.footerTemplate = function(selection) {
      return $('#footerTemplate').tmpl({
        disabled: !selection.length,
        contains: !!this.items.length
      });
    };

    function ProductsAddView() {
      var modal;
      ProductsAddView.__super__.constructor.apply(this, arguments);
      this.el = $('#modal-view');
      this.visible = false;
      modal = this.el.modal({
        show: this.visible,
        backdrop: true
      });
      this.list = new ProductsAddList({
        template: this.subTemplate,
        parent: this.parent,
        modal: true
      });
      modal.bind('show.bs.modal', this.proxy(this.modalShow));
      modal.bind('hide.bs.modal', this.proxy(this.modalHide));
      Spine.bind('products:add', this.proxy(this.show));
    }

    ProductsAddView.prototype.render = function(items) {
      this.html(this.template(this.items = items));
      this.delegateEvents(this.events);
      this.list.el = this.itemsEl;
      this.list.render(items);
      return this.el;
    };

    ProductsAddView.prototype.renderFooter = function(selection) {
      return this.footer.html(this.footerTemplate(selection));
    };

    ProductsAddView.prototype.show = function() {
      var list, records;
      list = CategoriesProduct.products(Category.record.id).toId();
      records = window.records = Product.filter(list, {
        func: 'idExcludeSelect'
      });
      return this.render(records).modal('show');
    };

    ProductsAddView.prototype.hide = function() {
      return this.el.modal('hide');
    };

    ProductsAddView.prototype.modalShow = function(e) {
      this.preservedList = Category.selectionList().slice(0);
      return this.selectionList = [];
    };

    ProductsAddView.prototype.modalHide = function(e) {};

    ProductsAddView.prototype.click = function(e) {
      var item;
      e.stopPropagation();
      e.preventDefault();
      item = $(e.currentTarget).item();
      return this.select(item.id, !this.isMeta(e));
    };

    ProductsAddView.prototype.select = function(items, cumul) {
      var i, item, len, list;
      if (items == null) {
        items = [];
      }
      if (!Array.isArray(items)) {
        items = [items];
      }
      if (cumul) {
        list = this.selectionList.slice(0);
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          list.addRemove(item);
        }
      } else {
        list = items.slice(0);
      }
      this.selectionList = list.slice(0);
      this.renderFooter(list);
      return this.list.exposeSelection(list);
    };

    ProductsAddView.prototype.selectAll = function(e) {
      var list;
      list = this.all();
      this.select(list);
      return e.stopPropagation();
    };

    ProductsAddView.prototype.selectInv = function(e) {
      var list;
      list = this.all();
      this.select(list, true);
      return e.stopPropagation();
    };

    ProductsAddView.prototype.all = function() {
      var items, list, root;
      root = this.itemsEl;
      items = root.children('.item');
      list = [];
      items.each(function(index, el) {
        var item;
        item = $(this).item();
        return list.unshift(item.id);
      });
      return list;
    };

    ProductsAddView.prototype.add = function() {
      var products;
      products = Product.toRecords(this.selectionList);
      return Product.trigger('create:join', products, Category.record, this.proxy(this.hide));
    };

    ProductsAddView.prototype.keyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      this.log('PhotosAddView:keyupCode: ' + code);
      switch (code) {
        case 65:
          if (e.metaKey || e.ctrlKey) {
            this.selectAll(e);
            e.stopPropagation();
            return e.preventDefault();
          }
          break;
        case 73:
          if (e.metaKey || e.ctrlKey) {
            this.selectInv(e);
            e.preventDefault();
            return e.stopPropagation();
          }
      }
    };

    return ProductsAddView;

  })(Spine.Controller);

  module.exports = ProductsAddView;

}).call(this);
 },"controllers/products_header": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, Photo, Product, ProductsHeader, ProductsPhoto, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Extender = require('extensions/controller_extender');

  ProductsHeader = (function(superClass) {
    extend(ProductsHeader, superClass);

    ProductsHeader.extend(Extender);

    ProductsHeader.prototype.events = {
      'click .gal': 'backToCategories'
    };

    function ProductsHeader() {
      ProductsHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Category.bind('change', this.proxy(this.render));
      CategoriesProduct.bind('change', this.proxy(this.render));
      Category.bind('change:selection', this.proxy(this.render));
      Product.bind('refresh', this.proxy(this.render));
      Product.bind('change', this.proxy(this.render));
      Product.bind('change:current', this.proxy(this.render));
      Product.bind('change:collection', this.proxy(this.render));
    }

    ProductsHeader.prototype.render = function() {
      this.html(this.template({
        model: Category,
        modelProduct: Product,
        modelPhoto: Photo,
        modelGas: CategoriesProduct,
        modelAps: ProductsPhoto,
        category: Category.record,
        product: Product.record,
        photo: Photo.record,
        author: User.first().name
      }));
      return this.refreshElements();
    };

    ProductsHeader.prototype.count = function() {
      var filterOptions;
      if (Category.record) {
        filterOptions = {
          model: 'Category'
        };
        return Product.filterRelated(Category.record.id, filterOptions).length;
      } else {
        return Product.filter();
      }
    };

    ProductsHeader.prototype.backToCategories = function(e) {
      this.navigate('/category', '');
      return e.preventDefault();
    };

    ProductsHeader.prototype.goUp = function(e) {
      this.navigate('/category', '');
      e.preventDefault();
      return e.stopPropagation();
    };

    ProductsHeader.prototype.active = function() {
      return this.render();
    };

    return ProductsHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsHeader;
  }

}).call(this);
 },"controllers/products_list": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Drag, Extender, Model, Photo, Product, ProductExtender, ProductsList, ProductsPhoto, Spine, UriHelper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  ProductsPhoto = require('models/products_photo');

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  Extender = require('extensions/controller_extender');

  ProductExtender = require('extensions/product_extender');

  CategoriesProduct = require('models/categories_product');

  UriHelper = require('extensions/uri_helper');

  Drag = require('extensions/drag');

  require('extensions/tmpl');

  ProductsList = (function(superClass) {
    extend(ProductsList, superClass);

    ProductsList.extend(Drag);

    ProductsList.extend(Extender);

    ProductsList.extend(ProductExtender);

    ProductsList.extend(UriHelper);

    ProductsList.prototype.events = {
      'click .dropdown-toggle': 'dropdownToggle',
      'click .opt-AddProducts': 'addProducts',
      'click .opt-delete': 'deleteProduct',
      'click .opt-ignored': 'ignoreProduct',
      'click .opt-original': 'original',
      'click .opt-favorite': 'toggleFavorite',
      'click .zoom': 'zoom'
    };

    function ProductsList() {
      ProductsList.__super__.constructor.apply(this, arguments);
      this.widows = [];
      this.add = this.html;
      Product.bind('update', this.proxy(this.updateTemplate));
      Product.bind("ajaxError", Product.errorHandler);
      CategoriesProduct.bind('change', this.proxy(this.changeRelated));
      CategoriesProduct.bind('destroy', this.proxy(this.testEmpty));
      Product.bind('change:collection', this.proxy(this.renderBackgrounds));
      Category.bind('change:selection', this.proxy(this.exposeSelection));
    }

    ProductsList.prototype.changedProducts = function(category) {};

    ProductsList.prototype.changeRelated = function(item, mode) {
      var product;
      if (!(this.parent && this.parent.isActive())) {
        return;
      }
      if (!Category.record) {
        return;
      }
      if (Category.record.id !== item['category_id']) {
        return;
      }
      product = Product.find(item['product_id']);
      product = this.mixinOne(product);
      switch (mode) {
        case 'create':
          this.wipe().append(this.template(product));
          this.renderBackgrounds(product);
          this.el.sortable('destroy').sortable();
          $('.dropdown-toggle', this.el).dropdown();
          break;
        case 'update':
          this.updateTemplate(product);
      }
      this.refreshElements();
      return this.el;
    };

    ProductsList.prototype.mixin = function(items) {
      var i, item, len, results;
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        results.push(this.mixinOne(item));
      }
      return results;
    };

    ProductsList.prototype.mixinOne = function(item) {
      var atts, ga;
      if (!Category.record) {
        return item;
      }
      ga = CategoriesProduct.productExists(item.id, Category.record.id);
      if (ga) {
        atts = ga != null ? ga.mixinAttributes(item) : void 0;
        item.silentUpdate(atts);
        return item;
      }
      return item;
    };

    ProductsList.prototype.render = function(items, mode) {
      var ref, ref1, ref2, s;
      if (items == null) {
        items = [];
      }
      if (mode == null) {
        mode = "html";
      }
      this.log('render', mode);
      if (!items.length) {
        s = (s = ((ref = this.model.record) != null ? ref.screenname : void 0) || (s = ((ref1 = this.model.record) != null ? ref1.name : void 0) || (s = (ref2 = this.model.record) != null ? ref2.title : void 0))) != null ? 'in ' + s + ' nichts los - kein Moos' : 'nichts los hier. Brutal...';
        this.renderEmpty(s);
        return this.el;
      }
      items = this.mixin(items);
      this[mode](this.template(items));
      this.renderBackgrounds(items);
      this.exposeSelection();
      $('.dropdown-toggle', this.el).dropdown();
      return this.el;
    };

    ProductsList.prototype.original = function(e) {
      var id;
      id = $(e.currentTarget).item().id;
      Category.selection[0].global.update([id]);
      this.navigate('/category', '');
      e.preventDefault();
      return e.stopPropagation();
    };

    ProductsList.prototype.toggleFavorite = function(e) {
      var cat, favorite, favorites, i, isFavorite, item, len;
      if ((cat = Category.record) && (!Category["protected"][cat != null ? cat.name : void 0])) {
        App.confirm('NO_VALID_CATEGORY', {
          mode: 'alert'
        });
        return;
      }
      item = $(e.currentTarget).item();
      isFavorite = item.favorite;
      if (!isFavorite && item.ignored) {
        App.confirm('NO_FAVORITE_FOR_IGNORED', {
          mode: 'alert'
        });
        return;
      }
      favorites = Product.findAllByAttribute('favorite', true);
      for (i = 0, len = favorites.length; i < len; i++) {
        favorite = favorites[i];
        favorite.updateAttributes({
          'favorite': false
        });
      }
      item.updateAttributes({
        'favorite': !isFavorite
      });
      e.preventDefault();
      return e.stopPropagation();
    };

    ProductsList.prototype.zoom = function(e) {
      var iid, item, ref;
      item = e.type === 'click' ? $(e.currentTarget).item() : this.models.record;
      this.parent.stopInfo();
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', (item != null ? item.id : void 0) || '', iid = (iid = typeof item.selectionList === "function" ? item.selectionList().first() : void 0) ? 'iid/' + iid : null);
      e.preventDefault();
      return e.stopPropagation();
    };

    ProductsList.prototype.back = function(e) {
      var cid, ref;
      this.navigate('/category', cid = (cid = (ref = Category.record) != null ? ref.id : void 0) ? 'cid/' + cid : null);
      e.preventDefault();
      return e.stopPropagation();
    };

    ProductsList.prototype.dropdownToggle = function(e) {
      var el;
      el = $(e.currentTarget);
      el.dropdown();
      return e.preventDefault();
    };

    ProductsList.prototype.ignoreProduct = function(e) {
      var category, product;
      product = $(e.currentTarget).item();
      category = this.parent.model.record;
      Spine.trigger('product:ignore', product, category);
      e.stopPropagation();
      return e.preventDefault();
    };

    ProductsList.prototype.deleteProduct = function(e) {
      var item, ref;
      this.log('deleteProduct');
      item = $(e.currentTarget).item();
      if ((item != null ? (ref = item.constructor) != null ? ref.className : void 0 : void 0) !== 'Product') {
        return;
      }
      Spine.trigger('delete:products', [item.id]);
      e.stopPropagation();
      return e.preventDefault();
    };

    ProductsList.prototype.addProducts = function(e) {
      this.log('add');
      return Spine.trigger('products:add');
    };

    return ProductsList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsList;
  }

}).call(this);
 },"controllers/products_trash_header": function(exports, require, module) { (function() {
  var $, Category, Extender, ProductsTrashHeader, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Extender = require('extensions/controller_extender');

  ProductsTrashHeader = (function(superClass) {
    extend(ProductsTrashHeader, superClass);

    ProductsTrashHeader.extend(Extender);

    ProductsTrashHeader.prototype.template = function(items) {
      return $("#headerProductTrashTemplate").tmpl(items);
    };

    function ProductsTrashHeader() {
      ProductsTrashHeader.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    ProductsTrashHeader.prototype.render = function(item) {
      return this.html(this.template(item));
    };

    ProductsTrashHeader.prototype.active = function() {
      return this.render();
    };

    return ProductsTrashHeader;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsTrashHeader;
  }

}).call(this);
 },"controllers/products_trash_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Controller, Drag, Extender, ProductExtender, Products, ProductsPhoto, ProductsTrash, ProductsTrashView, Spine, UriHelper, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Drag = require('extensions/drag');

  User = require("models/user");

  ProductsTrash = require("models/products_trash");

  CategoriesProduct = require("models/categories_product");

  Products = require("models/product");

  ProductsPhoto = require("models/products_photo");

  Extender = require('extensions/controller_extender');

  ProductExtender = require('extensions/product_extender');

  UriHelper = require('extensions/uri_helper');

  ProductsTrashView = (function(superClass) {
    extend(ProductsTrashView, superClass);

    ProductsTrashView.extend(UriHelper);

    ProductsTrashView.extend(Drag);

    ProductsTrashView.extend(Extender);

    ProductsTrashView.extend(ProductExtender);

    ProductsTrashView.prototype.elements = {
      '.items': 'items'
    };

    ProductsTrashView.prototype.events = {
      'click': 'clearSelection',
      'click .item': 'click',
      'click .dropdown-toggle': 'dropdownToggle',
      'click .opt-destroy': 'destroyProduct',
      'click .opt-recover': 'recoverProduct',
      'mousemove .item': 'in',
      'mouseleave .item': 'out',
      'dragstart ': 'dragstart',
      'dragend': 'dragend',
      'drop': 'drop',
      'dragover   ': 'dragover',
      'dragenter  ': 'dragenter',
      'keyup': 'keyup'
    };

    ProductsTrashView.prototype.template = function(items, options) {
      return $("#productsTrashTemplate").tmpl(items, options);
    };

    function ProductsTrashView() {
      this.out = bind(this.out, this);
      this["in"] = bind(this["in"], this);
      ProductsTrashView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Product.bind('beforeDestroy', this.proxy(this.beforeDestroy));
      Product.bind('destroy:trash', this.proxy(this.destroy));
      Product.bind('inbound:trash', this.proxy(this.inbound));
      Product.bind('outbound:trash', this.proxy(this.outbound));
      Product.bind('destroy:products', this.proxy(this.destroyProducts));
      Product.bind('empty:trash', this.proxy(this.emptyTrash));
      Product.bind('refresh', this.proxy(this.initTrash));
      ProductsTrash.bind('change:selection', this.proxy(this.exposeSelection));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
      this.bind('drag:start', this.proxy(this.dragStart));
      this.bind('drag:enter', this.proxy(this.dragEnter));
      this.bind('drag:over', this.proxy(this.dragOver));
      this.bind('drag:leave', this.proxy(this.dragLeave));
      this.bind('drag:drop', this.proxy(this.dragDrop));
    }

    ProductsTrashView.prototype.initTrash = function(items) {
      var i, item, len, results, trash;
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        if (!item.deleted) {
          continue;
        }
        trash = new ProductsTrash({
          id: item.id
        });
        trash.save();
        results.push(item.one('update destroy', this.proxy(this.watch)));
      }
      return results;
    };

    ProductsTrashView.prototype.refreshOne = function() {
      return Product.one('refresh', this.proxy(this.refresh));
    };

    ProductsTrashView.prototype.refresh = function() {
      var items;
      items = Product.filter(true, {
        func: 'selectDeleted'
      });
      return this.render(items);
    };

    ProductsTrashView.prototype.render = function(items) {
      this.items.html(this.template(items));
      this.log(items);
      this.renderBackgrounds(items);
      return this.el;
    };

    ProductsTrashView.prototype.active = function(items) {
      this.render(items);
      App.showView.trigger('change:toolbarOne', ['Default', 'Help']);
      return App.showView.trigger('change:toolbarTwo', ['Speichern']);
    };

    ProductsTrashView.prototype.inbound = function(products) {
      var i, len, product;
      if (!Array.isArray(products)) {
        products = [products];
      }
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        product.deleted = true;
        product.save();
        Product.trigger('trashed', product);
      }
      return this.initTrash(products);
    };

    ProductsTrashView.prototype.outbound = function(item) {};

    ProductsTrashView.prototype.watch = function(item) {
      var trash;
      if (!item.deleted || item.destroyed) {
        trash = ProductsTrash.find(item.id);
        if (!trash) {
          return;
        }
        trash.destroy();
        Product.trigger('outbound:trash');
        return this.remove(item);
      }
    };

    ProductsTrashView.prototype.dropdownToggle = function(e) {
      var el;
      el = $(e.currentTarget);
      el.dropdown();
      e.stopPropagation();
      return e.preventDefault();
    };

    ProductsTrashView.prototype.recoverProduct = function(e) {
      var item;
      e.stopPropagation();
      item = $(e.currentTarget).item();
      item.deleted = false;
      item.save();
      return Product.createJoin([item], Category.findByAttribute('name', 'none'));
    };

    ProductsTrashView.prototype.destroyProduct = function(e) {
      var id, item;
      e.stopPropagation();
      item = $(e.currentTarget).item();
      if (id = item != null ? item.id : void 0) {
        return this.destroyProducts(e, id);
      }
    };

    ProductsTrashView.prototype.destroyProducts = function(e, ids, callback) {
      var i, len, product, products, res, results;
      if (ids == null) {
        ids = this.model.selectionList();
      }
      this.log('destroyProducts');
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      products = Product.toRecords(ids);
      results = [];
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        if (product.deleted) {
          if (res || (res = App.confirm('DESTROY', this.humanize(products)))) {
            Product.trigger('destroy:trash', product);
            continue;
          } else {
            break;
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    ProductsTrashView.prototype.beforeDestroy = function(product) {
      var categories, category, i, len, photos, results;
      this.log('beforeDestroy');
      product.unbind('released:fromTrash');
      product.removeSelectionID();
      categories = CategoriesProduct.categories(product.id);
      results = [];
      for (i = 0, len = categories.length; i < len; i++) {
        category = categories[i];
        category.removeFromSelection(product.id);
        photos = ProductsPhoto.photos(product.id).toId();
        results.push(Photo.trigger('destroy:join', photos, product));
      }
      return results;
    };

    ProductsTrashView.prototype.destroy = function(items) {
      var i, item, len, results;
      this.log('destroy');
      if (!Array.isArray(items)) {
        items = [items];
      }
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        results.push(item.destroy());
      }
      return results;
    };

    ProductsTrashView.prototype.emptyTrash = function(items) {
      var i, item, len, results;
      if (App.confirm('EMPTYTRASH')) {
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          results.push(item.destroy());
        }
        return results;
      }
    };

    ProductsTrashView.prototype.click = function(e) {
      var item;
      item = $(e.currentTarget).item();
      this.select(e, item.id);
      return e.stopPropagation();
    };

    ProductsTrashView.prototype.select = function(e, ids) {
      var list;
      if (ids == null) {
        ids = [];
      }
      list = this.model.selectionList().slice(0);
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      if (this.isMeta(e)) {
        list.addRemove(ids);
      } else {
        list = ids.slice(0);
      }
      this.model.updateSelection(list);
      return e.stopPropagation();
    };

    ProductsTrashView.prototype.back = function(e) {
      var cid, pid, ref, ref1;
      if (cid = (ref = Category.record) != null ? ref.id : void 0) {
        return this.navigate('/category', cid, pid = ((ref1 = Category.record) != null ? ref1.selectionList().first() : void 0) ? 'pid/' + pid : '');
      } else {
        return this.navigate('/category', '');
      }
    };

    ProductsTrashView.prototype["in"] = function(e) {
      var el;
      el = $(e.currentTarget);
      return $('.glyphicon-set.fade', el).addClass('show').removeClass('fade');
    };

    ProductsTrashView.prototype.out = function(e) {
      var el, set;
      el = $(e.currentTarget);
      return set = $('.glyphicon-set.fade', el).addClass('fade').removeClass('show');
    };

    ProductsTrashView.prototype.keyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      switch (code) {
        case 8:
          this.destroyProducts(e);
          e.preventDefault();
          return e.stopPropagation();
      }
    };

    return ProductsTrashView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsTrashView;
  }

}).call(this);
 },"controllers/products_view": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Controller, Drag, Extender, Info, Product, ProductsList, ProductsPhoto, ProductsView, Spine, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Drag = require('extensions/drag');

  User = require("models/user");

  Product = require('models/product');

  Category = require('models/category');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Info = require('controllers/info');

  ProductsList = require('controllers/products_list');

  Extender = require('extensions/controller_extender');

  User = require('models/user');

  require('extensions/tmpl');

  ProductsView = (function(superClass) {
    extend(ProductsView, superClass);

    ProductsView.extend(Drag);

    ProductsView.extend(Extender);

    ProductsView.prototype.elements = {
      '.hoverinfo': 'infoEl',
      '.header .hoverinfo': 'headerEl',
      '.items': 'itemsEl'
    };

    ProductsView.prototype.events = {
      'click': 'clearSelection',
      'click      .item': 'click',
      'dragstart ': 'dragstart',
      'dragstart': 'stopInfo',
      'dragend': 'dragend',
      'drop': 'drop',
      'dragover   ': 'dragover',
      'dragenter  ': 'dragenter',
      'sortupdate .items': 'sortupdate',
      'mousemove .item': 'infoUp',
      'mouseleave .item': 'infoBye'
    };

    ProductsView.prototype.productsTemplate = function(items, options) {
      return $("#productsTemplate").tmpl(items, options);
    };

    ProductsView.prototype.headerTemplate = function(items) {
      return $("#headerProductTemplate").tmpl(items);
    };

    ProductsView.prototype.infoTemplate = function(item) {
      return $('#productInfoTemplate').tmpl(item);
    };

    function ProductsView() {
      this.stopInfo = bind(this.stopInfo, this);
      this.infoBye = bind(this.infoBye, this);
      this.infoUp = bind(this.infoUp, this);
      ProductsView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.info = new Info({
        el: this.infoEl,
        template: this.infoTemplate
      });
      this.list = new ProductsList({
        el: this.itemsEl,
        template: this.productsTemplate,
        parent: this
      });
      this.header.template = this.headerTemplate;
      this.viewport = this.list.el;
      CategoriesProduct.bind('beforeDestroy', this.proxy(this.beforeDestroyCategoriesProduct));
      CategoriesProduct.bind('destroy', this.proxy(this.destroyCategoriesProduct));
      CategoriesProduct.bind('ignored', this.proxy(this.ignoreProduct));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
      Product.bind('create', this.proxy(this.create));
      Product.bind('ajaxError', Product.errorHandler);
      Product.bind('create:join', this.proxy(this.createJoin));
      Product.bind('destroy:join', this.proxy(this.destroyJoin));
      Product.bind('change:collection', this.proxy(this.renderBackgrounds));
      Product.bind('show:unpublished', this.proxy(this.showUnpublished));
      Product.bind('show:unused', this.proxy(this.showUnused));
      Product.bind('trashed', this.proxy(this.remove));
      Spine.bind('reorder', this.proxy(this.reorder));
      Spine.bind('create:product', this.proxy(this.createProduct));
      Spine.bind('loading:start', this.proxy(this.loadingStart));
      Spine.bind('loading:done', this.proxy(this.loadingDone));
      Spine.bind('loading:fail', this.proxy(this.loadingFail));
      Spine.bind('delete:products', this.proxy(this.deleteProducts));
      this.bind('drag:start', this.proxy(this.dragStart));
      this.bind('drag:enter', this.proxy(this.dragEnter));
      this.bind('drag:over', this.proxy(this.dragOver));
      this.bind('drag:leave', this.proxy(this.dragLeave));
      this.bind('drag:drop', this.proxy(this.dragDrop));
      $(this.views).queue('fx');
    }

    ProductsView.prototype.deactivate = function() {
      this.el.removeClass('active');
      return this;
    };

    ProductsView.prototype.refreshOne = function() {
      return Product.one('refresh', this.proxy(this.refresh));
    };

    ProductsView.prototype.refresh = function() {
      return this.render(Product.renderBuffer(true));
    };

    ProductsView.prototype.render = function(items, mode) {
      if (mode == null) {
        mode = 'html';
      }
      this.list.render(items, mode);
      if (Category.record) {
        this.list.sortable('product');
      }
      return this.el;
    };

    ProductsView.prototype.active = function(items, options) {
      var b1, b2;
      b1 = this.eql.call(this.parent);
      b2 = this.eql_();
      if (b1 && b2) {
        return;
      }
      App.showView.trigger('change:toolbarOne', ['Default']);
      App.showView.trigger('change:toolbarTwo', ['Trustami']);
      this.render(items);
      return this.parent.scrollTo(this.models.record);
    };

    ProductsView.prototype.resetInvalid = function(products) {
      var alb, j, len, results;
      results = [];
      for (j = 0, len = products.length; j < len; j++) {
        alb = products[j];
        if (alb.invalid) {
          alb.invalid = false;
          results.push(alb.save({
            ajax: false
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    ProductsView.prototype.activateRecord = function(ids) {
      if (!ids) {
        ids = [];
      }
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      return Product.current(ids[0]);
    };

    ProductsView.prototype.showUnpublished = function() {
      var ga, gas, item, items, j, len;
      gas = CategoriesProduct.unpublishedProducts(true);
      items = [];
      for (j = 0, len = gas.length; j < len; j++) {
        ga = gas[j];
        if (item = Product.find(ga.product_id)) {
          items.push(item);
        }
      }
      this.navigate('/category', '');
      return this.render(items);
    };

    ProductsView.prototype.showUnused = function() {
      var items;
      items = Product.unusedProducts(true);
      this.navigate('/category', '');
      return this.render(items);
    };

    ProductsView.prototype.newAttributes = function() {
      var ref, user_id;
      if (user_id = (ref = User.first()) != null ? ref.id : void 0) {
        return {
          title: this.productName(),
          subtitle: '',
          notes: '',
          link: '',
          author: User.first().name,
          invalid: true,
          ignored: true,
          favorite: false,
          user_id: user_id,
          order: Product.count()
        };
      } else {
        return User.ping();
      }
    };

    ProductsView.prototype.productName = function(proposal) {
      if (proposal == null) {
        proposal = 'New Product ' + (function() {
          var i, index, s;
          s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
          index = (i = Product.count() + 1) < s.length ? i : i % s.length;
          return s.split('')[index];
        })();
      }
      Product.each((function(_this) {
        return function(record) {
          if (record.title === proposal) {
            return proposal = _this.productName(proposal + proposal.split(' ')[1][0]);
          }
        };
      })(this));
      return proposal;
    };

    ProductsView.prototype.create = function(record) {
      return record.updateSelectionID();
    };

    ProductsView.prototype.createProduct = function(target, options) {
      var cb, product;
      if (target == null) {
        target = Category.record;
      }
      if (options == null) {
        options = {};
      }
      cb = function(record, ido) {
        var func;
        if (target) {
          record.createJoin(target);
          func = function() {
            return target.updateSelection(record.id);
          };
        } else {
          func = function() {
            var ref;
            return Category.updateSelection([record.id], (ref = Category.record) != null ? ref.id : void 0);
          };
        }
        this.navigate('/category', (target != null ? target.id : void 0) || '', 'pid', product.id);
        setTimeout(func, 100);
        $().extend(options, {
          product: record
        });
        if (options.photos) {
          Photo.trigger('create:join', options.photos, record, cb);
          cb = (function(_this) {
            return function() {
              var origin;
              if (origin = options.deleteFromOrigin) {
                return Photo.trigger('destroy:join', options.photos, origin);
              }
            };
          })(this);
        }
        if (options.deferred) {
          options.deferred.notify(record);
        }
        if (options.cb) {
          return options.cb.apply(this, [record, options.deferred]);
        }
      };
      if (!Category.record) {
        return App.confirm('NOCAT', null, 'alert');
      }
      product = new Product(this.newAttributes());
      product.one('ajaxSuccess', this.proxy(cb));
      product.save();
      return product;
    };

    ProductsView.prototype.beforeDestroyCategoriesProduct = function(ga) {
      var category, product;
      category = Category.find(ga.category_id);
      if (category) {
        category.removeFromSelection(ga.product_id);
      }
      return product = Product.find(ga.product_id);
    };

    ProductsView.prototype.destroyCategoriesProduct = function(ga) {};

    ProductsView.prototype.ignoreProduct = function(ga, ignored) {
      this.log('ignoreProduct');
      ga.ignored = ignored;
      return ga.save();
    };

    ProductsView.prototype.deleteProducts = function(ids, callback) {
      var cat, category, cats, j, k, len, len1, product, products, res1, res2, res3, res4, results;
      this.log('deleteProduct');
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      this.stopInfo();
      if (!ids.length) {
        ids = Category.selectionList().slice(0);
      }
      products = Product.toRecords(ids);
      results = [];
      for (j = 0, len = products.length; j < len; j++) {
        product = products[j];
        if (product.deleted) {
          Product.trigger('destroy:products', ids);
          break;
        }
        cats = CategoriesProduct.categories(product.id);
        if (!(category = Category.record)) {
          if (cats.length) {
            if (res1 || (res1 = App.confirm('REMOVE_AND_DELETE', this.humanize(products)))) {
              for (k = 0, len1 = cats.length; k < len1; k++) {
                cat = cats[k];
                this.destroyJoin(product, cat);
              }
              Product.trigger('inbound:trash', product);
              continue;
            } else {
              break;
            }
          } else {
            if (res2 || (res2 = App.confirm('DELETE', this.humanize(products)))) {
              Product.trigger('inbound:trash', product);
              continue;
            } else {
              break;
            }
          }
        } else {
          if (cats.length === 1) {
            if (res3 || (res3 = App.confirm('DELETE', this.humanize(products)))) {
              this.destroyJoin(product, category);
              Product.trigger('inbound:trash', product);
              continue;
            } else {
              break;
            }
          } else {
            if (res4 || (res4 = App.confirm('REMOVE', this.humanize(products)))) {
              this.destroyJoin(product, category);
              continue;
            } else {
              break;
            }
          }
        }
      }
      return results;
    };

    ProductsView.prototype.createJoin = function(products, category, callback) {
      Product.createJoin(products, category, callback);
      return category.updateSelection(products.toId());
    };

    ProductsView.prototype.destroyJoin = function(products, category) {
      var callback;
      this.log('destroyJoin');
      callback = function() {};
      if (!Product.isArray(products)) {
        products = [products];
      }
      return Product.destroyJoin(products, category, callback);
    };

    ProductsView.prototype.loadingStart = function(product) {
      var el;
      if (!this.isActive()) {
        return;
      }
      if (!product) {
        return;
      }
      el = this.itemsEl.children().forItem(product);
      $('.glyphicon-set', el).addClass('show');
      return $('.downloading', el).removeClass('fade').addClass('show');
    };

    ProductsView.prototype.loadingDone = function(product) {
      var el;
      if (!this.isActive()) {
        return;
      }
      if (!product) {
        return;
      }
      el = this.itemsEl.children().forItem(product);
      $('.glyphicon-set', el).removeClass('show');
      return $('.downloading', el).removeClass('show').addClass('fade');
    };

    ProductsView.prototype.loadingFail = function(product, error) {
      var el, err;
      if (!this.isActive()) {
        return;
      }
      err = error.errorThrown;
      el = this.itemsEl.children().forItem(product);
      $('.glyphicon-set', el).removeClass('show');
      return $('.downloading', el).addClass('error').tooltip('destroy').tooltip({
        title: err
      }).tooltip('show');
    };

    ProductsView.prototype.renderBackgrounds = function(products) {
      if (!this.isActive()) {
        return;
      }
      return this.list.renderBackgrounds(products);
    };

    ProductsView.prototype.sortupdate = function(e, o) {
      var cb;
      cb = function() {
        return Category.trigger('change:collection', Category.record);
      };
      this.list.children().each(function(index) {
        var ga, item;
        item = $(this).item();
        if (item && Category.record) {
          ga = CategoriesProduct.filter(item.id, {
            func: 'selectProduct'
          })[0];
          if (ga && parseInt(ga.order) !== index) {
            ga.order = index;
            return ga.silentUpdate();
          }
        }
      });
      return Category.record.save({
        done: cb,
        validate: false
      });
    };

    ProductsView.prototype.reorder = function(category) {
      if (category.id === Category.record.id) {
        return this.render(Product.renderBuffer());
      }
    };

    ProductsView.prototype.click = function(e, excl) {
      var item;
      item = $(e.currentTarget).item();
      return this.select(e, item.id);
    };

    ProductsView.prototype.select = function(e, ids) {
      var list, ref, ref1;
      if (ids == null) {
        ids = [];
      }
      list = this.model.selectionList().slice(0);
      if (!Array.isArray(ids)) {
        ids = [ids];
      }
      if (!this.isMeta(e) && e.type === 'click') {
        list.addRemove(ids);
      } else {
        list = ids.slice(0);
      }
      if (list.length) {
        this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', 'pid', list[0]);
      } else {
        this.navigate('/category', ((ref1 = Category.record) != null ? ref1.id : void 0) || '');
      }
      this.model.updateSelection(list);
      return e.stopPropagation();
    };

    ProductsView.prototype.infoUp = function(e) {
      var el;
      this.info.up(e);
      el = $(e.currentTarget);
      return $('.glyphicon-set.fade', el).addClass('show').removeClass('fade');
    };

    ProductsView.prototype.infoBye = function(e) {
      var el, set;
      this.info.bye(e);
      el = $(e.currentTarget);
      return set = $('.glyphicon-set.fade', el).addClass('fade').removeClass('show');
    };

    ProductsView.prototype.stopInfo = function(e) {
      return this.info.bye(e);
    };

    ProductsView.prototype.dropComplete = function(e) {
      return this.log('dropComplete');
    };

    return ProductsView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ProductsView;
  }

}).call(this);
 },"controllers/refresh_view": function(exports, require, module) { (function() {
  var $, Category, Description, Photo, Product, RefreshView, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  Description = require('models/description');

  RefreshView = (function(superClass) {
    extend(RefreshView, superClass);

    RefreshView.prototype.elements = {
      'button': 'logoutEl'
    };

    RefreshView.prototype.events = {
      'click .opt-Refresh': 'refresh'
    };

    RefreshView.prototype.template = function(icon) {
      if (icon == null) {
        icon = 'repeat';
      }
      return $('#refreshTemplate').tmpl({
        icon: icon
      });
    };

    function RefreshView() {
      RefreshView.__super__.constructor.apply(this, arguments);
      Spine.bind('refresh:all', this.proxy(this.refresh));
    }

    RefreshView.prototype.refresh = function(e) {
      this.render('cloud-download');
      Spine.trigger('refresh:one');
      this.fetchAll();
      if (e != null) {
        e.stopPropagation();
      }
      return e != null ? e.preventDefault() : void 0;
    };

    RefreshView.prototype.render = function(icon) {
      return this.html(this.template(icon));
    };

    RefreshView.prototype.fetchAll = function() {
      Photo.fetch(null, {
        clear: true
      });
      Product.fetch(null, {
        clear: true
      });
      Category.fetch(null, {
        clear: true
      });
      return Description.fetch(null, {
        clear: true
      });
    };

    return RefreshView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = RefreshView;
  }

}).call(this);
 },"controllers/show_view": function(exports, require, module) { (function() {
  var $, CategoriesHeader, CategoriesProduct, CategoriesView, Category, Clipboard, Controller, Drag, Extender, ModalSimpleView, Model, MysqlAjax, Photo, PhotoHeader, PhotoView, PhotosAddView, PhotosHeader, PhotosTrash, PhotosTrashHeader, PhotosTrashView, PhotosView, Product, ProductsAddView, ProductsHeader, ProductsPhoto, ProductsTrash, ProductsTrashHeader, ProductsTrashView, ProductsView, Root, ShowView, Spine, ToolbarView, WaitView,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Controller = Spine.Controller;

  Root = require('models/root');

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  ProductsTrash = require('models/products_trash');

  PhotosTrash = require('models/photos_trash');

  CategoriesProduct = require('models/categories_product');

  Clipboard = require("models/clipboard");

  ToolbarView = require("controllers/toolbar_view");

  WaitView = require("controllers/wait_view");

  ProductsView = require("controllers/products_view");

  PhotosHeader = require('controllers/photos_header');

  PhotosView = require('controllers/photos_view');

  PhotoHeader = require('controllers/photo_header');

  PhotoView = require('controllers/photo_view');

  ProductsHeader = require('controllers/products_header');

  ProductsTrashView = require('controllers/products_trash_view');

  ProductsTrashHeader = require('controllers/products_trash_header');

  PhotosTrashView = require('controllers/photos_trash_view');

  PhotosTrashHeader = require('controllers/photos_trash_header');

  ProductsAddView = require('controllers/products_add_view');

  PhotosAddView = require('controllers/photos_add_view');

  CategoriesView = require('controllers/categories_view');

  CategoriesHeader = require('controllers/categories_header');

  ModalSimpleView = require("controllers/modal_simple_view");

  Extender = require('extensions/controller_extender');

  Drag = require('extensions/drag');

  MysqlAjax = require('extensions/mysql_ajax');

  require('spine/lib/manager');

  ShowView = (function(superClass) {
    extend(ShowView, superClass);

    ShowView.extend(Drag);

    ShowView.extend(Extender);

    ShowView.extend(MysqlAjax);

    ShowView.prototype.elements = {
      '#fileupload': 'uploader',
      '#views .views': 'views',
      '.contents': 'contents',
      '.items': 'lists',
      '.header .categories': 'categoriesHeaderEl',
      '.header .products': 'productsHeaderEl',
      '.header .photos': 'photosHeaderEl',
      '.header .photo': 'photoHeaderEl',
      '.header .photos-trash': 'photosTrashHeaderEl',
      '.header .products-trash': 'productsTrashHeaderEl',
      '.opt-EditCategory': 'btnEditCategory',
      '.opt-Category .ui-icon': 'btnCategory',
      '.opt-AutoUpload': 'btnAutoUpload',
      '.opt-Previous': 'btnPrevious',
      '.opt-Sidebar': 'btnSidebar',
      '.opt-FullScreen': 'btnFullScreen',
      '.opt-Save': 'btnSave',
      '.toolbar-one': 'toolbarOneEl',
      '.toolbar-two': 'toolbarTwoEl',
      '.props': 'propsEl',
      '.content.photos-trash': 'photosTrashEl',
      '.content.products-trash': 'productsTrashEl',
      '.content.categories': 'categoriesEl',
      '.content.products': 'productsEl',
      '.content.photos': 'photosEl',
      '.content.photo': 'photoEl',
      '.content.wait': 'waitEl',
      '#modal-action': 'modalActionEl',
      '#modal-addProduct': 'modalAddProductEl',
      '#modal-addPhoto': 'modalAddPhotoEl',
      '.slider': 'slider',
      '.opt-Product': 'btnProduct',
      '.opt-Category': 'btnCategory',
      '.opt-Photo': 'btnPhoto',
      '.opt-Upload': 'btnUpload'
    };

    ShowView.prototype.events = {
      'click .dropdown-toggle:not(.disabled)': 'dropdown',
      'click a[href]:not(.disabled)': 'followLink',
      'click .opt-MysqlDump:not(.disabled)': 'mysqlDump',
      'click .opt-MysqlRestore:not(.disabled)': 'mysqlRestore',
      'click .opt-ShowProducts:not(.disabled)': 'showProducts',
      'click .opt-ShowPhotos:not(.disabled)': 'showPhotos',
      'click .opt-ShowPhoto:not(.disabled)': 'showPhoto',
      'click .opt-AutoUpload:not(.disabled)': 'toggleAutoUpload',
      'click .opt-Previous:not(.disabled)': 'back',
      'click .opt-Sidebar:not(.disabled)': 'toggleSidebar',
      'click .opt-FullScreen:not(.disabled)': 'toggleFullScreen',
      'click .opt-CreateCategory:not(.disabled)': 'createCategory',
      'click .opt-CreateProduct:not(.disabled)': 'createProduct',
      'click .opt-DuplicateProducts:not(.disabled)': 'duplicateProducts',
      'click .opt-ToggleVisible:not(.disabled)': 'toggleVisible',
      'click .opt-CopyProductsToNewCategory:not(.disabled)': 'copyProductsToNewCategory',
      'click .opt-CopyPhotosToNewProduct:not(.disabled)': 'copyPhotosToNewProduct',
      'click .opt-CopyPhoto:not(.disabled)': 'copyPhoto',
      'click .opt-CutPhoto:not(.disabled)': 'cutPhoto',
      'click .opt-PastePhoto:not(.disabled)': 'pastePhoto',
      'click .opt-CopyProduct:not(.disabled)': 'copyProduct',
      'click .opt-CutProduct:not(.disabled)': 'cutProduct',
      'click .opt-PasteProduct:not(.disabled)': 'pasteProduct',
      'click .opt-EmptyProduct:not(.disabled)': 'emptyProduct',
      'click .opt-EmptyPhotosTrash:not(.disabled)': 'emptyPhotosTrash',
      'click .opt-EmptyProductsTrash:not(.disabled)': 'emptyProductsTrash',
      'click .opt-IntroQuatsch:not(.disabled)': 'toggleIntroQuatsch',
      'click .opt-CreatePhoto:not(.disabled)': 'createPhoto',
      'click .opt-DestroyEmptyProducts:not(.disabled)': 'destroyEmptyProducts',
      'click .opt-DeleteCategory:not(.disabled)': 'deleteCategory',
      'click .opt-DeleteProduct:not(.disabled)': 'deleteProduct',
      'click .opt-DeletePhoto:not(.disabled)': 'deletePhoto',
      'click .opt-Category:not(.disabled)': 'toggleCategoryShow',
      'click .opt-Rotate-cw:not(.disabled)': 'rotatePhotoCW',
      'click .opt-Rotate-ccw:not(.disabled)': 'rotatePhotoCCW',
      'click .opt-Product:not(.disabled)': 'toggleProductShow',
      'click .opt-Photo:not(.disabled)': 'togglePhotoShow',
      'click .opt-Upload:not(.disabled)': 'toggleUploadShow',
      'click .opt-UploadDialogue:not(.disabled)': 'uploadDialogue',
      'click .opt-ShowOverview:not(.disabled)': 'showOverview',
      'click .opt-ShowCategories:not(.disabled)': 'showCategories',
      'click .opt-ShowAllProducts:not(.disabled)': 'showProductMasters',
      'click .opt-AddProducts:not(.disabled)': 'showProductMastersAdd',
      'click .opt-ShowAllPhotos:not(.disabled)': 'showPhotoMasters',
      'click .opt-AddPhotos:not(.disabled)': 'showPhotoMastersAdd',
      'click .opt-ActionCancel:not(.disabled)': 'cancelAdd',
      'click .opt-ShowPhotoSelection:not(.disabled)': 'showPhotoSelection',
      'click .opt-ShowProductSelection:not(.disabled)': 'showProductSelection',
      'click .opt-SelectAll:not(.disabled)': 'selectAll',
      'click .opt-SelectNone.btn:not(.disabled)': 'selectNone',
      'click .opt-SelectNone:not(.btn):not(.disabled)': 'deselect',
      'click .opt-SelectInv:not(.disabled)': 'selectInv',
      'click .opt-CloseDraghandle:not(.disabled)': 'toggleDraghandle',
      'click .opt-Help:not(.disabled)': 'help',
      'click .opt-Version:not(.disabled)': 'version',
      'click .opt-Prev:not(.disabled)': 'prev',
      'click .opt-ShowProductsTrash:not(.disabled)': 'showProductsTrash',
      'click .opt-ShowPhotosTrash:not(.disabled)': 'showPhotosTrash',
      'click .opt-ShowFavorite:not(.disabled)': 'showFavorite',
      'dblclick .draghandle': 'toggleDraghandle',
      'hidden.bs.modal': 'hiddenmodal',
      'keydown': 'keydown',
      'keyup': 'keyup'
    };

    function ShowView() {
      this.sliderSlide = bind(this.sliderSlide, this);
      this.initSlider = bind(this.initSlider, this);
      ShowView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.silent = true;
      this.toolbarOne = new ToolbarView({
        el: this.toolbarOneEl
      });
      this.toolbarTwo = new ToolbarView({
        el: this.toolbarTwoEl
      });
      this.categoriesHeader = new CategoriesHeader({
        el: this.categoriesHeaderEl
      });
      this.productsHeader = new ProductsHeader({
        el: this.productsHeaderEl,
        parent: this
      });
      this.photosHeader = new PhotosHeader({
        el: this.photosHeaderEl,
        parent: this
      });
      this.photoHeader = new PhotoHeader({
        el: this.photoHeaderEl,
        parent: this
      });
      this.categoriesView = new CategoriesView({
        el: this.categoriesEl,
        assocControl: 'opt-Category',
        header: this.categoriesHeader,
        parent: this
      });
      this.productsView = new ProductsView({
        el: this.productsEl,
        header: this.productsHeader,
        parentModel: Category,
        parent: this
      });
      this.photosView = new PhotosView({
        el: this.photosEl,
        header: this.photosHeader,
        parentModel: Product,
        parent: this
      });
      this.photoView = new PhotoView({
        el: this.photoEl,
        header: this.photoHeader,
        photosView: this.photosView,
        parent: this,
        parentModel: Photo
      });
      this.productsTrashHeader = new ProductsTrashHeader({
        el: this.productsTrashHeaderEl
      });
      this.photosTrashHeader = new PhotosTrashHeader({
        el: this.photosTrashHeaderEl
      });
      this.productsTrashView = new ProductsTrashView({
        el: this.productsTrashEl,
        header: this.productsTrashHeader,
        parent: this
      });
      this.photosTrashView = new PhotosTrashView({
        el: this.photosTrashEl,
        header: this.photosTrashHeader,
        parent: this
      });
      this.productsAddView = new ProductsAddView({
        parent: this.productsView
      });
      this.photosAddView = new PhotosAddView({
        parent: this.photosView
      });
      this.waitView = new WaitView({
        el: this.waitEl,
        parent: this
      });
      this.bind('change:toolbarOne', this.proxy(this.changeToolbarOne));
      this.bind('change:toolbarTwo', this.proxy(this.changeToolbarTwo));
      this.bind('activate:editview', this.proxy(this.activateEditView));
      this.toolbarOne.bind('refresh', this.proxy(this.refreshToolbar));
      this.bind('awake', this.proxy(this.awake));
      this.bind('sleep', this.proxy(this.sleep));
      Category.bind('change:current', this.proxy(this.toggleClassAll));
      Product.bind('change:current', this.proxy(this.toggleClassAll));
      Category.bind('change', this.proxy(this.changeToolbarOne));
      Category.bind('change:selection', this.proxy(this.refreshToolbars));
      Product.bind('change:selection', this.proxy(this.refreshToolbars));
      CategoriesProduct.bind('change', this.proxy(this.refreshToolbars));
      ProductsTrash.bind('change:selection', this.proxy(this.refreshToolbars));
      PhotosTrash.bind('change:selection', this.proxy(this.refreshToolbars));
      CategoriesProduct.bind('error', this.proxy(this.error));
      CategoriesProduct.bind('destroy', this.proxy(this.removeJoinedProductElement));
      ProductsPhoto.bind('destroy', this.proxy(this.removeJoinedPhotoElement));
      ProductsPhoto.bind('error', this.proxy(this.error));
      ProductsPhoto.bind('create destroy', this.proxy(this.refreshToolbars));
      Product.bind('change', this.proxy(this.changeToolbarOne));
      Photo.bind('change', this.proxy(this.changeToolbarOne));
      Photo.bind('refresh', this.proxy(this.refreshToolbars));
      Product.bind('current', this.proxy(this.refreshToolbars));
      Spine.bind('products:copy', this.proxy(this.copyProducts));
      Spine.bind('photos:copy', this.proxy(this.copyPhotos));
      Spine.bind('product:ignore', this.proxy(this.ignoreProduct));
      this.current = this.controller = this.productsView;
      this.sOutValue = 160;
      this.sliderRatio = 50;
      this.thumbSize = 240;
      this.canvasManager = new Spine.Manager(this.categoriesView, this.productsView, this.photosView, this.photoView, this.photosTrashView, this.productsTrashView);
      this.headerManager = new Spine.Manager(this.categoriesHeader, this.productsHeader, this.photosHeader, this.photoHeader, this.photosTrashHeader, this.productsTrashHeader);
      this.canvasManager.bind('change', this.proxy(this.changeCanvas));
      this.headerManager.bind('change', this.proxy(this.changeHeader));
      this.trigger('change:toolbarOne');
      Category.bind('current', this.proxy(this.scrollTo));
      Product.bind('current', this.proxy(this.scrollTo));
      Photo.bind('current', this.proxy(this.scrollTo));
      Model.Settings.bind('change', this.proxy(this.changeSettings));
      Model.Settings.bind('refresh', this.proxy(this.refreshSettings));
    }

    ShowView.prototype.dropdown = function(e) {
      var el;
      el = $(e.target);
      el.dropdown('toggle');
      return e.stopPropagation();
    };

    ShowView.prototype.active = function(controller, params) {
      var ref;
      this.log('active');
      if (controller) {
        controller.trigger('active', params);
        if ((ref = controller.header) != null) {
          ref.trigger('active');
        }
        return this.activated(controller).focus();
      }
    };

    ShowView.prototype.activated = function(controller) {
      var c, p;
      if (!this.current.subview) {
        p = this.previous = this.current;
      }
      c = this.current = this.controller = controller;
      this.currentHeader = controller.header;
      this.prevLocation = location.hash;
      this.el.data('current', {
        model: controller.model,
        models: controller.models
      });
      return this.controller;
    };

    ShowView.prototype.changeCanvas = function(controller, args) {
      return this.transform(controller, this.previous, this.current);
    };

    ShowView.prototype.transform = function(controller, pContr, cContr) {
      var c, cm, e, fadein, i, len, pm, ref;
      try {
        cm = cContr.model.className;
        pm = pContr.model.className;
      } catch (error) {
        e = error;
      }
      this.controllers = (function() {
        var i, len, ref, results;
        ref = this.canvasManager.controllers;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (c !== controller) {
            results.push(c);
          }
        }
        return results;
      }).call(this);
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        $('.items', this.el).removeClass('in3');
      }
      fadein = (function(_this) {
        return function() {
          var viewport;
          viewport = controller.viewport || controller.el;
          return viewport.addClass('in3');
        };
      })(this);
      return window.setTimeout((function(_this) {
        return function() {
          return fadein();
        };
      })(this), 500);
    };

    ShowView.prototype.resetSelection = function(controller) {};

    ShowView.prototype.changeHeader = function(controller) {};

    ShowView.prototype.changeToolbarOne = function(list) {
      this.toolbarOne.change(list);
      this.toolbarTwo.refresh();
      return this.refreshElements();
    };

    ShowView.prototype.changeToolbarTwo = function(list) {
      this.toolbarTwo.change(list);
      return this.refreshElements();
    };

    ShowView.prototype.refreshToolbar = function(toolbar, lastControl) {};

    ShowView.prototype.refreshToolbars = function() {
      this.log('refreshToolbars');
      this.toolbarOne.refresh();
      return this.toolbarTwo.refresh();
    };

    ShowView.prototype.renderViewControl = function(controller) {
      return App[controller].trigger('active');
    };

    ShowView.prototype.createCategory = function(e) {
      Spine.trigger('create:category');
      return e.preventDefault();
    };

    ShowView.prototype.createPhoto = function(e) {
      Spine.trigger('create:photo');
      return e.preventDefault();
    };

    ShowView.prototype.createProduct = function() {
      return Spine.trigger('create:product');
    };

    ShowView.prototype.copyProducts = function(products, category) {
      return Product.trigger('create:join', products, category);
    };

    ShowView.prototype.copyPhotos = function(photos, product) {
      return Photo.trigger('create:join', photos, product);
    };

    ShowView.prototype.copyProductsToNewCategory = function() {
      return this.productsToCategory(Category.selectionList().slice(0));
    };

    ShowView.prototype.copyPhotosToNewProduct = function() {
      return this.photosToProduct(Product.selectionList().slice(0));
    };

    ShowView.prototype.duplicateStart = function() {};

    ShowView.prototype.donecallback = function(rec) {};

    ShowView.prototype.failcallback = function(t) {};

    ShowView.prototype.progresscallback = function(rec) {};

    ShowView.prototype.duplicateProducts = function() {
      this.deferred = $.Deferred();
      return $.when(this.duplicateProductsDeferred()).then(this.donecallback, this.failcallback, this.progresscallback);
    };

    ShowView.prototype.duplicateProductsDeferred = function() {
      var deferred, i, id, len, list;
      deferred = this.deferred || (this.deferred = $.Deferred());
      list = Category.selectionList();
      for (i = 0, len = list.length; i < len; i++) {
        id = list[i];
        this.duplicateProduct(id);
      }
      return deferred.promise();
    };

    ShowView.prototype.duplicateProduct = function(id) {
      var callback, photos, product;
      if (!(product = Product.find(id))) {
        return;
      }
      callback = (function(_this) {
        return function(a, def) {
          return _this.deferred.always(function() {
            return this.log('completed with success ' + a.id);
          });
        };
      })(this);
      photos = product.photos().toId();
      return this.photosToProduct(photos, callback);
    };

    ShowView.prototype.duplicateProduct_new = function(id) {
      var descr, newProduct, options, product, productPhotos, target;
      if (!(product = Product.find(id))) {
        return;
      }
      target = Category.record;
      productPhotos = ProductsPhoto.productsPhotos(product.id);
      descr = product.descriptions();
      options = {
        ajax: false,
        validate: false
      };
      newProduct = product.dup(true, options);
      productPhotos = ProductsPhoto.duplicate(productPhotos, {
        'product_id': newProduct.id
      }, options);
      if (Category.record) {
        Product.createJoin(newProduct, Category.record);
      }
      newProduct.save();
      if (Category.record) {
        Category.record.save();
      }
      return this.log(newProduct);
    };

    ShowView.prototype.productsToCategory = function(products, category) {
      return Spine.trigger('create:category', {
        products: products,
        category: category,
        deleteFromOrigin: false,
        relocate: true
      });
    };

    ShowView.prototype.photosToProduct = function(photos, callback) {
      var target;
      target = Category.record;
      return Spine.trigger('create:product', target, {
        photos: photos,
        deleteFromOrigin: false,
        relocate: true,
        deferred: this.deferred,
        cb: callback
      });
    };

    ShowView.prototype.createProductCopy = function(products, target) {
      var i, id, len, photos;
      if (products == null) {
        products = Category.selectionList();
      }
      if (target == null) {
        target = Category.record;
      }
      this.log('createProductCopy');
      for (i = 0, len = products.length; i < len; i++) {
        id = products[i];
        if (Product.find(id)) {
          photos = Product.photos(id).toId();
          Spine.trigger('create:product', target({
            photos: photos
          }));
        }
      }
      if (target) {
        target.updateSelection(products);
        return this.navigate('/category', target.id);
      } else {
        return this.showProductMasters();
      }
    };

    ShowView.prototype.createProductMove = function(products, target) {
      var i, id, len, photos;
      if (products == null) {
        products = Category.selectionList();
      }
      if (target == null) {
        target = Category.record;
      }
      for (i = 0, len = products.length; i < len; i++) {
        id = products[i];
        if (Product.find(id)) {
          photos = Product.photos(id).toId();
          Spine.trigger('create:product', target({
            photos: photos,
            from: Product.record
          }));
        }
      }
      if (Category.record) {
        return this.navigate('/category', target.id);
      } else {
        return this.showProductMasters();
      }
    };

    ShowView.prototype.removeJoinedProductElement = function(cp) {
      var item;
      if ((item = Product.find(cp.product_id)) && cp.category_id === Category.record.id) {
        return this.controller.remove(item);
      }
    };

    ShowView.prototype.removeJoinedPhotoElement = function(cp) {
      var item;
      if (item = Photo.find(cp.photo_id)) {
        return this.remove(item);
      }
    };

    ShowView.prototype.emptyProduct = function(e) {
      var aid, ap, aps, i, j, len, len1, product, products;
      products = Category.selectionList();
      for (i = 0, len = products.length; i < len; i++) {
        aid = products[i];
        if (product = Product.find(aid)) {
          aps = ProductsPhoto.filter(product.id, {
            associationForeignKey: 'product_id'
          });
          for (j = 0, len1 = aps.length; j < len1; j++) {
            ap = aps[j];
            ap.destroy();
          }
        }
        Product.trigger('change:collection', product);
      }
      return e.preventDefault();
    };

    ShowView.prototype.emptyProductsTrash = function() {
      var items;
      items = Product.filter(true, {
        func: 'selectDeleted'
      });
      return Product.trigger('empty:trash', items);
    };

    ShowView.prototype.emptyPhotosTrash = function() {
      var items;
      items = Photo.filter(true, {
        func: 'selectDeleted'
      });
      return Photo.trigger('empty:trash', items);
    };

    ShowView.prototype.editCategory = function(e) {
      return Spine.trigger('edit:category');
    };

    ShowView.prototype.editProduct = function(e) {
      return Spine.trigger('edit:product');
    };

    ShowView.prototype.destroyEmptyProducts = function(e) {
      var i, len, product, products, results;
      products = Product.findEmpties();
      results = [];
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        results.push(product.destroy());
      }
      return results;
    };

    ShowView.prototype.deleteSelected = function(e) {
      var models;
      this.log('deleteSelected');
      models = this.controller.models;
      return this['delete' + models.className]();
    };

    ShowView.prototype.deleteCategory = function(e) {
      var id, ref;
      if (!(id = (ref = Category.record) != null ? ref.id : void 0)) {
        return;
      }
      return Spine.trigger('delete:category', id);
    };

    ShowView.prototype.deleteProduct = function(e) {
      var model;
      model = App.showView.current.model;
      return Spine.trigger('delete:products', model.selectionList());
    };

    ShowView.prototype.deletePhoto = function(e) {
      var model;
      model = App.showView.current.model;
      return Spine.trigger('delete:photos', model.selectionList());
    };

    ShowView.prototype.toggleCategoryShow = function(e) {
      this.trigger('activate:editview', 'category', e.target);
      return e.preventDefault();
    };

    ShowView.prototype.toggleProductShow = function(e) {
      this.trigger('activate:editview', 'product', e.target);
      this.refreshToolbars();
      return e.preventDefault();
    };

    ShowView.prototype.togglePhotoShow = function(e) {
      this.trigger('activate:editview', 'upload', e.target);
      this.refreshToolbars();
      return e.preventDefault();
    };

    ShowView.prototype.toggleUploadShow = function(e) {
      this.trigger('activate:editview', 'upload', e.target);
      this.refreshToolbars();
      e.preventDefault();
      return e.stopPropagation();
    };

    ShowView.prototype.toggleCategory = function(e) {
      this.changeToolbarOne(['Category']);
      this.refreshToolbars();
      return e.preventDefault();
    };

    ShowView.prototype.toggleProduct = function(e) {
      this.changeToolbarOne(['Product']);
      this.refreshToolbars();
      return e.preventDefault();
    };

    ShowView.prototype.togglePhoto = function(e) {
      this.changeToolbarOne(['Photos', 'Slider']);
      return this.refreshToolbars();
    };

    ShowView.prototype.toggleUpload = function(e) {
      this.changeToolbarOne(['Upload']);
      return this.refreshToolbars();
    };

    ShowView.prototype.toggleSidebar = function() {
      return App.sidebar.toggleDraghandle();
    };

    ShowView.prototype.toggleFullScreen = function() {
      this.toggleFullScreen();
      return this.refreshToolbars();
    };

    ShowView.prototype.toggleFullScreen = function(activate) {
      var isActive, root;
      root = document.documentElement;
      if (activate || !(isActive = this.fullScreenEnabled())) {
        if (root.webkitRequestFullScreen) {
          root.webkitRequestFullScreen(window.Element.ALLOW_KEYBOARD_INPUT);
        } else if (root.mozRequestFullScreen) {
          root.mozRequestFullScreen();
        }
      } else {
        (document.webkitCancelFullScreen || document.mozCancelFullScreen || $.noop).apply(document);
      }
      return this.fullScreenEnabled();
    };

    ShowView.prototype.fullScreenEnabled = function() {
      return !!window.fullScreen;
    };

    ShowView.prototype.toggleDraghandle = function() {
      return this.animateView();
    };

    ShowView.prototype.toggleAutoUpload = function() {
      var active, args, b, settings;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      settings = Model.Settings.loadSettings();
      b = args.length ? args[0] : !settings.autoupload;
      active = settings.autoupload = !!b;
      this.uploader.fileupload('option', 'autoUpload', active);
      settings.save();
      return this.refreshToolbars();
    };

    ShowView.prototype.toggleIntroQuatsch = function(e) {
      var active, b, settings;
      settings = Model.Settings.loadSettings();
      b = !settings.intro;
      active = settings.intro = !!b;
      settings.save();
      return this.refreshToolbars();
    };

    ShowView.prototype.refreshSettings = function(records) {
      var settings;
      if (settings = Model.Settings.loadSettings()) {
        this.changeSettings(settings);
      }
      return this.refreshToolbars();
    };

    ShowView.prototype.changeSettings = function(rec) {
      var active;
      active = rec.autoupload;
      $('#fileupload').fileupload('option', 'autoUpload', active);
      return this.refreshToolbars();
    };

    ShowView.prototype.isAutoUpload = function() {
      return $('#fileupload').fileupload('option', 'autoUpload');
    };

    ShowView.prototype.activateEditView = function(controller) {
      App[controller].trigger('active');
      return this.openView();
    };

    ShowView.prototype.closeView = function() {
      if (!App.hmanager.el.hasClass('open')) {
        return;
      }
      return this.animateView({
        close: true
      });
    };

    ShowView.prototype.openView = function(val) {
      if (val == null) {
        val = '300';
      }
      if (App.hmanager.el.hasClass('open')) {
        return;
      }
      return this.animateView({
        open: val
      });
    };

    ShowView.prototype.animateView = function(options) {
      var height, isOpen, min, speed;
      min = 25;
      options = $().extend({
        open: false
      }, options);
      speed = options.close || options.open ? 800 : 700;
      if (options.open) {
        App.hmanager.el.removeClass('open');
        App.hmanager.el.addClass('forcedopen');
      }
      isOpen = function() {
        return App.hmanager.el.hasClass('open');
      };
      height = function() {
        var h;
        h = !isOpen() ? parseInt(options.open || App.hmanager.currentDim) : parseInt(min);
        return h;
      };
      return this.views.animate({
        height: height() + 'px'
      }, speed, function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if ($(this).height() === min) {
          return $(this).removeClass('open forcedopen');
        } else {
          return $(this).addClass('open');
        }
      });
    };

    ShowView.prototype.awake = function() {
      return this.views.addClass('open');
    };

    ShowView.prototype.sleep = function() {
      return this.animateView();
    };

    ShowView.prototype.openPanel = function(controller) {
      var ui;
      if (this.views.hasClass('open')) {
        return;
      }
      App[controller].deactivate();
      ui = App.hmanager.externalClass(App[controller]);
      return ui.click();
    };

    ShowView.prototype.closePanel = function(controller, target) {
      App[controller].trigger('active');
      return target.click();
    };

    ShowView.prototype.deselect = function(e) {
      var model;
      model = this.current.model;
      if (model) {
        return model.updateSelection([]);
      }
    };

    ShowView.prototype.selectNone = function(e) {};

    ShowView.prototype.selectAll = function(e) {
      var list;
      try {
        list = this.all();
        return this.current.select(e, list);
      } catch (error) {
        e = error;
      }
    };

    ShowView.prototype.selectInv = function(e) {
      var list, selList;
      try {
        list = this.all();
        selList = this.current.model.selectionList();
        list.addRemove(selList);
        return this.current.select(e, list);
      } catch (error) {
        e = error;
      }
    };

    ShowView.prototype.all = function() {
      var items, list, root;
      list = [];
      root = $('.items', this.current.el);
      items = $('.item', root);
      items.each(function() {
        return list.unshift(this.id);
      });
      return list;
    };

    ShowView.prototype.uploadProgress = function(e, coll) {};

    ShowView.prototype.uploadDone = function(e, coll) {};

    ShowView.prototype.sliderInValue = function(val) {
      val = val || this.sOutValue;
      return this.sInValue = (val / 2) - this.sliderRatio;
    };

    ShowView.prototype.sliderOutValue = function(value) {
      var val;
      val = value || this.slider.slider('value');
      return this.sOutValue = (val + this.sliderRatio) * 2;
    };

    ShowView.prototype.initSlider = function() {
      var inValue;
      inValue = this.sliderInValue();
      this.refreshElements();
      return this.slider.slider({
        orientation: 'horizonatal',
        value: inValue,
        slide: (function(_this) {
          return function(e, ui) {
            return _this.sliderSlide(ui.value);
          };
        })(this)
      });
    };

    ShowView.prototype.sliderSlide = function(val) {
      var newVal;
      newVal = this.sliderOutValue(val);
      Spine.trigger('slider:change', newVal);
      return newVal;
    };

    ShowView.prototype.toggleClassAll = function(record, classname) {
      var b, el;
      el = $('[data-model-name=' + classname + ']', this.el);
      b = !Model[classname].record;
      return el.toggleClass('all', b);
    };

    ShowView.prototype.toggleVisible = function(e, list) {
      var ga, i, id, len, ref, results;
      if (list == null) {
        list = Category.selectionList();
      }
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        id = list[i];
        ga = CategoriesProduct.productExists(id, (ref = Category.record) != null ? ref.id : void 0);
        ga.ignored = !ga.ignored;
        results.push(ga.save());
      }
      return results;
    };

    ShowView.prototype.showProductsTrash = function() {
      return this.navigate('/trash/products', '');
    };

    ShowView.prototype.showPhotosTrash = function() {
      return this.navigate('/trash/photos', '');
    };

    ShowView.prototype.showCategories = function() {
      var cid, ref;
      return this.navigate('/category', cid = (cid = (ref = Category.record) != null ? ref.id : void 0) ? 'cid/' + cid : null);
    };

    ShowView.prototype.showProductMasters = function() {
      return this.navigate('/category', '');
    };

    ShowView.prototype.showPhotoMasters = function() {
      return this.navigate('/category', '/');
    };

    ShowView.prototype.showProducts = function(e) {
      var cid, pid, ref, ref1;
      this.navigate('/category', cid = ((ref = Category.record) != null ? ref.id : void 0) || '', pid = (pid = (ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) ? 'pid/' + pid : null);
      return e.preventDefault();
    };

    ShowView.prototype.showPhotos = function(e) {
      var iid, ref, ref1, ref2;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', iid = (iid = (ref2 = Product.record) != null ? typeof ref2.selectionList === "function" ? ref2.selectionList().first() : void 0 : void 0) ? 'iid/' + iid : null);
      return e.preventDefault();
    };

    ShowView.prototype.showPhoto = function(e) {
      var ref, ref1, ref2;
      this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', ((ref1 = Category.record) != null ? typeof ref1.selectionList === "function" ? ref1.selectionList().first() : void 0 : void 0) || '', ((ref2 = Product.record) != null ? typeof ref2.selectionList === "function" ? ref2.selectionList().first() : void 0 : void 0) || '');
      return e.preventDefault();
    };

    ShowView.prototype.showOverview = function() {
      return this.navigate('/overview', '');
    };

    ShowView.prototype.showProductMastersAdd = function(e) {
      e.preventDefault();
      return Spine.trigger('products:add');
    };

    ShowView.prototype.showPhotoMastersAdd = function(e) {
      e.preventDefault();
      return Spine.trigger('photos:add');
    };

    ShowView.prototype.showProductSelection = function() {
      return this.navigate('/category', Category.record.id || '');
    };

    ShowView.prototype.showPhotoSelection = function() {
      if (Category.record) {
        return this.navigate('/category', Category.record.id, Category.selectionList()[0] || '');
      } else {
        return this.navigate('/category', '', Category.selectionList()[0] || '');
      }
    };

    ShowView.prototype.cancelAdd = function(e) {
      this.back();
      App.sidebar.filter();
      this.el.removeClass('add');
      return e.preventDefault();
    };

    ShowView.prototype.copy = function(e) {
      var model;
      model = this.current.models.className;
      switch (model) {
        case 'Photo':
          return this.copyPhoto();
        case 'Product':
          return this.copyProduct();
      }
    };

    ShowView.prototype.cut = function(e) {
      var model;
      model = this.current.models.className;
      switch (model) {
        case 'Photo':
          return this.cutPhoto();
        case 'Product':
          return this.cutProduct();
      }
    };

    ShowView.prototype.paste = function(e) {
      var first, model;
      if (!(first = Clipboard.first())) {
        return;
      }
      model = first.item.constructor.className;
      switch (model) {
        case 'Photo':
          return this.pastePhoto();
        case 'Product':
          return this.pasteProduct();
      }
    };

    ShowView.prototype.copyPhoto = function() {
      var i, id, len, ref;
      Clipboard.deleteAll();
      ref = Product.selectionList();
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        Clipboard.create({
          item: Photo.find(id),
          type: 'copy'
        });
      }
      return this.refreshToolbars();
    };

    ShowView.prototype.cutPhoto = function() {
      var i, id, len, ref;
      Clipboard.deleteAll();
      ref = Product.selectionList();
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        Clipboard.create({
          item: Photo.find(id),
          type: 'copy',
          cut: Product.record
        });
      }
      return this.refreshToolbars();
    };

    ShowView.prototype.pastePhoto = function() {
      var callback, clb, clipboard, i, items, len, product;
      if (!(product = Product.record)) {
        return;
      }
      clipboard = Clipboard.findAllByAttribute('type', 'copy');
      items = [];
      for (i = 0, len = clipboard.length; i < len; i++) {
        clb = clipboard[i];
        items.push(clb.item);
      }
      callback = (function(_this) {
        return function() {
          var cut, options, origin;
          cut = Clipboard.last().cut;
          origin = Clipboard.last().origin;
          if (cut) {
            Clipboard.destroyAll();
            options = {
              photos: items,
              product: cut
            };
            Photo.trigger('destroy:join', options);
          }
          return _this.refreshToolbars();
        };
      })(this);
      return Photo.trigger('create:join', items, product, callback);
    };

    ShowView.prototype.rotatePhotoCW = function(e) {
      Spine.trigger('rotate', false, -90);
      this.refreshToolbars();
      return false;
    };

    ShowView.prototype.rotatePhotoCCW = function(e) {
      Spine.trigger('rotate', false, 90);
      this.refreshToolbars();
      return false;
    };

    ShowView.prototype.copyProduct = function() {
      var i, item, len, ref;
      Clipboard.deleteAll();
      ref = Category.selectionList();
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        Clipboard.create({
          item: Product.find(item),
          type: 'copy'
        });
      }
      return this.refreshToolbars();
    };

    ShowView.prototype.cutProduct = function() {
      var i, id, len, ref;
      Clipboard.deleteAll();
      ref = Category.selectionList();
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        Clipboard.create({
          item: Product.find(id),
          type: 'copy',
          cut: Category.record
        });
      }
      return this.refreshToolbars();
    };

    ShowView.prototype.error = function(record, err) {
      return alert(err);
    };

    ShowView.prototype.pasteProduct = function() {
      var callback, category, clb, clipboard, i, items, len;
      if (!(category = Category.record)) {
        return;
      }
      clipboard = Clipboard.findAllByAttribute('type', 'copy');
      callback = (function(_this) {
        return function() {
          var cut, origin;
          cut = Clipboard.last().cut;
          origin = Clipboard.last().origin;
          if (cut) {
            Clipboard.deleteAll();
            Product.trigger('destroy:join', items, cut);
          }
          return _this.refreshToolbars();
        };
      })(this);
      items = [];
      for (i = 0, len = clipboard.length; i < len; i++) {
        clb = clipboard[i];
        items.push(clb.item);
      }
      return Product.trigger('create:join', items, category, callback);
    };

    ShowView.prototype.ignoreProduct = function(product, category) {
      var categoryId, ga, itemId, newIgnored;
      if (!category) {
        return;
      }
      itemId = product.id;
      categoryId = category.id;
      if (ga = CategoriesProduct.productExists(itemId, categoryId)) {
        newIgnored = !ga.ignored;
        if (product.favorite && newIgnored) {
          App.confirm('NO_IGNORE_FOR_FAVORITE', {
            mode: 'alert'
          });
          return;
        }
        return CategoriesProduct.trigger('ignored', ga, newIgnored);
      }
    };

    ShowView.prototype.help = function(e) {
      var carouselOptions, dialog, options;
      carouselOptions = {
        id: 'help-carousel',
        interval: 1000,
        slides: [
          {
            img: "/img/keyboard.png",
            width: '700px'
          }, {
            items: [
              'Abschnitt 1', {
                items: ['Abschnitt 1.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 2', {
                items: ['Abschnitt 2.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 3', {
                items: ['Abschnitt 3.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 4', {
                items: ['Abschnitt 4.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 5', {
                items: ['Abschnitt 5.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 6', {
                items: ['Abschnitt 6.1']
              }
            ]
          }, {
            items: [
              'Abschnitt 7', {
                items: ['Abschnitt 7.1']
              }
            ]
          }, {
            items: ['Abschnitt 1']
          }
        ]
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: true
        }
      });
      options = {
        small: false,
        header: 'TastaturBefehle',
        body: function() {
          return require("views/carousel")(carouselOptions);
        },
        footerButtonText: 'Close'
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      return dialog.show(options);
    };

    ShowView.prototype.version = function(e) {
      var dialog;
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: {
          small: true,
          header: '',
          body: function() {
            return require("views/version")({
              copyright: 'Axel Nitzschner',
              spine_version: Spine.version,
              app_version: App.version,
              bs_version: $.fn.tooltip.Constructor.VERSION
            });
          },
          footer: ''
        }
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      return dialog.show();
    };

    ShowView.prototype.hidemodal = function(e) {
      return this.log('hidemodal');
    };

    ShowView.prototype.hiddenmodal = function(e) {
      this.log('hiddenmodal');
      return App.modal.exists = false;
    };

    ShowView.prototype.showmodal = function(e) {
      this.log('showmodal');
      return App.modal.exists = true;
    };

    ShowView.prototype.shownmodal = function(e) {
      return this.log('shownmodal');
    };

    ShowView.prototype.uploadDialogue = function(e) {
      this.toggleUploadShow(e);
      return $('input', '#fu').click();
    };

    ShowView.prototype.showFavorite = function(e) {
      var url;
      if (!(url = Product.getFavoriteUrl())) {
        return;
      }
      this.navigate(url);
      this.refreshToolbars();
      e.preventDefault();
      return e.stopPropagation();
    };

    ShowView.prototype.selectByKey = function(e, direction) {
      var active, activeEl, el, elements, first, id, index, isMeta, last, lastIndex, list, models, next, parent, prev, record, ref, selection;
      isMeta = e.metaKey || e.ctrlKey || e.shiftKey;
      index = null;
      lastIndex = null;
      list = ((ref = this.controller.list) != null ? ref.listener : void 0) || this.controller.list;
      elements = list ? $('.item', list.el) : $();
      if (!elements.length) {
        return;
      }
      models = this.controller.models;
      parent = this.controller.model;
      record = models.record;
      activeEl = list.findModelElement(record) || $();
      elements.each((function(_this) {
        return function(idx, el) {
          lastIndex = idx;
          if ($(el).is(activeEl)) {
            return index = idx;
          }
        };
      })(this));
      last = elements[lastIndex] || false;
      if (index == null) {
        prev = next = first = elements[0] || false;
      } else if (isMeta) {
        active = elements[index];
        first = elements[0] || false;
        prev = elements[index - 1] || false;
        next = elements[index + 1] || false;
      } else {
        first = elements[0] || false;
        prev = elements[index - 1] || elements[index] || false;
        next = elements[index + 1] || elements[index] || false;
      }
      switch (direction) {
        case 'left':
          el = $(prev);
          break;
        case 'up':
          el = $(first);
          break;
        case 'right':
          el = $(next);
          break;
        case 'down':
          el = $(last);
      }
      id = el.attr('data-id');
      if (!isMeta) {
        selection = parent.selectionList().slice(0);
        if (indexOf.call(selection, id) < 0) {
          selection.addRemove(id);
        } else {
          first = selection.first();
          selection.addRemove(id);
          selection.addRemove(first);
          selection.addRemove(id);
        }
        return list.parent.select(e, selection);
      } else {
        return list.parent.select(e, [id]);
      }
    };

    ShowView.prototype.scrollTo = function(item) {
      var dht, e, el, marginBottom, marginTop, ohc, ohp, otc, otp, outOfMaxRange, outOfMinRange, outOfRange, parentEl, res, resMax, resMin, stp;
      Spine.trigger('scroll', item);
      if (!(this.controller.isActive() && item)) {
        return;
      }
      if (item.constructor.className !== this.controller.models.className) {
        return;
      }
      try {
        el = this.controller.list.findModelElement(item) || $();
        if (!el.length) {
          return;
        }
        parentEl = el.parent();
      } catch (error) {
        e = error;
        return;
      }
      marginTop = 55;
      marginBottom = 10;
      ohc = el[0].offsetHeight;
      otc = el.offset().top;
      stp = parentEl[0].scrollTop;
      otp = parentEl.offset().top;
      ohp = parentEl[0].offsetHeight;
      dht = parentEl[0].scrollHeight;
      resMin = stp + otc - (otp + marginTop);
      resMax = stp + otc - (otp + ohp - ohc - marginBottom);
      outOfRange = stp > resMin || stp < resMax;
      if (!outOfRange) {
        return;
      }
      outOfMinRange = stp > resMin;
      outOfMaxRange = stp < resMax;
      res = outOfMinRange ? resMin : outOfMaxRange ? resMax : void 0;
      if (Math.abs(res - stp) <= ohc / 2) {
        return;
      }
      return parentEl.animate({
        scrollTop: res
      }, {
        queue: false,
        duration: 'slow',
        done: (function(_this) {
          return function() {};
        })(this)
      });
    };

    ShowView.prototype.zoom = function(e) {
      var base, ref;
      ((ref = this.controller.list) != null ? typeof ref.zoom === "function" ? ref.zoom(e) : void 0 : void 0) || (typeof (base = this.controller).zoom === "function" ? base.zoom(e) : void 0);
      return e.preventDefault();
    };

    ShowView.prototype.back = function(e) {
      var base, ref;
      return ((ref = this.controller.list) != null ? ref.back(e) : void 0) || (typeof (base = this.controller).back === "function" ? base.back(e) : void 0);
    };

    ShowView.prototype.prev = function(e) {
      history.back();
      return e.preventDefault();
    };

    ShowView.prototype.mysqlDump = function() {
      var options;
      options = {
        done: (function(_this) {
          return function(xhr) {
            return setTimeout(function() {
              return Spine.trigger('done:wait');
            }, 5000, xhr);
          };
        })(this),
        fail: function(e) {}
      };
      Spine.trigger('show:wait', {
        small: true,
        header: false,
        body: 'Datensicherung luft...',
        footer: false
      });
      return this.mysql('dump', options);
    };

    ShowView.prototype.mysqlRestore = function() {
      var options;
      options = {
        done: (function(_this) {
          return function(xhr) {
            return setTimeout(function() {
              Spine.trigger('done:wait');
              return Spine.trigger('refresh:all');
            }, 5000, xhr);
          };
        })(this),
        fail: function(e) {}
      };
      Spine.trigger('show:wait', {
        small: true,
        header: false,
        body: 'Wiederherstellung luft...',
        footer: false
      });
      return this.mysql('restore', options);
    };

    ShowView.prototype.keydown = function(e) {
      var code, el, isFormfield;
      code = e.charCode || e.keyCode;
      el = $(document.activeElement);
      return isFormfield = $().isFormElement(el);
    };

    ShowView.prototype.keyup = function(e) {
      var code, el, isFormfield, photos;
      code = e.charCode || e.keyCode;
      el = $(document.activeElement);
      isFormfield = $().isFormElement(el);
      switch (code) {
        case 8:
          if (!isFormfield) {
            this.deleteSelected(e);
            return e.preventDefault();
          }
          break;
        case 13:
          if (!isFormfield) {
            this.zoom(e);
            return e.preventDefault();
          }
          break;
        case 27:
          if (!(isFormfield || App.modal.exists)) {
            this.back(e);
            return e.preventDefault();
          }
          break;
        case 32:
          if (!isFormfield) {
            photos = App.activePhotos();
            return e.preventDefault();
          }
          break;
        case 37:
          if (!isFormfield) {
            this.selectByKey(e, 'left');
            return e.preventDefault();
          }
          break;
        case 38:
          if (!isFormfield) {
            this.selectByKey(e, 'up');
            return e.preventDefault();
          }
          break;
        case 39:
          if (!isFormfield) {
            this.selectByKey(e, 'right');
            return e.preventDefault();
          }
          break;
        case 40:
          if (!isFormfield) {
            this.selectByKey(e, 'down');
            return e.preventDefault();
          }
          break;
        case 65:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.selectAll(e);
            }
          }
          break;
        case 67:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.copy(e);
            }
          }
          break;
        case 73:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.selectInv(e);
            }
          }
          break;
        case 77:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.toggleVisible(e);
            }
          }
          break;
        case 86:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.paste(e);
            }
          }
          break;
        case 88:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return this.cut(e);
            }
          }
          break;
        case 82:
          if (!isFormfield) {
            if (e.metaKey || e.ctrlKey) {
              return Spine.trigger('rotate', false, -90);
            }
          }
      }
    };

    return ShowView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ShowView;
  }

}).call(this);
 },"controllers/sidebar": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Drag, Extender, Photo, Product, ProductsPhoto, RefreshView, Root, Sidebar, SidebarList, Spine, SpineDragItem, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  Root = require('models/root');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  User = require("models/user");

  Drag = require('extensions/drag');

  SidebarList = require('controllers/sidebar_list');

  RefreshView = require('controllers/refresh_view');

  Extender = require('extensions/controller_extender');

  SpineDragItem = require('models/drag_item');

  Sidebar = (function(superClass) {
    extend(Sidebar, superClass);

    Sidebar.extend(Drag);

    Sidebar.extend(Extender);

    Sidebar.prototype.elements = {
      'form': 'form',
      'input.search-query': 'input',
      '.flickr': 'flickr',
      '.items': 'items',
      '.inner': 'inner',
      '.droppable': 'droppable',
      '.expander': 'expander',
      '#refresh': 'refreshEl'
    };

    Sidebar.prototype.events = {
      'click .clear-search': 'clearSearch',
      'keyup input': 'filter',
      'click .opt-CreateProduct': 'createProduct',
      'click .opt-CreateCategory': 'createCategory',
      'dblclick .draghandle': 'toggleDraghandle',
      'sortupdate .sublist': 'sortupdate',
      'dragstart  .alb.item': 'dragstart',
      'dragover   .gal.item': 'dragover',
      'dragenter  .gal.item': 'dragenter',
      'dragenter  .alb.item': 'dragenter',
      'dragleave  .gal.item': 'dragleave',
      'dragleave  .alb.item': 'dragleave',
      'dragend    .gal.item': 'dragend',
      'dragend    .alb.item': 'dragend',
      'drop       .gal.item': 'drop',
      'drop       .alb.item': 'drop'
    };

    Sidebar.prototype.categoryTemplate = function(items) {
      return $("#sidebarTemplate").tmpl(items);
    };

    function Sidebar() {
      Sidebar.__super__.constructor.apply(this, arguments);
      this.el.width(8);
      this.defaultTemplate = this.categoryTemplate;
      this.list = new SidebarList({
        el: this.items,
        template: this.categoryTemplate,
        parent: this
      });
      this.refreshView = new RefreshView({
        el: this.refreshEl
      });
      Category.one('refresh', this.proxy(this.refresh));
      Category.bind('error', this.proxy(this.error));
      Category.bind('update', this.proxy(this.render));
      Category.bind("ajaxError", Category.errorHandler);
      Category.bind("ajaxSuccess", Category.successHandler);
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
      Spine.bind('create:category', this.proxy(this.createCategory));
      Spine.bind('edit:category', this.proxy(this.edit));
      Spine.bind('delete:category', this.proxy(this.deleteCategory));
      this.bind('drag:timeout', this.proxy(this.expandAfterTimeout));
      this.bind('drag:help', this.proxy(this.dragHelp));
      this.bind('drag:start', this.proxy(this.dragStart));
      this.bind('drag:enter', this.proxy(this.dragEnter));
      this.bind('drag:over', this.proxy(this.dragOver));
      this.bind('drag:leave', this.proxy(this.dragLeave));
      this.bind('drag:drop', this.proxy(this.dragDrop));
      this.model = this.defaultModel = 'Category';
    }

    Sidebar.prototype.filter = function(e, qry) {
      if (qry) {
        this.input.val(qry);
      }
      this.query = this.input.val() || qry;
      return this.render();
    };

    Sidebar.prototype.refresh = function(items) {
      return this.render();
    };

    Sidebar.prototype.refreshOne = function() {
      return Category.one('refresh', this.proxy(this.refresh));
    };

    Sidebar.prototype.render = function() {
      var cat, items, j, k, len, len1, pro, ref, ref1;
      this.log('render');
      this.products = Product.filter(this.query, {
        func: 'searchSelect'
      });
      if (this.query) {
        items = [];
        ref = this.products;
        for (j = 0, len = ref.length; j < len; j++) {
          pro = ref[j];
          ref1 = CategoriesProduct.categories(pro.id);
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            cat = ref1[k];
            items.push(cat);
          }
        }
      } else {
        items = Category.filter(this.query, {
          func: 'searchSelect'
        });
      }
      this.list.render(items);
      return this.refreshView.render();
    };

    Sidebar.prototype.newAttributes = function() {
      if (User.first()) {
        return {
          screenname: this.categoryName(),
          author: User.first().name,
          user_id: User.first().id
        };
      } else {
        return User.ping();
      }
    };

    Sidebar.prototype.categoryName = function(proposal) {
      if (proposal == null) {
        proposal = 'Category ' + (function() {
          var i, index, s;
          s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
          index = (i = Category.count() + 1) < s.length ? i : i % s.length;
          return s.split('')[index];
        })();
      }
      Category.each((function(_this) {
        return function(record) {
          if (record.name === proposal) {
            return proposal = _this.categoryName(proposal + proposal.split(' ')[1][0]);
          }
        };
      })(this));
      return proposal;
    };

    Sidebar.prototype.createCategory = function(options) {
      var category, cb;
      if (options == null) {
        options = {};
      }
      this.log('createCategory');
      cb = function(category) {
        category.updateSelectionID();
        Root.updateSelection([category.id]);
        if (options.products) {
          Product.trigger('create:join', options.products, category);
          if (options.deleteFromOrigin) {
            return Product.trigger('destroy:join', options.products, options.deleteFromOrigin);
          }
        }
      };
      category = new Category(this.newAttributes());
      category.one('ajaxSuccess', this.proxy(cb));
      return category.save(options);
    };

    Sidebar.prototype.error = function(item, err) {
      return alert(err);
    };

    Sidebar.prototype.createProduct = function() {
      return Spine.trigger('create:product');
    };

    Sidebar.prototype.deleteCategory = function(id) {
      var category;
      if (!(category = Category.find(id))) {
        return;
      }
      if (category.isValid()) {
        if (App.confirm('DESTROY_CATEGORY', this.humanize(category))) {
          return category.destroy();
        }
      } else {
        return App.confirm('DESTROY_CATEGORY_NOT_ALLOWED', {
          mode: 'alert'
        });
      }
    };

    Sidebar.prototype.clearSearch = function() {
      $(this.input).val('');
      return this.filter();
    };

    Sidebar.prototype.edit = function() {
      App.categoryEditView.render();
      return App.contentManager.change(App.categoryEditView);
    };

    Sidebar.prototype.toggleDraghandle = function(options) {
      var speed, w, width;
      width = (function(_this) {
        return function() {
          var max, w;
          max = App.vmanager.currentDim;
          w = _this.el.width();
          if (App.vmanager.sleep) {
            App.vmanager.awake();
            _this.clb = function() {};
            return max + "px";
          } else {
            _this.clb = App.vmanager.goSleep;
            return '20px';
          }
        };
      })(this);
      w = width();
      speed = 700;
      return this.el.animate({
        width: w
      }, speed, (function(_this) {
        return function() {
          return _this.clb();
        };
      })(this));
    };

    Sidebar.prototype.expandAfterTimeout = function(e, timer) {
      var categoryEl, item, ref;
      clearTimeout(timer);
      categoryEl = $(e.target).closest('.gal.item');
      item = categoryEl.item();
      if (!(item && item.id !== ((ref = Spine.dragItem.originModelName.record) != null ? ref.id : void 0))) {
        return;
      }
      return this.list.expand(item, true);
    };

    Sidebar.prototype.sortupdate = function(e, o) {
      var category, gas, list;
      list = o.item.parent();
      category = list.parent().item();
      gas = CategoriesProduct.filter(category.id, {
        associationForeignKey: 'category_id'
      });
      list.children().each(function(index) {
        var ga, j, len, product, results;
        product = $(this).item();
        results = [];
        for (j = 0, len = gas.length; j < len; j++) {
          ga = gas[j];
          if (ga.product_id === product.id && parseInt(ga.order) !== index) {
            ga.order = index;
            results.push(ga.silentUpdate());
          } else {
            results.push(void 0);
          }
        }
        return results;
      });
      category.save({
        validate: false
      });
      return Spine.trigger('reorder', category);
    };

    return Sidebar;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Sidebar;
  }

}).call(this);
 },"controllers/sidebar_flickr": function(exports, require, module) { (function() {
  var $, Extender, SidebarFlickr, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  SidebarFlickr = (function(superClass) {
    extend(SidebarFlickr, superClass);

    SidebarFlickr.extend(Extender);

    SidebarFlickr.prototype.elements = {
      '.items': 'items',
      '.inner': 'inner',
      '.expander': 'expander'
    };

    SidebarFlickr.prototype.events = {
      'click      .expander': 'expand',
      'click      .opt-flickr': 'expand',
      'click      .opt-FlickrRecent': 'navRecent',
      'click      .opt-FlickrInter': 'navInter'
    };

    SidebarFlickr.prototype.template = function(items) {
      return $("#sidebarFlickrTemplate").tmpl(items);
    };

    function SidebarFlickr() {
      SidebarFlickr.__super__.constructor.apply(this, arguments);
      this.render();
    }

    SidebarFlickr.prototype.render = function() {
      var items;
      this.log('render');
      items = {
        name: 'flickr',
        sub: [
          {
            name: 'Recent Photos',
            klass: 'opt-FlickrRecent',
            icon: 'picture'
          }, {
            name: 'Interesting Stuff',
            klass: 'opt-FlickrInter',
            icon: 'picture'
          }
        ]
      };
      return this.html(this.template(items));
    };

    SidebarFlickr.prototype.expand = function(e) {
      var parent;
      parent = $(e.target).closest('li');
      parent.toggleClass('open');
      if (parent.hasClass('open')) {
        this.navigate('/flickr/');
      }
      e.stopPropagation();
      return e.preventDefault();
    };

    SidebarFlickr.prototype.navRecent = function(e) {
      this.log('flickr recent clicked');
      this.navigate('/flickr', 'recent/1');
      e.stopPropagation();
      return e.preventDefault();
    };

    SidebarFlickr.prototype.navInter = function(e) {
      this.log('flickr interesting clicked');
      this.navigate('/flickr', 'inter/1');
      e.stopPropagation();
      return e.preventDefault();
    };

    return SidebarFlickr;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SidebarFlickr;
  }

}).call(this);
 },"controllers/sidebar_list": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Drag, Extender, Product, ProductsPhoto, Root, SidebarList, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Root = require("models/root");

  Product = require('models/product');

  Category = require('models/category');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  Drag = require('extensions/drag');

  Extender = require('extensions/controller_extender');

  require('extensions/tmpl');

  SidebarList = (function(superClass) {
    extend(SidebarList, superClass);

    SidebarList.extend(Drag);

    SidebarList.extend(Extender);

    SidebarList.prototype.elements = {
      '.gal.item': 'item'
    };

    SidebarList.prototype.events = {
      'click .opt-ignored': 'ignoreProduct',
      "click      .item": 'click',
      "click      .expander": 'clickExpander'
    };

    SidebarList.prototype.selectFirst = true;

    SidebarList.prototype.contentTemplate = function(items) {
      return $('#sidebarContentTemplate').tmpl(items);
    };

    SidebarList.prototype.sublistTemplate = function(items) {
      return $('#productsSublistTemplate').tmpl(items);
    };

    SidebarList.prototype.ctaTemplate = function(item) {
      return $('#ctaTemplate').tmpl(item);
    };

    function SidebarList() {
      this.change = bind(this.change, this);
      SidebarList.__super__.constructor.apply(this, arguments);
      CategoriesProduct.bind('update', this.proxy(this.renderItemFromCategoriesProduct));
      Category.bind('change:collection', this.proxy(this.renderCategory));
      Category.bind('change', this.proxy(this.change));
      Category.bind('change:selection', this.proxy(this.exposeSublistSelection));
      Category.bind('current', this.proxy(this.exposeSelection));
      Product.bind('change:collection', this.proxy(this.renderProduct));
      Product.bind('create destroy update', this.proxy(this.renderSublists));
      Root.bind('change:selection', this.proxy(this.closeAllOtherSublists));
      Spine.bind('scroll', this.proxy(this.scrollTo));
    }

    SidebarList.prototype.template = function() {
      return arguments[0];
    };

    SidebarList.prototype.change = function(item, mode, e) {
      this.log('change');
      switch (mode) {
        case 'create':
          this.current = item;
          this.create(item);
          return this.navigate('/category', item.id);
        case 'update':
          this.current = item;
          return this.update(item);
        case 'destroy':
          this.current = null;
          return this.destroy(item);
      }
    };

    SidebarList.prototype.create = function(item) {
      this.append(this.template(item));
      this.renderOneSublist(item);
      return this.reorder(item);
    };

    SidebarList.prototype.update = function(item) {
      this.updateTemplate(item);
      return this.reorder(item);
    };

    SidebarList.prototype.destroy = function(item) {
      return this.children().forItem(item, true).detach();
    };

    SidebarList.prototype.render = function(items, mode) {
      var categoryEl, item, j, len;
      this.children().addClass('invalid');
      for (j = 0, len = items.length; j < len; j++) {
        item = items[j];
        categoryEl = this.children().forItem(item);
        if (!categoryEl.length) {
          this.append(this.template(item));
          this.reorder(item);
        } else {
          this.updateTemplate(item).removeClass('invalid');
          this.reorder(item);
        }
        this.renderOneSublist(item);
      }
      return this.children('.invalid').remove();
    };

    SidebarList.prototype.reorder = function(item) {
      var children, id, idxAfterSort, idxBeforeSort, index, newEl, oldEl;
      this.log('reorder');
      id = item.id;
      index = function(id, list) {
        var i, itm, j, len;
        for (i = j = 0, len = list.length; j < len; i = ++j) {
          itm = list[i];
          if (itm.id === id) {
            return i;
          }
        }
        return i;
      };
      children = this.children();
      oldEl = this.children().forItem(item);
      idxBeforeSort = this.children().index(oldEl);
      idxAfterSort = index(id, Category.all().sort(Category.sortByOrder));
      newEl = $(children[idxAfterSort]);
      if (idxBeforeSort < idxAfterSort) {
        return newEl.after(oldEl);
      } else if (idxBeforeSort > idxAfterSort) {
        return newEl.before(oldEl);
      }
    };

    SidebarList.prototype.updateSublist = function(ga) {
      var category;
      category = Category.find(ga.category_id);
      return this.renderOneSublist(category);
    };

    SidebarList.prototype.renderAllSublist = function() {
      var gal, index, j, len, ref, results;
      this.log('renderAllSublist');
      ref = Category.records;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        gal = ref[index];
        results.push(this.renderOneSublist(gal));
      }
      return results;
    };

    SidebarList.prototype.renderSublists = function(product) {
      var category, ga, gas, j, len, results;
      this.log('renderSublists');
      gas = CategoriesProduct.filter(product.id, {
        associationForeignKey: 'product_id'
      });
      results = [];
      for (j = 0, len = gas.length; j < len; j++) {
        ga = gas[j];
        if (category = Category.find(ga['category_id'])) {
          results.push(this.renderOneSublist(category));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    SidebarList.prototype.renderFromCategoriesProduct = function(ga) {
      var category;
      this.log('renderFromCategoriesProduct');
      if (category = Category.find(ga['category_id'])) {
        return this.updateTemplate(category);
      }
    };

    SidebarList.prototype.renderOneSublist = function(category) {
      var categoryEl, categorySublist, filterOptions, products;
      if (category == null) {
        category = Category.record;
      }
      this.log('renderOneSublist');
      filterOptions = {
        model: 'Category'
      };
      products = Category.products(category.id, filterOptions).filter(this.p());
      if (!products.length) {
        products.push({
          flash: 'keine Produkte'
        });
      }
      categoryEl = this.children().forItem(category);
      categorySublist = $('ul', categoryEl);
      categorySublist.html(this.sublistTemplate(products));
      $(categorySublist).sortable({
        items: ':not(.disabled)'
      });
      return this.exposeSublistSelection(null, category.id);
    };

    SidebarList.prototype.updateTemplate = function(item) {
      var innerEl, itemEl, tmplItem;
      itemEl = this.children().forItem(item);
      innerEl = $('.item-content', itemEl);
      tmplItem = innerEl.tmplItem();
      tmplItem.data = item;
      if (typeof tmplItem.update === "function") {
        tmplItem.update();
      }
      itemEl.attr('id', item.id);
      return itemEl;
    };

    SidebarList.prototype.renderItemFromCategoriesProduct = function(ga, mode) {
      var category;
      category = Category.find(ga.category_id);
      if (category) {
        this.updateTemplate(category);
        return this.renderOneSublist(category);
      }
    };

    SidebarList.prototype.renderCategory = function(item) {
      this.updateTemplate(item);
      return this.renderOneSublist(item);
    };

    SidebarList.prototype.renderProduct = function(item) {
      var category, ga, gas, j, len, results;
      gas = CategoriesProduct.filter(item.id, {
        associationForeignKey: 'product_id'
      });
      results = [];
      for (j = 0, len = gas.length; j < len; j++) {
        ga = gas[j];
        if (category = Category.find(ga.category_id)) {
          results.push(this.renderCategory(category));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    SidebarList.prototype.renderItemFromProductsPhoto = function(ap) {
      var ga, gas, j, len, results;
      this.log('renderItemFromProductsPhoto');
      gas = CategoriesProduct.filter(ap.product_id, {
        associationForeignKey: 'product_id'
      });
      results = [];
      for (j = 0, len = gas.length; j < len; j++) {
        ga = gas[j];
        results.push(this.renderItemFromCategoriesProduct(ga));
      }
      return results;
    };

    SidebarList.prototype.exposeSelection = function(item) {
      if (item == null) {
        item = Category.record;
      }
      this.children().removeClass('active');
      if (item) {
        this.children().forItem(item).addClass("active");
      }
      this.expand(item, true);
      return this.exposeSublistSelection(null, item != null ? item.id : void 0);
    };

    SidebarList.prototype.exposeSublistSelection = function(selection, id) {
      var activeEl, activeProduct, categoryEl, item, j, len, product, productsEl, ref, ref1, sel;
      if (selection == null) {
        selection = Category.selectionList();
      }
      if (id == null) {
        id = (ref = Category.record) != null ? ref.id : void 0;
      }
      this.log('exposeSublistSelection');
      item = Category.find(id);
      if (item) {
        categoryEl = this.children().forItem(item);
        productsEl = categoryEl.find('li');
        productsEl.removeClass('selected active');
        ref1 = item.selectionList();
        for (j = 0, len = ref1.length; j < len; j++) {
          sel = ref1[j];
          if (product = Product.find(sel)) {
            productsEl.forItem(product).addClass('selected');
          }
        }
        if (activeProduct = Product.find(item.selectionList().first())) {
          activeEl = productsEl.forItem(activeProduct).addClass('active');
        }
      }
      return this.refreshElements();
    };

    SidebarList.prototype.click = function(e) {
      var category, cid, el, item, list, pid, ref;
      el = $(e.target).closest('li');
      item = el.item();
      if (!item) {
        return;
      }
      list = item.selectionList().slice(0);
      cid = item.id;
      switch (item.constructor.className) {
        case 'Category':
          this.expand(item, (this.isOpen(el)) || (!(((ref = Category.record) != null ? ref.id : void 0) === item.id) || !this.isOpen(el)));
          this.navigate('/category', cid, pid = (pid = item.selectionList().first()) ? 'pid/' + pid : null);
          break;
        case 'Product':
          category = $(e.target).closest('li.gal').item();
          this.navigate('/category', category.id, 'pid', item.id);
      }
      return item.updateSelection(list);
    };

    SidebarList.prototype.ignoreProduct = function(e) {
      var category, product;
      product = $(e.currentTarget).item();
      category = $(e.currentTarget).parents('.gal.data').item();
      Spine.trigger('product:ignore', product, category);
      e.stopPropagation();
      return e.preventDefault();
    };

    SidebarList.prototype.clickExpander = function(e) {
      var el, item;
      el = $(e.target).closest('li.gal');
      if (!this.isOpen(el)) {
        el.addClass('manual');
      } else {
        el.removeClass('manual');
      }
      item = el.item();
      if (item) {
        this.expand(item, !this.isOpen(el));
      }
      e.stopPropagation();
      return e.preventDefault();
    };

    SidebarList.prototype.expand = function(item, open) {
      var el, expander;
      el = this.categoryElFromItem(item);
      expander = $('.expander', el);
      el.toggleClass('open', open);
      return;
      if (open) {
        return this.openSublist(el);
      } else {
        if (!el.hasClass('manual')) {
          return this.closeSublist(el);
        }
      }
    };

    SidebarList.prototype.isOpen = function(el) {
      return el.hasClass('open');
    };

    SidebarList.prototype.openSublist = function(el) {
      return el.addClass('open');
    };

    SidebarList.prototype.closeSublist = function(el) {
      return el.removeClass('open manual');
    };

    SidebarList.prototype.closeAllSublists = function() {
      var category, j, len, ref, results;
      ref = Category.all();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        category = ref[j];
        results.push(this.expand(category));
      }
      return results;
    };

    SidebarList.prototype.closeAllOtherSublists = function(list) {
      var category, id, j, len, ref, results;
      id = list[0];
      ref = Category.all();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        category = ref[j];
        results.push(this.expand(category, id === category.id));
      }
      return results;
    };

    SidebarList.prototype.categoryElFromItem = function(item) {
      return this.children().forItem(item);
    };

    SidebarList.prototype.close = function() {};

    SidebarList.prototype.show = function(e) {
      App.contentManager.change(App.showView);
      e.stopPropagation();
      return e.preventDefault();
    };

    SidebarList.prototype.scrollTo = function(item) {
      var clsName, el, el_, ohc, ohp, otc, otp, outOfMaxRange, outOfMinRange, outOfRange, queued, res, resMax, resMin, speed, stp, ul;
      if (!item) {
        return;
      }
      el = this.children().forItem(Category.record);
      clsName = item.constructor.className;
      switch (clsName) {
        case 'Category':
          return;
          queued = false;
          ul = $('ul', el);
          ul.hide();
          el_ = el[0];
          if (el_) {
            ohc = el_.offsetHeight;
          }
          ul.show();
          speed = 10;
          break;
        case 'Product':
          queued = false;
          ul = $('ul', el);
          el = $('li', ul).forItem(item);
          el_ = el[0];
          if (el_) {
            ohc = el_.offsetHeight;
          }
          speed = 200;
          break;
        default:
          return;
      }
      if (!el.length) {
        return;
      }
      otc = el.offset().top;
      stp = this.el[0].scrollTop;
      otp = this.el.offset().top;
      ohp = this.el[0].offsetHeight;
      resMin = stp + otc - otp;
      resMax = stp + otc - (otp + ohp - ohc);
      outOfRange = stp > resMin || stp < resMax;
      if (!outOfRange) {
        return;
      }
      outOfMinRange = stp > resMin;
      outOfMaxRange = stp < resMax;
      res = outOfMinRange ? resMin : outOfMaxRange ? resMax : void 0;
      return this.el.animate({
        scrollTop: res
      }, {
        queue: queued,
        duration: speed,
        done: (function(_this) {
          return function() {};
        })(this)
      });
    };

    return SidebarList;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SidebarList;
  }

}).call(this);
 },"controllers/sub_edit_view_description": function(exports, require, module) { (function() {
  var $, Description, Drag, Extender, KeyEnhancer, Model, Spine, SubEditViewDescription, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  User = require("models/user");

  KeyEnhancer = require('extensions/key_enhancer');

  Extender = require('extensions/controller_extender');

  Description = require("models/description");

  Drag = require('extensions/drag');

  SubEditViewDescription = (function(superClass) {
    extend(SubEditViewDescription, superClass);

    SubEditViewDescription.extend(Extender);

    SubEditViewDescription.extend(Drag);

    SubEditViewDescription.prototype.events = {
      'keyup': 'saveOnKeyup',
      'click .opt-add': 'add',
      'click .opt-remove': 'remove',
      'sortupdate': 'sortupdate',
      'drop': 'drop'
    };

    SubEditViewDescription.prototype.template = function(item) {
      return $('#editDescriptionTemplate').tmpl(item);
    };

    function SubEditViewDescription() {
      this.saveOnKeyup = bind(this.saveOnKeyup, this);
      SubEditViewDescription.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Description.bind('destroy', this.proxy(this.destroy));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
    }

    SubEditViewDescription.prototype.newAttributes = function(object) {
      var count, obj, product_id, ref, ref1, user_id;
      if (object == null) {
        object = {};
      }
      if ((user_id = (ref = User.first()) != null ? ref.id : void 0) && (product_id = (ref1 = this.parent.current) != null ? ref1.id : void 0)) {
        count = Description.filter(product_id).length;
        obj = {
          product_id: product_id,
          description: '',
          user_id: user_id,
          order: count + 1
        };
        return object = $.extend({}, obj, object);
      } else {
        return User.ping();
      }
    };

    SubEditViewDescription.prototype.refreshOne = function() {
      return Description.one('refresh', this.proxy(this.refresh));
    };

    SubEditViewDescription.prototype.refresh = function() {
      return this.active();
    };

    SubEditViewDescription.prototype.active = function() {
      var items, ref;
      $(this.btn, this.parent.el).addClass('active');
      items = Description.filterSortByOrder((ref = this.parent.current) != null ? ref.id : void 0);
      if (!items.length) {
        items = this.create();
      }
      return this.render(items);
    };

    SubEditViewDescription.prototype.render = function(items) {
      this.html(this.template(items));
      this.el.sortable();
      this.refreshElements();
      return this.el;
    };

    SubEditViewDescription.prototype.add = function(e) {
      var el, item, newItem;
      item = $(e.target).item();
      el = this.findModelElement(item);
      newItem = this.create({
        order: parseInt(item.order) + 1
      });
      el.after(this.template(newItem));
      this.sortupdate();
      return $('[data-description-id=' + newItem.id + '] input', this.el).focus();
    };

    SubEditViewDescription.prototype.remove = function(e) {
      var item;
      item = $(e.target).item();
      return item.destroy();
    };

    SubEditViewDescription.prototype.create = function(attr) {
      var item;
      item = new Description(this.newAttributes(attr));
      item.save();
      return item;
    };

    SubEditViewDescription.prototype.destroy = function(item) {
      var el;
      el = this.findModelElement(item);
      el.detach();
      if (!Description.filter(this.parent.current.id).length) {
        this.active();
      }
      return this.sortupdate();
    };

    SubEditViewDescription.prototype.drop = function(e) {
      return e.stopPropagation();
    };

    SubEditViewDescription.prototype.sortupdate = function() {
      this.children().each(function(index) {
        var item, tmplItem;
        item = $(this).item();
        item.order = index + 1;
        item.save();
        tmplItem = $(this).tmplItem();
        tmplItem.data = item;
        return tmplItem.update();
      });
      this.el.sortable('destroy').sortable();
      return this.refreshElements();
    };

    SubEditViewDescription.prototype.save = function(e) {
      var atts, base, item;
      this.log('save description');
      if (this.parent.current) {
        atts = typeof (base = $(e.target).parent()).serializeForm === "function" ? base.serializeForm() : void 0;
        item = $(e.target).item();
        return item.updateChangedAttributes(atts);
      }
    };

    SubEditViewDescription.prototype.saveOnKeyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      switch (code) {
        case 32:
          e.stopPropagation();
          break;
        case 9:
          e.stopPropagation();
      }
      return this.save(e);
    };

    return SubEditViewDescription;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SubEditViewDescription;
  }

}).call(this);
 },"controllers/sub_edit_view_product": function(exports, require, module) { (function() {
  var $, Category, Extender, KeyEnhancer, Root, Spine, SubEditViewProduct,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  KeyEnhancer = require('extensions/key_enhancer');

  Extender = require('extensions/controller_extender');

  Category = require("models/category");

  Root = require("models/root");

  SubEditViewProduct = (function(superClass) {
    extend(SubEditViewProduct, superClass);

    SubEditViewProduct.extend(Extender);

    SubEditViewProduct.prototype.events = {
      'keyup': 'saveOnKeyup',
      'click .opt-ignored': 'ignoreProduct'
    };

    SubEditViewProduct.prototype.linkTemplate = function(item) {
      return $('validLinkTemplate').tmpl(item);
    };

    SubEditViewProduct.prototype.template = function(item) {
      return $('#editProductTemplate').tmpl(item);
    };

    function SubEditViewProduct() {
      this.saveOnKeyup = bind(this.saveOnKeyup, this);
      SubEditViewProduct.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Spine.bind('refresh:one', this.proxy(this.refreshOne));
    }

    SubEditViewProduct.prototype.refreshOne = function() {
      return Product.one('refresh', this.proxy(this.refresh));
    };

    SubEditViewProduct.prototype.refresh = function() {
      return this.active();
    };

    SubEditViewProduct.prototype.active = function() {
      return this.render();
    };

    SubEditViewProduct.prototype.render = function() {
      var item;
      this.html(this.template(item = this.parent.current));
      return this.checkLink();
    };

    SubEditViewProduct.prototype.checkLink = function() {
      var item;
      item = this.parent.current;
      if (item) {
        return $('#validLink', this.el).toggleClass('valid', item.validUrl());
      }
    };

    SubEditViewProduct.prototype.save = function(el) {
      var atts, record;
      this.log('save product');
      if (record = this.parent.current) {
        atts = (typeof el.serializeForm === "function" ? el.serializeForm() : void 0) || this.el.serializeForm();
        return record.updateChangedAttributes(atts);
      }
    };

    SubEditViewProduct.prototype.ignoreProduct = function(e) {
      var category, product;
      product = $(e.currentTarget).item();
      category = Category.record;
      if (!category) {
        return;
      }
      return Spine.trigger('product:ignore', product, category);
    };

    SubEditViewProduct.prototype.saveOnKeyup = function(e) {
      var code;
      code = e.charCode || e.keyCode;
      switch (code) {
        case 32:
          e.stopPropagation();
          break;
        case 9:
          e.stopPropagation();
      }
      this.save(this.el);
      return this.checkLink();
    };

    return SubEditViewProduct;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SubEditViewProduct;
  }

}).call(this);
 },"controllers/sub_no_product": function(exports, require, module) { (function() {
  var $, Extender, Spine, SubNoProduct,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Extender = require('extensions/controller_extender');

  SubNoProduct = (function(superClass) {
    extend(SubNoProduct, superClass);

    SubNoProduct.extend(Extender);

    function SubNoProduct() {
      SubNoProduct.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
    }

    SubNoProduct.prototype.active = function() {
      return this.render();
    };

    SubNoProduct.prototype.render = function() {
      return this.renderEmpty('Kein Produkt ausgewhlt');
    };

    return SubNoProduct;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = SubNoProduct;
  }

}).call(this);
 },"controllers/toolbar_view": function(exports, require, module) { (function() {
  var $, Extender, Model, Spine, Toolbar, ToolbarView,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Toolbar = Model.Toolbar = require('models/toolbar');

  Extender = require('extensions/controller_extender');

  ToolbarView = (function(superClass) {
    extend(ToolbarView, superClass);

    ToolbarView.extend(Extender);

    ToolbarView.prototype.template = function(items) {
      return $('#toolsTemplate').tmpl(items);
    };

    function ToolbarView() {
      ToolbarView.__super__.constructor.apply(this, arguments);
      this.current = [];
    }

    ToolbarView.prototype.elements = {
      'li': 'items'
    };

    ToolbarView.prototype.events = {
      'click': 'click'
    };

    ToolbarView.prototype.click = function(e) {
      return this.lastcontrol = $(e.target);
    };

    ToolbarView.prototype.change = function(list) {
      var content, i, itm, lastItem, len, tools;
      if (list == null) {
        list = [];
      }
      if (list.length) {
        tools = Toolbar.filter(list);
        content = new Array;
        for (i = 0, len = tools.length; i < len; i++) {
          itm = tools[i];
          $.merge(content, itm.content);
        }
        this.current = content;
        lastItem = list.last();
        if (typeof lastItem === 'function') {
          this.current.cb = lastItem;
        }
      }
      return this.render();
    };

    ToolbarView.prototype.filterTools = function(list) {
      return Toolbar.select(list);
    };

    ToolbarView.prototype.sort = function(a, b) {};

    ToolbarView.prototype.refresh = function() {
      return this.change();
    };

    ToolbarView.prototype.lock = function() {
      return this.locked = true;
    };

    ToolbarView.prototype.unlock = function() {
      return this.locked = false;
    };

    ToolbarView.prototype.clear = function() {
      this.current = [];
      return this.render();
    };

    ToolbarView.prototype.renderSub = function() {
      var i, items, itm, len, results, test;
      items = this.current.slice(0);
      test = function() {
        var name, res;
        res = [];
        name = itm.itemGroup.name;
        if (typeof name === 'function') {
          res.push(name.call());
        } else {
          res.push(name);
        }
        return res[0];
      };
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        itm = items[i];
        if (test(itm) === 'Hilfe') {
          results.push(itm);
        }
      }
      return results;
    };

    ToolbarView.prototype.render = function(list) {
      var ref;
      if (list == null) {
        list = this.current;
      }
      if (this.locked) {
        return;
      }
      this.trigger('before:refresh', this);
      this.html(this.template(list));
      if ((ref = this.current) != null) {
        if (typeof ref.cb === "function") {
          ref.cb();
        }
      }
      return this.trigger('refresh', this, this.lastcontrol);
    };

    return ToolbarView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ToolbarView;
  }

}).call(this);
 },"controllers/trustami_view": function(exports, require, module) { (function() {
  var $, Spine, TrustamiView, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  User = require('models/user');

  TrustamiView = (function(superClass) {
    extend(TrustamiView, superClass);

    TrustamiView.prototype.elements = {
      'input': 'input'
    };

    TrustamiView.prototype.events = {
      'click .opt-Count-Up': 'countUp',
      'click .opt-Count-Down': 'countDown',
      'keyup': 'saveOnKeyup'
    };

    TrustamiView.prototype.template = function(item) {
      return $('#trustamiTemplate').tmpl(item);
    };

    function TrustamiView() {
      this.saveOnKeyup = bind(this.saveOnKeyup, this);
      TrustamiView.__super__.constructor.apply(this, arguments);
      User.one('update', this.proxy(this.render));
      this.init();
    }

    TrustamiView.prototype.init = function() {
      return this.user = User.first();
    };

    TrustamiView.prototype.render = function(item) {
      return this.html(this.template(item));
    };

    TrustamiView.prototype.save = function() {
      var atts, n;
      atts = this.el.serializeForm();
      if (isNaN(n = parseInt(atts.tmi)) || n < 1) {
        this.input.val(this.user.tmi);
        return;
      }
      this.input.val(n);
      this.user.updateAttributes({
        tmi: n
      });
      return this.user.setTmi(this.setCallback);
    };

    TrustamiView.prototype.countUp = function() {
      var val;
      val = parseInt(this.input.val()) + 1;
      this.input.val(val);
      return this.save();
    };

    TrustamiView.prototype.countDown = function() {
      var val;
      val = parseInt(this.input.val()) - 1;
      this.input.val(val);
      return this.save();
    };

    TrustamiView.prototype.getCallback = function(json) {
      return json = $.parseJSON(json);
    };

    TrustamiView.prototype.setCallback = function(json) {
      return json = $.parseJSON(json);
    };

    TrustamiView.prototype.saveOnKeyup = function(e) {
      var code, el, isFormfield;
      code = e.charCode || e.keyCode;
      if (code >= 37 && code <= 40) {
        return;
      }
      el = $(document.activeElement);
      isFormfield = $().isFormElement(el);
      switch (code) {
        case 32:
          if (!isFormfield) {
            e.stopPropagation();
          }
          break;
        case 9:
          if (!isFormfield) {
            e.stopPropagation();
          }
      }
      return this.save();
    };

    TrustamiView.prototype.dummy = function() {};

    return TrustamiView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = TrustamiView;
  }

}).call(this);
 },"controllers/upload_edit_view": function(exports, require, module) { (function() {
  var $, PhotoEditView, Product, Settings, Spine, UploadEditView,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Product = require("models/product");

  Settings = require("models/settings");

  PhotoEditView = require("controllers/photo_edit_view");

  UploadEditView = (function(superClass) {
    extend(UploadEditView, superClass);

    UploadEditView.prototype.elements = {
      '.delete:not(.files .delete)': 'clearEl',
      '#fileupload button.cancel': 'cancelEl',
      '.files': 'filesEl',
      '.uploadinfo': 'uploadinfoEl',
      '#ph': 'photoEl',
      '.editor': 'editorEl',
      '#fileupload': 'uploader'
    };

    UploadEditView.prototype.events = {
      'fileuploaddone': 'done',
      'fileuploadsubmit': 'submit',
      'fileuploadfail': 'fail',
      'fileuploaddrop': 'drop',
      'fileuploadadd': 'add',
      'fileuploadsend': 'send',
      'fileuploadprogressall': 'alldone',
      'fileuploadprogress': 'progress',
      'fileuploaddestroyed': 'destroyed',
      'click .opt-editor': 'toggleEditor'
    };

    UploadEditView.prototype.template = function(item) {
      return $('#template-upload').tmpl(item);
    };

    function UploadEditView() {
      UploadEditView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      Product.bind('change:current', this.proxy(this.changeDataLink));
      this.data = {
        fileslist: [
          {
            link: false
          }
        ]
      };
      this.queue = [];
      this.editor = new PhotoEditView({
        el: this.photoEl
      });
      this.editor.change();
    }

    UploadEditView.prototype.changeDataLink = function(product) {
      return this.data.link = product != null ? product.id : void 0;
    };

    UploadEditView.prototype.change = function(item) {
      return this.render();
    };

    UploadEditView.prototype.active = function() {};

    UploadEditView.prototype.render = function() {
      var category, selection;
      selection = Category.selectionList();
      category = Category.record;
      this.product = Product.find(selection[0]) || false;
      this.uploadinfoEl.html(this.template({
        category: category,
        product: this.product
      }));
      this.refreshElements();
      return this.el;
    };

    UploadEditView.prototype.setAutoupload = function(b) {
      return this.uploader.fileupload('option', 'autoUpload', b);
    };

    UploadEditView.prototype.getAutoupload = function() {
      return this.uploader.fileupload('option', 'autoUpload');
    };

    UploadEditView.prototype.destroyed = function() {};

    UploadEditView.prototype.fail = function(e, data) {
      var product;
      this.log(data.textStatus);
      this.log(data.errorThrown);
      product = Product.find(this.data.link);
      return Spine.trigger('loading:fail', product, data.errorThrown);
    };

    UploadEditView.prototype.drop = function(e, data) {};

    UploadEditView.prototype.add = function(e, data) {
      var file, i, len, ref, results;
      this.trigger('active');
      this.clearEl.click();
      this.parent.toggleAutoUpload(true);
      if (!this.checkSelected(data)) {
        this.cancelUpload(e, data);
        return;
      }
      ref = data.files;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        results.push(this.data.fileslist.push(file));
      }
      return results;
    };

    UploadEditView.prototype.checkSelected = function(data) {
      var auto, multiple, str, valid;
      valid = function() {
        return !!Category.selectionList().length;
      };
      auto = this.getAutoupload() ? '' : 'nicht';
      if (!valid()) {
        multiple = data.files.length > 1;
        str = multiple ? 'Sollen die Fotos ' : 'Soll das Foto ';
        App.confirm('NO_CAT_FOR_UPLOAD', {
          mode: 'alert'
        });
        return false;
      }
      return true;
    };

    UploadEditView.prototype.cancelUpload = function(e, data) {
      this.autoupload = this.getAutoupload();
      if (this.autoupload) {
        this.parent.toggleAutoUpload(false);
      }
      this.jqXHR(data).abort();
      return $('button.cancel', '#fileupload').click((function(_this) {
        return function() {
          return _this.jqXHR(data).abort();
        };
      })(this));
    };

    UploadEditView.prototype.jqXHR = function(data) {
      return this.uploader.fileupload('send', data).error((function(_this) {
        return function(jqXHR, textStatus, errorThrown) {
          if (errorThrown === 'abort') {
            return _this.log('Foto Upload abgebrochen');
          }
        };
      })(this));
    };

    UploadEditView.prototype.submit = function(e, data) {
      return $('button.cancel', this.uploader).click((function(_this) {
        return function() {
          return _this.jqXHR(data).abort();
        };
      })(this));
    };

    UploadEditView.prototype.send = function(e, data) {
      var product;
      product = Product.find(this.data.link);
      return Spine.trigger('loading:start', product);
    };

    UploadEditView.prototype.alldone = function(e, data) {};

    UploadEditView.prototype.done = function(e, data) {
      var i, len, photos, product, raw, raws, ref, selection;
      product = Product.find(this.data.link);
      raws = $.parseJSON(data.jqXHR.responseText);
      photos = [];
      for (i = 0, len = raws.length; i < len; i++) {
        raw = raws[i];
        photos.push(new Photo(raw['Photo']).save({
          ajax: false
        }));
      }
      if (product) {
        Photo.trigger('create:join', photos, product);
      } else {
        Photo.trigger('created', photos);
        this.navigate('/category', ((ref = Category.record) != null ? ref.id : void 0) || '', '');
      }
      console.log(product);
      Spine.trigger('loading:done', product);
      selection = photos.toId();
      Product.updateSelection(selection);
      if (this.autoupload) {
        this.parent.toggleAutoUpload(this.autoupload);
      }
      delete this.autoupload;
      return e.preventDefault();
    };

    UploadEditView.prototype.progress = function(e, data) {};

    UploadEditView.prototype.paste = function(e, data) {
      this.log('paste');
      if (data.files.length) {
        return this.drop(e, data);
      }
    };

    UploadEditView.prototype.notify = function() {
      return App.modal2ButtonView.show({
        header: 'No Product selected',
        body: 'Please select an product .',
        info: '',
        button_1_text: 'Hallo',
        button_2_text: 'Bye'
      });
    };

    UploadEditView.prototype.changedSelected = function(product) {
      var ref;
      product = Product.find(product.id);
      if (this.data.fileslist.length) {
        return $.extend(this.data, {
          link: (ref = Product.record) != null ? ref.id : void 0
        });
      }
    };

    UploadEditView.prototype.toggleEditor = function() {
      return this.editor.content.toggleClass('hide', !this.isHidden());
    };

    UploadEditView.prototype.isHidden = function() {
      return this.editor.content.hasClass('hide');
    };

    return UploadEditView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = UploadEditView;
  }

}).call(this);
 },"controllers/wait_view": function(exports, require, module) { (function() {
  var $, Controller, Extender, ModalSimpleView, Model, Spine, WaitView,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Controller = Spine.Controller;

  ModalSimpleView = require("controllers/modal_simple_view");

  Extender = require('extensions/controller_extender');

  WaitView = (function(superClass) {
    extend(WaitView, superClass);

    WaitView.extend(Extender);

    function WaitView() {
      WaitView.__super__.constructor.apply(this, arguments);
      this.bind('active', this.proxy(this.active));
      this.header = new Spine.Controller;
      Spine.bind('show:wait', this.proxy(this.show));
      Spine.bind('done:wait', this.proxy(this.close));
    }

    WaitView.prototype.render = function(items) {};

    WaitView.prototype.show = function(params) {
      App.showView.trigger('canvas', this);
      return this.active(params);
    };

    WaitView.prototype.active = function(options) {
      return this.notify(options);
    };

    WaitView.prototype.notify = function(options) {
      var defaults;
      if (options == null) {
        options = {};
      }
      defaults = {
        body: 'Body',
        small: true
      };
      options = $.extend(defaults, options);
      this.modalSimpleView = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      this.modalSimpleView.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      this.modalSimpleView.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      this.modalSimpleView.el.one('show.bs.modal', this.proxy(this.showmodal));
      return this.modalSimpleView.show();
    };

    WaitView.prototype.close = function(cb) {
      this.modalSimpleView.close();
      if (typeof cb === 'function') {
        return cb.call(this);
      }
    };

    WaitView.prototype.hidemodal = function(e) {};

    WaitView.prototype.hiddenmodal = function(e) {};

    WaitView.prototype.showmodal = function(e) {};

    return WaitView;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = WaitView;
  }

}).call(this);
 },"extensions/ajax_relations": function(exports, require, module) { (function() {
  var $, AjaxRelations, Builder, CategoriesProduct, Category, Model, Photo, Product, ProductsPhoto, Request, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  require('spine/lib/ajax');

  Builder = (function() {
    function Builder(record) {
      var base;
      this.record = record;
      this.data = {};
      this.model = this.record.constructor;
      this.foreignModels = typeof (base = this.model).foreignModels === "function" ? base.foreignModels() : void 0;
    }

    Builder.prototype.newWrapper = function(key) {
      var data;
      if (!key.className) {
        throw 'No classname found';
      }
      data = {};
      data[key.className] = {};
      return data;
    };

    Builder.prototype.build = function() {
      var foreignRecords, i, key, len, ref, value;
      if (this.foreignModels) {
        this.fModels = (function() {
          var ref, results;
          ref = this.foreignModels;
          results = [];
          for (key in ref) {
            value = ref[key];
            results.push(this.foreignModels[key]);
          }
          return results;
        }).call(this);
        ref = this.fModels;
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          foreignRecords = Model[key.joinTable].filter(this.record.id, {
            associationForeignKey: key.foreignKey
          });
          this.data[key.joinTable] = foreignRecords;
        }
      }
      this.data[this.model.className] = this.record;
      return this.data;
    };

    return Builder;

  })();

  Request = (function(superClass) {
    extend(Request, superClass);

    function Request(record) {
      this.record = record;
      Request.__super__.constructor.apply(this, arguments);
      this.data = new Builder(this.record).build();
    }

    Request.prototype.create = function(params, options) {
      return this.ajaxQueue(params, {
        type: "POST",
        data: JSON.stringify(this.data),
        url: Spine.Ajax.getURL(this.model)
      }).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    Request.prototype.update = function(params, options) {
      return this.ajaxQueue(params, {
        type: "PUT",
        data: JSON.stringify(this.data),
        url: Spine.Ajax.getURL(this.record)
      }).done(this.recordResponse(options)).fail(this.failResponse(options));
    };

    return Request;

  })(Spine.Ajax.Singleton);

  AjaxRelations = {
    extended: function() {
      var Include;
      Include = {
        ajax: function() {
          return new Request(this);
        }
      };
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.AjaxRelations = AjaxRelations;
  }

}).call(this);
 },"extensions/cache": function(exports, require, module) { (function() {
  var $, Model, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Model.Cache = {
    extended: function() {
      var Extend, Include;
      Extend = {
        caches: [
          {
            global: []
          }
        ],
        cacheList: (function(_this) {
          return function(recordID) {
            var i, id, item, itm, len, ref;
            id = recordID || 'global';
            if (!id) {
              return;
            }
            ref = _this.caches;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              if (itm = item[id]) {
                return itm;
              }
            }
            throw 'record ' + id + ' is not configured ';
          };
        })(this),
        cache: function(url, id) {
          var cached, i, item, key, len, val;
          cached = this.cacheList(id);
          if (!cached) {
            return;
          }
          for (i = 0, len = cached.length; i < len; i++) {
            item = cached[i];
            for (key in item) {
              val = item[key];
              if (item[url]) {
                return val[0];
              }
            }
          }
        },
        initCache: function(id) {
          var arr;
          arr = this.caches;
          arr.push(this.hash(id));
          return arr;
        },
        hash: function(key) {
          var o;
          o = new Object();
          o[key] = [];
          return o;
        },
        hasCache: function(url, id) {
          return !!(this.cache(url, id));
        },
        addToCache: function(url, uris) {
          var i, item, itm, itm_url, key, len, results, uri, val;
          results = [];
          for (i = 0, len = uris.length; i < len; i++) {
            uri = uris[i];
            results.push((function() {
              var results1;
              results1 = [];
              for (key in uri) {
                val = uri[key];
                item = this.cacheList(key);
                if (!this.keyExists.call(item, url)) {
                  item.push(this.hash(url));
                }
                results1.push((function() {
                  var j, len1, ref, results2;
                  results2 = [];
                  for (j = 0, len1 = item.length; j < len1; j++) {
                    itm = item[j];
                    if (itm_url = itm[url]) {
                      [].splice.apply(itm_url, [0, itm_url.length - 0].concat(ref = [])), ref;
                      results2.push(itm_url.push(uri));
                    } else {
                      results2.push(void 0);
                    }
                  }
                  return results2;
                })());
              }
              return results1;
            }).call(this));
          }
          return results;
        },
        itemExists: function(item) {
          var i, key, len, ref, thisItem, val;
          for (key in item) {
            val = item[key];
            ref = this;
            for (i = 0, len = ref.length; i < len; i++) {
              thisItem = ref[i];
              if (thisItem[key]) {
                return thisItem;
              }
            }
          }
          return false;
        },
        keyExists: function(key) {
          var i, len, ref, thisItem;
          ref = this;
          for (i = 0, len = ref.length; i < len; i++) {
            thisItem = ref[i];
            if (thisItem[key]) {
              return thisItem;
            }
          }
          return false;
        },
        destroyCache: function(id) {
          var findIdFromObject, findItemsFromArray, i, idx, itm, len, list, results;
          list = this.cacheList();
          findIdFromObject = function(id, obj) {
            var arr, i, idx, itm, key, len, value;
            for (key in obj) {
              value = obj[key];
              arr = obj[key];
              for (idx = i = 0, len = arr.length; i < len; idx = ++i) {
                itm = arr[idx];
                if (itm[id]) {
                  return arr.splice(idx, 1);
                }
              }
            }
          };
          findItemsFromArray = function(items) {
            var i, itm, ix, len, results;
            results = [];
            for (ix = i = 0, len = items.length; i < len; ix = ++i) {
              itm = items[ix];
              results.push(findIdFromObject(id, itm));
            }
            return results;
          };
          results = [];
          for (idx = i = 0, len = list.length; i < len; idx = ++i) {
            itm = list[idx];
            if (itm[id]) {
              results.push(list.splice(idx, 1));
            } else {
              results.push(void 0);
            }
          }
          return results;
        },
        clearCache: function(id) {
          var originalList, ref;
          originalList = this.cacheList(id);
          [].splice.apply(originalList, [0, originalList.length - 0].concat(ref = [])), ref;
          return originalList;
        }
      };
      Include = {
        cache: function(url) {
          return this.constructor.cache(url, this.id);
        },
        addToCache: function(url, uri, mode) {
          return this.constructor.addToCache(this, url, uri, mode);
        },
        destroyCache: function() {
          return this.constructor.destroyCache(this.id);
        },
        clearCache: function() {
          var list;
          return list = this.constructor.clearCache(this.id);
        }
      };
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Cache;
  }

}).call(this);
 },"extensions/controller_extender": function(exports, require, module) { (function() {
  var $, Controller, Spine,
    slice = [].slice;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Controller.Extender = {
    extended: function() {
      var Extend, Include;
      Extend = {
        empty: function() {
          this.log('empty');
          return this.constructor.apply(this, arguments);
        }
      };
      Include = {
        init: function() {
          var modelName, modelsName, ref, ref1;
          this.trace = !Spine.isProduction;
          this.logPrefix = '(' + this.constructor.name + ')';
          this.model = (modelName = this.el.data('modelName')) ? Model[modelName] : (ref = this.parent) != null ? ref.model : void 0;
          return this.models = (modelsName = this.el.data('modelsName')) ? Model[modelsName] : (ref1 = this.parent) != null ? ref1.models : void 0;
        },
        p: function() {
          return App.sidebar.products;
        },
        humanize: function(arr) {
          var p, plural, record;
          if (!Array.isArray(arr)) {
            arr = [arr];
          }
          if (!arr.length) {
            throw 'nothing to humanize';
          }
          record = arr[0];
          plural = arr.length > 1;
          return {
            plural: plural,
            length: arr.length,
            type: record.constructor['humanName' + ((p = plural) ? 's' : '')](),
            name: record.n()
          };
        },
        emptyMessage: function(name) {
          return name;
        },
        followLink: function(e) {
          var strWindowFeatures;
          strWindowFeatures = "menubar=no,location=no,resizable=no,scrollbars=yes,status=no";
          window.open($(e.target).closest('a').attr('href'), 'new');
          e.preventDefault();
          return e.stopPropagation();
        },
        exposeSelection: function(selection) {
          var el, first, i, id, len;
          if (selection == null) {
            selection = this.model.selectionList();
          }
          this.log('exposing');
          this.deselect();
          for (i = 0, len = selection.length; i < len; i++) {
            id = selection[i];
            el = $('#' + id, this.el);
            el.addClass("active");
          }
          if (first = selection.first()) {
            return $('#' + first, this.el).addClass("hot");
          }
        },
        createImage: function(url, onload) {
          var img;
          img = new Image();
          if (onload) {
            img.onload = onload;
          }
          if (url) {
            img.src = url;
          }
          return img;
        },
        eql: function() {
          var c, p, ref, ref1;
          c = (ref = this.current) != null ? ref.model.className : void 0;
          p = (ref1 = this.previous) != null ? ref1.model.className : void 0;
          return !!(c === p);
        },
        eql_: function() {
          var prev, rec, ref;
          rec = this.model.record;
          prev = this.current;
          this.current = rec;
          return !!(((ref = this.current) != null ? typeof ref.eql === "function" ? ref.eql(prev) : void 0 : void 0) && !!prev);
        },
        activated: function() {},
        testEmpty: function() {
          if (this.model.record) {
            if (!this.model.record.contains()) {
              return this.renderEmpty();
            }
          }
        },
        renderEmpty: function(s, element) {
          var info;
          if (s == null) {
            s = 'nichts zu melden';
          }
          if (element == null) {
            element = 'el';
          }
          info = '<label class="invite"><span class="enlightened">' + this.emptyMessage(s) + '</span></label>';
          this[element].html($("#noSelectionTemplate").tmpl({
            type: info || ''
          }));
          return this.el;
        },
        wipe: function(item) {
          var first;
          if (this.model.record) {
            first = this.model.record.contains() === 1;
          }
          if (first) {
            this.el.empty();
          }
          return this.el;
        },
        focusFirstInput: function(el) {
          if (el == null) {
            el = this.el;
          }
          if (!el) {
            return;
          }
          if (el.is(':visible')) {
            $('input', el).first().focus().select();
          }
          return el;
        },
        focus: function() {
          return this.el.focus();
        },
        panelIsActive: function(controller) {
          return App[controller].isActive();
        },
        openPanel: function(controller) {
          var ui;
          ui = App.vmanager.externalUI(App[controller]);
          return ui.click();
        },
        closePanel: function(controller, target) {
          var ui;
          App[controller].activate();
          ui = App.vmanager.externalUI(App[controller]);
          return ui.click();
        },
        isMeta: function(e) {
          return (e != null ? e.metaKey : void 0) || (e != null ? e.ctrlKey : void 0) || (e != null ? e.altKey : void 0);
        },
        children: function(sel) {
          return this.el.children(sel);
        },
        find: function(sel) {
          return this.el.find(sel);
        },
        remove: function(item) {
          var el, els, f;
          els = this.el.find('.items');
          el = els.children().forItem(item);
          if (!el.length) {
            return;
          }
          el.addClass('out').removeClass('in');
          f = function() {
            el.detach();
            return this.trigger('detached', item);
          };
          return this.delay(f, 400);
        },
        deselect: function() {
          var args, ref;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return (ref = this.el).deselect.apply(ref, args);
        },
        clearSelection: function(e) {
          return this.model.updateSelection([]);
        },
        sortable: function(type) {
          return this.el.sortable(type);
        },
        findModelElement: function(item) {
          return this.children().forItem(item, true);
        },
        noMethod: function(e) {
          e.stopPropagation();
          return e.preventDefault();
        }
      };
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Controller.Extender;
  }

}).call(this);
 },"extensions/develop": function(exports, require, module) { (function() {
  var $, Ajax, Base, Develop, Developer, DeveloperCollection, Model, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Ajax = {
    enabled: true,
    cache: true,
    pending: false,
    requests: [],
    requestNext: function() {
      var next;
      next = this.requests.shift();
      if (next) {
        return this.request(next);
      } else {
        this.pending = false;
        return Spine.trigger('uri:alldone');
      }
    },
    request: function(callback) {
      return (callback()).done((function(_this) {
        return function() {
          return _this.requestNext();
        };
      })(this));
    },
    queue: function(callback) {
      if (!this.enabled) {
        return;
      }
      if (this.pending) {
        this.requests.push(callback);
      } else {
        this.pending = true;
        this.request(callback);
      }
      return callback;
    }
  };

  Base = (function() {
    function Base() {}

    Base.prototype.defaults = {
      contentType: 'application/json',
      processData: false,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      },
      dataType: 'json'
    };

    Base.prototype.ajax = function(params, defaults) {
      return $.ajax($.extend({}, this.defaults, defaults, params));
    };

    Base.prototype.ajaxQueue = function(callback) {
      return Ajax.queue(callback);
    };

    Base.prototype.get = function() {
      return this.ajaxQueue((function(_this) {
        return function() {
          return _this.ajax({
            type: "POST",
            url: base_url + 'photos/dev/' + _this.url,
            data: JSON.stringify(_this.data)
          }).done(_this.recordResponse).fail(_this.failResponse);
        };
      })(this));
    };

    Base.prototype.uri = function(options) {
      var o, ret, val;
      ret = (function() {
        var results;
        results = [];
        for (o in options) {
          val = options[o];
          results.push(val);
        }
        return results;
      })();
      return ret.join('/');
    };

    return Base;

  })();

  Developer = (function(superClass) {
    extend(Developer, superClass);

    function Developer(model, method, params, callback1, data1) {
      var options;
      this.model = model;
      this.callback = callback1;
      this.data = data1 != null ? data1 : [];
      this.failResponse = bind(this.failResponse, this);
      this.recordResponse = bind(this.recordResponse, this);
      Developer.__super__.constructor.apply(this, arguments);
      options = $.extend({
        method: method
      }, this.settings, params);
      this.url = this.uri(options);
      return;
      if (!this.data.length) {
        return;
      }
    }

    Developer.prototype.settings = {};

    Developer.prototype.recordResponse = function(res) {
      return this.callback(res);
    };

    Developer.prototype.failResponse = function(xhr, statusText, error) {
      return this.model.trigger('ajaxError', xhr, statusText, error);
    };

    return Developer;

  })(Base);

  DeveloperCollection = (function(superClass) {
    extend(DeveloperCollection, superClass);

    function DeveloperCollection(record, params, mode, callback1, max) {
      var options, photos, type;
      this.record = record;
      this.callback = callback1;
      this.failResponse = bind(this.failResponse, this);
      this.recordResponse = bind(this.recordResponse, this);
      DeveloperCollection.__super__.constructor.apply(this, arguments);
      type = this.record.constructor.className;
      switch (type) {
        case 'Product':
          photos = ProductsPhoto.photos(this.record.id);
          max = max || photos.length;
          this.mode = mode;
          this.photos = photos.slice(0, max);
          break;
        case 'Photo':
          this.photos = [this.record];
      }
      options = $.extend({}, this.settings, params);
      this.url = this.uri(options);
    }

    DeveloperCollection.prototype.settings = {
      width: 140,
      height: 140,
      square: 1,
      quality: 70
    };

    DeveloperCollection.prototype.init = function() {
      var cache;
      cache = this.record.cache(this.url);
      if (cache != null ? cache.length : void 0) {
        return this.callback(cache, this.record);
      } else {
        return this.get();
      }
    };

    DeveloperCollection.prototype.all = function() {
      return this.ajaxQueue((function(_this) {
        return function() {
          return _this.ajax({
            type: "POST",
            url: base_url + 'photos/uri/' + _this.url,
            data: JSON.stringify(_this.photos)
          }).done(_this.recordResponse).fail(_this.failResponse);
        };
      })(this));
    };

    DeveloperCollection.prototype.recordResponse = function(uris) {
      return this.callback(uris, this.record);
    };

    DeveloperCollection.prototype.failResponse = function(xhr, statusText, error) {
      return this.record.trigger('ajaxError', xhr, statusText, error);
    };

    return DeveloperCollection;

  })(Base);

  Develop = {
    extended: function() {
      var Extend, Include;
      Include = {
        develop: function(params, mode, callback, max) {
          return new DeveloperCollection(this, params, mode, callback, max).get();
        }
      };
      Extend = {
        develop: function(method, params, callback, data) {
          return new Developer(this, method, params, callback, data).get();
        }
      };
      this.include(Include);
      return this.extend(Extend);
    }
  };

  Develop.Ajax = Ajax;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Develop = Develop;
  }

}).call(this);
 },"extensions/drag": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Controller, Drag, Log, Photo, Product, ProductsPhoto, Spine, SpineDragItem;

  Spine = require("spine");

  $ = Spine.$;

  Log = Spine.Log;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  SpineDragItem = require('models/drag_item');

  Controller = Spine.Controller;

  Controller.Drag = {
    extended: function() {
      var Include;
      Include = {
        dragstart: function(e) {
          var className, data, el, event, id, img, model, parentEl, parentModel, parentRecord, record, ref, ref1, ref2, selection, source;
          this.log('dragstart');
          event = e.originalEvent;
          el = $(e.target);
          if (!(record = el.item())) {
            e.stopPropagation();
            e.preventDefault();
            return;
          }
          parentEl = el.parents('.data');
          parentModel = ((ref = parentEl.data('tmplItem')) != null ? ref.data.constructor : void 0) || parentEl.data('modelName');
          parentRecord = ((ref1 = parentEl.data('tmplItem')) != null ? ref1.data : void 0) || Model[parentModel].record;
          Spine.dragItem.updateAttributes({
            el: el,
            els: [],
            source: record,
            sourceModelName: record.constructor.className,
            sourceModelId: record.id,
            originModel: Model[parentModel],
            originModelName: parentModel,
            originRecord: parentRecord,
            originRecordName: parentRecord.constructor.className,
            originRecordId: parentRecord.id,
            selection: []
          });
          this.trigger('drag:start', e, record);
          parentEl.addClass('drag-in-progress');
          model = Spine.dragItem.originRecord || Spine.dragItem.originModel;
          source = Spine.dragItem.source;
          selection = model.selectionList().slice(0);
          if (selection.indexOf(id = source.id) === -1) {
            selection = [source.id];
            model.updateSelection(selection);
          }
          Spine.dragItem.selection = selection;
          Spine.dragItem.save();
          data = [];
          data.push(selection);
          event = e.originalEvent;
          event.dataTransfer.effectAllowed = 'move';
          event.dataTransfer.setData('text/json', JSON.stringify(data));
          if (!App.useDragImage) {
            return;
          }
          className = record.constructor.className;
          switch (className) {
            case 'Product':
              img = data.length === 1 ? App.ALBUM_SINGLE_MOVE : App.ALBUM_DOUBLE_MOVE;
              break;
            case 'Photo':
              img = data.length === 1 ? App.IMAGE_SINGLE_MOVE : App.IMAGE_DOUBLE_MOVE;
          }
          return (ref2 = event.dataTransfer) != null ? ref2.setDragImage(img, 45, 60) : void 0;
        },
        dragenter: function(e, data) {
          var event, func;
          this.log('enter');
          if (!Spine.dragItem.source) {
            e.stopPropagation();
            e.preventDefault();
            return;
          }
          event = e.originalEvent;
          func = (function(_this) {
            return function() {
              return _this.trigger('drag:timeout', e, Spine.timer);
            };
          })(this);
          clearTimeout(Spine.timer);
          Spine.timer = setTimeout(func, 1000);
          this.trigger('drag:enter', e, data);
          return false;
        },
        dragover: function(e, data) {
          e.stopPropagation();
          e.preventDefault();
          this.trigger('drag:over', e, this);
          return false;
        },
        dragleave: function(e, data) {
          this.trigger('drag:leave', e, this);
          return false;
        },
        dragend: function(e, data) {
          $('.drag-in-progress').removeClass('drag-in-progress');
          this.trigger('drag:end', e, data);
          return false;
        },
        drop: function(e, data) {
          var event;
          this.trigger('drag:drop', e, data);
          $('.drag-in-progress').removeClass('drag-in-progress');
          clearTimeout(Spine.timer);
          event = e.originalEvent;
          data = event.dataTransfer.getData('text/json');
          try {
            data = JSON.parse(data);
          } catch (error) {
            e = error;
          }
          return false;
        },
        dragStart: function(e, record) {},
        dragEnter: function(e) {
          var el, indicator, o, origin, ref, ref1, s, selector, source, t, target;
          this.log('dragEnter');
          el = indicator = $(e.target).closest('.data');
          selector = el.attr('data-drag-over');
          if (selector) {
            indicator = el.children('.' + selector);
          }
          target = t = Spine.dragItem.target = ((ref = el.data('tmplItem')) != null ? ref.data : void 0) || this.model.record;
          source = s = Spine.dragItem.source;
          origin = o = Spine.dragItem.originRecord;
          if ((ref1 = Spine.dragItem.closest) != null) {
            ref1.removeClass('over nodrop');
          }
          Spine.dragItem.closest = indicator;
          if (this.validateDrop(target, source, origin)) {
            Spine.dragItem.closest.addClass('over');
          } else {
            Spine.dragItem.closest.addClass('over nodrop');
          }
          return Spine.dragItem.save();
        },
        dragOver: (function(_this) {
          return function(e) {};
        })(this),
        dragLeave: (function(_this) {
          return function(e) {};
        })(this),
        dragEnd: (function(_this) {
          return function(e) {
            var ref;
            _this.log('dragEnd');
            return (ref = Spine.dragItem.closest) != null ? ref.removeClass('over nodrop') : void 0;
          };
        })(this),
        dragDrop: function(e, record) {
          var cb, hash, origin, photos, ref, selection, source, target;
          this.log('dragDrop');
          if (!e.originalEvent.dataTransfer.files.length) {
            e.stopPropagation();
            e.preventDefault();
          }
          $('.sortable-placeholder').detach();
          target = Spine.dragItem.target;
          source = Spine.dragItem.source;
          origin = Spine.dragItem.originRecord;
          if (!(source || target || source)) {
            return;
          }
          if ((ref = Spine.dragItem.closest) != null) {
            ref.removeClass('over nodrop');
          }
          if (!this.validateDrop(target, source, origin, true)) {
            return false;
          }
          hash = location.hash;
          selection = Spine.dragItem.selection;
          switch (source.constructor.className) {
            case 'Product':
              cb = (function(_this) {
                return function() {
                  if (!_this.isMeta(e)) {
                    return Product.trigger('destroy:join', Product.toRecords(selection), origin);
                  }
                };
              })(this);
              return Product.trigger('create:join', Product.toRecords(selection), target, cb);
            case 'Photo':
              photos = Photo.toRecords(selection);
              cb = (function(_this) {
                return function() {
                  if (!_this.isMeta(e)) {
                    Photo.trigger('destroy:join', {
                      photos: photos,
                      product: origin
                    });
                  }
                  return _this.navigate(hash);
                };
              })(this);
              return Photo.trigger('create:join', photos, target, cb);
          }
        },
        validateDrop: (function(_this) {
          return function(target, source, origin, alrt) {
            var i, item, items, j, len, len1, oid, res2, sid, tid;
            tid = target != null ? target.id : void 0;
            sid = source != null ? source.id : void 0;
            oid = origin != null ? origin.id : void 0;
            if (!(((tid != null) && (sid != null)) || (tid === sid))) {
              return false;
            }
            switch (source.constructor.className) {
              case 'Product':
                if (['Category', 'ProductsTrash'].indexOf(target.constructor.className) === -1) {
                  return false;
                }
                res2 = oid === tid;
                if (res2) {
                  return false;
                }
                items = CategoriesProduct.filter(target.id, {
                  associationForeignKey: 'category_id'
                });
                for (i = 0, len = items.length; i < len; i++) {
                  item = items[i];
                  if (item.product_id === source.id) {
                    return false;
                  }
                }
                return true;
              case 'Photo':
                if ((target != null ? target.constructor.className : void 0) !== 'Product') {
                  return false;
                }
                if (oid === tid) {
                  return false;
                }
                items = ProductsPhoto.filter(target.id, {
                  associationForeignKey: 'product_id'
                });
                for (j = 0, len1 = items.length; j < len1; j++) {
                  item = items[j];
                  if (item.photo_id === sid) {
                    return false;
                  }
                }
                return true;
              default:
                return false;
            }
          };
        })(this)
      };
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Drag = Controller.Drag;
  }

}).call(this);
 },"extensions/filter": function(exports, require, module) { (function() {
  var $, Filter, Model, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Filter = {
    extended: function() {
      var extend, include;
      extend = {
        options: {
          func: 'select'
        },
        filter: function(query, options) {
          var opts;
          opts = $.extend({}, this.options, options);
          if (!query) {
            return this.all();
          }
          return this.select(function(item) {
            return item[opts.func](query, opts);
          });
        },
        filterSortByOrder: function(query, options) {
          return (this.filter(query, options)).sort(this.sortByOrder);
        },
        filterRelated: function(id, options) {
          var definition, foreignKey, joinTableItems, model, ret, sort;
          definition = this.foreignModels()[options.model];
          model = definition.model;
          foreignKey = definition.foreignKey;
          joinTableItems = Model[definition.joinTable].filter(id, definition);
          ret = this.findRelated(joinTableItems, foreignKey);
          if (sort = options != null ? options.sort : void 0) {
            return ret.sort(this[sort]);
          }
          return ret;
        },
        nameSort: function(a, b) {
          var aa, bb, ref, ref1;
          aa = (ref = (a || '').name) != null ? ref.toLowerCase() : void 0;
          bb = (ref1 = (b || '').name) != null ? ref1.toLowerCase() : void 0;
          if (aa === bb) {
            return 0;
          } else if (aa < bb) {
            return -1;
          } else {
            return 1;
          }
        },
        sortByOrder: function(a, b) {
          var aInt, bInt;
          aInt = parseInt(a.order);
          bInt = parseInt(b.order);
          if (aInt < bInt) {
            return -1;
          } else if (aInt > bInt) {
            return 1;
          } else {
            return 0;
          }
        },
        sortByReverseOrder: function(a, b) {
          var aInt, bInt;
          aInt = parseInt(a.order);
          bInt = parseInt(b.order);
          if (aInt < bInt) {
            return 1;
          } else if (aInt > bInt) {
            return -1;
          } else {
            return 0;
          }
        },
        sortByScreenName: function(a, b) {
          a = a.screenname;
          b = b.screenname;
          if (a < b) {
            return -1;
          } else if (a > b) {
            return 1;
          } else {
            return 0;
          }
        }
      };
      include = {
        select: function(query) {
          var atts, key, value;
          query = query != null ? query.toLowerCase() : void 0;
          atts = (this.selectAttributes || this.attributes).apply(this);
          for (key in atts) {
            value = atts[key];
            value = value != null ? value.toLowerCase() : void 0;
            if (!((value != null ? value.indexOf(query) : void 0) === -1)) {
              return true;
            }
          }
          return false;
        }
      };
      this.extend(extend);
      return this.include(include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Filter = Filter;
  }

}).call(this);
 },"extensions/init_db": function(exports, require, module) { (function() {
  var $, Flash, Log, Model, Spine,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Log = Spine.Log;

  Flash = require("models/flash");

  Model.Extender = {
    extended: function() {
      var Extend, Include;
      Extend = {
        trace: !Spine.isProduction,
        logPrefix: '(' + this.className + ')',
        guid: function() {
          var back, diff, mask, milli, re1, re2, re3, re4, res, ret, sub;
          mask = [8, 4, 4, 4, 12];
          ret = [];
          ret = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = mask.length; i < len; i++) {
              sub = mask[i];
              res = null;
              milli = new Date().getTime();
              back = new Date().setTime(milli * (-200));
              diff = milli - back;
              re1 = diff.toString(16).split('');
              re2 = re1.slice(sub * (-1));
              re3 = re2.join('');
              results.push(re3);
            }
            return results;
          })();
          re4 = ret.join('-');
          return re4;
        },
        uuid: function() {
          var s4;
          s4 = function() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
          };
          return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        },
        record: false,
        selection: [
          {
            global: []
          }
        ],
        current: function(recordOrID) {
          var id, prev, rec, ref, same;
          id = (recordOrID != null ? recordOrID.id : void 0) || recordOrID;
          rec = this.find(id) || false;
          prev = this.record;
          this.record = rec;
          same = !!(((ref = this.record) != null ? typeof ref.eql === "function" ? ref.eql(prev) : void 0 : void 0) && !!prev);
          Model[this.className].trigger('current', this.record, !same);
          if (!same) {
            Model[this.className].trigger('change:current', this.record, this.className);
          }
          return this.record;
        },
        selectionList: function(recordID) {
          var i, id, item, len, ref, ref1, ref2, ret;
          ret = [];
          id = recordID || ((ref = this.record) != null ? ref.id : void 0) || ((ref1 = this.record) != null ? ref1.cid : void 0);
          if (!id) {
            return this.selection[0].global;
          }
          ref2 = this.selection;
          for (i = 0, len = ref2.length; i < len; i++) {
            item = ref2[i];
            if (item[id]) {
              return item[id];
            }
          }
          return ret;
        },
        updateSelection: function(list, id, options) {
          var defaults, option, ref, ret;
          if (list == null) {
            list = this.selectionList();
          }
          defaults = {
            trigger: true
          };
          option = $().extend(defaults, options);
          ret = this.emptySelection(id, list);
          if (option.trigger) {
            this.trigger('change:selection', ret, id);
          }
          if ((ref = Model[this.childType]) != null) {
            ref.current(ret.first());
          }
          return ret;
        },
        emptySelection: function(id, idOrList) {
          var originalList;
          if (idOrList == null) {
            idOrList = [];
          }
          if (!this.isArray(idOrList)) {
            idOrList = [idOrList];
          }
          originalList = this.selectionList(id);
          [].splice.apply(originalList, [0, originalList.length - 0].concat(idOrList)), idOrList;
          return originalList;
        },
        removeFromSelection: function(id, idOrList, options) {
          var i, index, len, list, originalList;
          if (idOrList == null) {
            idOrList = [];
          }
          originalList = this.selectionList(id);
          if (!this.isArray(idOrList)) {
            idOrList = [idOrList];
          }
          for (i = 0, len = idOrList.length; i < len; i++) {
            id = idOrList[i];
            if ((index = originalList.indexOf(id)) !== -1) {
              originalList.splice(index, 1);
            }
          }
          list = this.updateSelection(id, originalList.slice(0), options);
          return list;
        },
        isArray: function(value) {
          return Object.prototype.toString.call(value) === "[object Array]";
        },
        isObject: function(value) {
          return Object.prototype.toString.call(value) === "[object Object]";
        },
        isString: function(value) {
          return Object.prototype.toString.call(value) === "[object String]";
        },
        selected: function() {
          return this.record;
        },
        toId: function(records) {
          var i, len, record, results;
          if (records == null) {
            records = this.records;
          }
          results = [];
          for (i = 0, len = records.length; i < len; i++) {
            record = records[i];
            results.push(record.id);
          }
          return results;
        },
        toRecords: function(ids) {
          var i, id, len, results;
          if (ids == null) {
            ids = [];
          }
          results = [];
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            results.push(this.find(id));
          }
          return results;
        },
        duplicate: function(items, atts, options) {
          var item, newItem, ret;
          if (atts == null) {
            atts = {};
          }
          if (!Array.isArray(items)) {
            items = [items];
          }
          ret = [];
          ret = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              newItem = item.dup(true).save(options);
              newItem.updateAttributes(atts, options);
              results.push(newItem);
            }
            return results;
          })();
          return ret;
        },
        successHandler: function(data, status, xhr) {},
        errorHandler: function(record, xhr, statusText, error) {
          var status;
          status = xhr.status;
          if (status !== 200) {
            error = new Flash({
              record: record,
              xhr: xhr,
              statusText: statusText,
              error: error
            });
            return error.save();
          }
        },
        customErrorHandler: function(record, xhr) {
          var error, status;
          status = xhr.status;
          if (status !== 200) {
            error = new Error({
              flash: '<strong style="color:red">Login failed</strong>',
              xhr: xhr
            });
            error.save();
            return User.redirect('users/login');
          }
        },
        contains: function() {
          return [];
        },
        createJoinTables: function(arr) {
          var i, joinTables, key, len, results;
          if (!this.isArray(arr)) {
            return;
          }
          joinTables = this.joinTables();
          results = [];
          for (i = 0, len = joinTables.length; i < len; i++) {
            key = joinTables[i];
            results.push(Model[key].refresh(this.createJoins(arr, key), {
              clear: true
            }));
          }
          return results;
        },
        make: function(arr, key) {
          var i, len, obj, results;
          if (!Array.isArray(arr)) {
            return new this(arr);
          }
          results = [];
          for (i = 0, len = arr.length; i < len; i++) {
            obj = arr[i];
            results.push(new this(obj[key]));
          }
          return results;
        },
        activePhotos: function() {
          return Category.activePhotos();
        },
        joinTables: function() {
          var fModels, joinTables, key, value;
          fModels = this.foreignModels();
          joinTables = (function() {
            var results;
            results = [];
            for (key in fModels) {
              value = fModels[key];
              results.push(fModels[key]['joinTable']);
            }
            return results;
          })();
          return joinTables;
        },
        createJoins: function(json, tableName) {
          var i, introspect, len, obj, res;
          res = [];
          introspect = (function(_this) {
            return function(obj) {
              var i, item, j, key, len, len1, results, val;
              if (_this.isObject(obj)) {
                for (key in obj) {
                  val = obj[key];
                  if (key === tableName) {
                    for (i = 0, len = val.length; i < len; i++) {
                      item = val[i];
                      res.push(item);
                    }
                  } else {
                    introspect(obj[key]);
                  }
                }
              }
              if (_this.isArray(obj)) {
                results = [];
                for (j = 0, len1 = obj.length; j < len1; j++) {
                  val = obj[j];
                  results.push(introspect(val));
                }
                return results;
              }
            };
          })(this);
          for (i = 0, len = json.length; i < len; i++) {
            obj = json[i];
            introspect(obj);
          }
          return res;
        }
      };
      Include = {
        trace: !Spine.isProduction,
        logPrefix: this.className + '::',
        selectionList: function() {
          return this.constructor.selectionList(this.id);
        },
        selectionParentList: function() {
          var e, modelName;
          modelName = this.constructor['parent'];
          try {
            return Model[modelName].selectionList();
          } catch (error1) {
            e = error1;
            return [];
          }
        },
        updateSelectionID: function() {
          var i, idx, index, item, len, ref;
          ref = this.constructor.selection;
          for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
            item = ref[idx];
            if (item[this.cid]) {
              index = idx;
            }
          }
          if (index) {
            this.constructor.selection.splice(index, 1);
          }
          return this.init(this);
        },
        removeSelectionID: function() {
          var __itm, __key, __val, __x, _idx, _item, _x, i, j, len, len1, list, modelName, ref, results;
          ref = this.constructor.selection;
          for (_idx = i = 0, len = ref.length; i < len; _idx = ++i) {
            _item = ref[_idx];
            if (_item[this.id]) {
              _x = _idx;
            }
          }
          if (_x) {
            this.constructor.selection.splice(_x, 1);
          }
          modelName = this.constructor['parent'];
          if (!modelName) {
            return;
          }
          list = Model[modelName].selection;
          results = [];
          for (j = 0, len1 = list.length; j < len1; j++) {
            __itm = list[j];
            results.push((function() {
              var results1;
              results1 = [];
              for (__key in __itm) {
                __val = __itm[__key];
                if (!(__x = __val.indexOf(this.id) === -1)) {
                  results1.push(__val.splice(__x, 1));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }).call(this));
          }
          return results;
        },
        removeFromSelection: function(list, options) {
          return this.constructor.removeFromSelection(this.id, list, options);
        },
        updateSelection: function(list, options) {
          if (list == null) {
            list = [];
          }
          if (!this.constructor.isArray(list)) {
            list = [list];
          }
          return list = this.constructor.updateSelection(list, this.id, options);
        },
        emptySelection: function() {
          var list;
          return list = this.constructor.emptySelection(this.id);
        },
        addRemoveSelection: function(isMetaKey) {
          var originalList;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (isMetaKey) {
            this.addUnique(originalList);
          } else {
            this.toggleSelected(originalList);
          }
          return originalList;
        },
        addToSelection: function(isMetaKey) {
          var originalList, ref;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (isMetaKey) {
            this.addUnique(originalList);
          } else {
            if (ref = this.id, indexOf.call(originalList, ref) < 0) {
              originalList.unshift(this.id);
            }
          }
          return originalList;
        },
        shiftSelection: function() {
          var index, originalList, rm;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (index = originalList.indexOf(this.id) === 0) {
            return originalList;
          }
          rm = originalList.splice(0, 1, originalList[index]);
          originalList.splice(index, 1);
          originalList.push(rm[0]);
          index = originalList.indexOf(this.id);
          return originalList;
        },
        updateChangedAttributes: function(atts) {
          var invalid, key, origAtts, value;
          this.log('updateChangedAttributes');
          invalid = false;
          origAtts = this.selectAttributes();
          for (key in atts) {
            value = atts[key];
            if (origAtts[key] !== value) {
              invalid = true;
              this[key] = value;
            }
          }
          if (invalid) {
            return this.save();
          }
        },
        addUnique: function(list) {
          var ref;
          [].splice.apply(list, [0, list.length - 0].concat(ref = [this.id])), ref;
          return list;
        },
        toggleSelected: function(list) {
          var index, ref;
          if (ref = this.id, indexOf.call(list, ref) < 0) {
            list.unshift(this.id);
          } else {
            index = list.indexOf(this.id);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
          return list;
        },
        searchSelect: function(query) {
          var atts, key, value;
          query = query.toLowerCase();
          atts = this.selectAttributes.apply(this);
          for (key in atts) {
            value = atts[key];
            value = value.toLowerCase();
            if (!((value != null ? value.indexOf(query) : void 0) === -1)) {
              return true;
            }
          }
          return false;
        },
        idSelect: function(query) {
          var value;
          query = query.toLowerCase();
          value = this.id.toLowerCase();
          if (!((value != null ? value.indexOf(query) : void 0) === -1)) {
            return true;
          }
          return false;
        },
        idExcludeSelect: function(query) {
          if (query.indexOf(this.id) === -1) {
            return true;
          }
          return false;
        },
        defaultDetails: {
          iCount: 0,
          aCount: 0,
          sCount: 0,
          author: ''
        }
      };
      this.include(Log);
      this.extend(Log);
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Extender;
  }

}).call(this);
 },"extensions/key_enhancer": function(exports, require, module) { (function() {
  var $, Controller, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  Controller.KeyEnhancer = {
    extended: function() {
      var Extend, Include;
      Extend = {
        events: {
          'keyup': 'keyup',
          'keypress input': 'stopPropagation',
          'keypress textarea': 'stopPropagation'
        }
      };
      Include = {
        init: function() {
          if (this.constructor.events) {
            return this.delegateEvents(this.constructor.events);
          }
        },
        stopPropagation: function(e) {
          return e.stopPropagation();
        },
        keyup: function(e) {
          this.log(e);
          this.log(this);
          return e.stopPropagation();
        }
      };
      this.include(Include);
      return this.extend(Extend);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Controller.KeyEnhancer;
  }

}).call(this);
 },"extensions/manager": function(exports, require, module) { (function() {
  var $, Log, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Log = Spine.Log;

  Spine.Manager = require('spine/lib/manager');

  Spine.Manager.extend.Log;

  Spine.Manager.extend({
    deactivate: function() {
      this.log('deactivate');
      return this.constructor.apply(this, arguments);
    }
  });

  Spine.Manager.include({
    disableDrag: function() {
      this.el.draggable('disable');
      return !this.el.draggable("option", "disabled");
    },
    enableDrag: function() {
      this.el.draggable('enable');
      return !this.el.draggable("option", "disabled");
    },
    initDrag: function(el, opts) {
      var defaults, dim, max, min, options, ori, rev;
      if (!el) {
        return;
      }
      this.el = el;
      defaults = {
        manager: this,
        initSize: function() {
          return 500;
        },
        disabled: false,
        sleep: true,
        axis: 'x',
        min: function() {
          return 20;
        },
        max: function() {
          return 300;
        },
        tol: 50,
        handle: '.draghandle',
        goSleep: function() {},
        awake: function() {}
      };
      options = $.extend({}, defaults, opts);
      ori = options.axis === 'y' ? 'top' : 'left';
      dim = options.axis === 'y' ? 'height' : 'width';
      rev = options.axis === 'y' ? 1 : -1;
      min = options.min;
      max = options.max;
      this.sleep = options.sleep;
      this.currentDim = options.initSize.call(this);
      if (options.disabled) {
        this.disableDrag();
      }
      this.goSleep = (function(_this) {
        return function() {
          _this.sleep = true;
          options.goSleep();
          return _this.trigger('sleep');
        };
      })(this);
      this.awake = (function(_this) {
        return function() {
          _this.sleep = false;
          options.awake();
          return _this.trigger('awake');
        };
      })(this);
      return el.draggable({
        create: (function(_this) {
          return function(e, ui) {
            return _this.el.css({
              position: 'inherit'
            });
          };
        })(this),
        axis: options.axis,
        handle: options.handle,
        start: (function(_this) {
          return function(e, ui) {
            return _this.currentDim = $(ui.helper)[dim]();
          };
        })(this),
        stop: (function(_this) {
          return function(e, ui) {
            if (!_this.el.draggable("option", "disabled")) {
              if (!_this.sleep) {
                return _this.currentDim = $(ui.helper)[dim]();
              }
            }
          };
        })(this),
        drag: (function(_this) {
          return function(e, ui) {
            var _cur, _max, _min, _ori, _pos;
            _ori = ui.originalPosition[ori];
            _pos = ui.position[ori];
            _cur = _this.currentDim;
            _max = max.call(_this);
            _min = min.call(_this);
            return $(ui.helper)[dim](function() {
              var d;
              d = (_cur + _ori) - (_pos * rev);
              if (!_this.sleep) {
                if (d >= _min && d <= _max) {
                  return d;
                }
                if (d < _min) {
                  if (!_this.el.draggable("option", "disabled")) {
                    _this.goSleep();
                  }
                  return _min;
                }
                if (d > _max) {
                  return _max;
                }
              } else if (d >= _min) {
                if (!_this.el.draggable("option", "disabled")) {
                  _this.awake();
                }
                return d;
              }
            });
          };
        })(this)
      });
    },
    hasActive: function() {
      var controller, i, len, ref;
      ref = this.controllers;
      for (i = 0, len = ref.length; i < len; i++) {
        controller = ref[i];
        if (controller.isActive()) {
          return this.controller = this.last = controller;
        }
      }
      return false;
    },
    active: function() {
      return this.hasActive();
    },
    lastActive: function() {
      return this.last || this.controllers[0];
    },
    externalUI: function(controller) {
      var activeController;
      activeController = controller || this.lastActive();
      return $(activeController.externalClass, this.external.el);
    }
  });

}).call(this);
 },"extensions/model_extender": function(exports, require, module) { (function() {
  var $, Flash, Log, Model, Spine,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Log = Spine.Log;

  Flash = require("models/flash");

  Model.Extender = {
    extended: function() {
      var Extend, Include;
      Extend = {
        trace: !Spine.isProduction,
        logPrefix: '(' + this.className + ')',
        humanName: function() {
          return 'no human Name';
        },
        humanNames: function() {
          return 'no human Names';
        },
        guid: function() {
          var back, diff, mask, milli, re1, re2, re3, re4, res, ret, sub;
          mask = [8, 4, 4, 4, 12];
          ret = [];
          ret = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = mask.length; i < len; i++) {
              sub = mask[i];
              res = null;
              milli = new Date().getTime();
              back = new Date().setTime(milli * (-200));
              diff = milli - back;
              re1 = diff.toString(16).split('');
              re2 = re1.slice(sub * (-1));
              re3 = re2.join('');
              results.push(re3);
            }
            return results;
          })();
          re4 = ret.join('-');
          return re4;
        },
        uuid: function() {
          var s4;
          s4 = function() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
          };
          return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        },
        n: function(inst) {
          return inst.name || inst.screenname || inst.title || inst.src || 'no name';
        },
        "protected": {},
        record: false,
        selection: [
          {
            global: []
          }
        ],
        current: function(recordOrId) {
          var id, prev, rec, ref, same;
          id = (recordOrId != null ? recordOrId.id : void 0) || recordOrId;
          rec = this.find(id) || false;
          prev = this.record;
          this.record = rec;
          same = !!(((ref = this.record) != null ? typeof ref.eql === "function" ? ref.eql(prev) : void 0 : void 0) && !!prev);
          Model[this.className].trigger('current', this.record, !same);
          if (!same) {
            Model[this.className].trigger('change:current', this.record, this.className);
          }
          return this.record;
        },
        selectionList: function(recordID) {
          var i, id, item, len, ref, ref1, ref2, ret;
          ret = [];
          id = recordID || ((ref = this.record) != null ? ref.id : void 0) || ((ref1 = this.record) != null ? ref1.cid : void 0);
          if (!id) {
            return this.selection[0].global;
          }
          ref2 = this.selection;
          for (i = 0, len = ref2.length; i < len; i++) {
            item = ref2[i];
            if (item[id]) {
              return item[id];
            }
          }
          return ret;
        },
        updateSelection: function(list, id, options) {
          var defaults, option, ref, ret;
          if (list == null) {
            list = this.selectionList();
          }
          defaults = {
            trigger: true
          };
          option = $().extend(defaults, options);
          ret = this.emptySelection(id, list);
          if (option.trigger) {
            this.trigger('change:selection', ret, id);
          }
          if ((ref = Model[this.childType]) != null) {
            ref.current(ret.first());
          }
          return ret;
        },
        emptySelection: function(id, idOrList) {
          var originalList;
          if (idOrList == null) {
            idOrList = [];
          }
          if (!Array.isArray(idOrList)) {
            idOrList = [idOrList];
          }
          originalList = this.selectionList(id);
          [].splice.apply(originalList, [0, originalList.length - 0].concat(idOrList)), idOrList;
          return originalList;
        },
        removeFromSelection: function(id, idOrList, options) {
          var i, index, len, list, originalList;
          if (idOrList == null) {
            idOrList = [];
          }
          originalList = this.selectionList(id);
          if (!Array.isArray(idOrList)) {
            idOrList = [idOrList];
          }
          for (i = 0, len = idOrList.length; i < len; i++) {
            id = idOrList[i];
            if ((index = originalList.indexOf(id)) !== -1) {
              originalList.splice(index, 1);
            }
          }
          list = this.updateSelection(originalList.slice(0), id, options);
          return list;
        },
        isArray: function(value) {
          return Object.prototype.toString.call(value) === "[object Array]";
        },
        isObject: function(value) {
          return Object.prototype.toString.call(value) === "[object Object]";
        },
        isString: function(value) {
          return Object.prototype.toString.call(value) === "[object String]";
        },
        selected: function() {
          return this.record;
        },
        toId: function(records) {
          var i, len, record, results;
          if (records == null) {
            records = this.records;
          }
          results = [];
          for (i = 0, len = records.length; i < len; i++) {
            record = records[i];
            results.push(record.id);
          }
          return results;
        },
        toRecords: function(ids) {
          var i, id, len, results;
          if (ids == null) {
            ids = [];
          }
          results = [];
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            results.push(this.find(id));
          }
          return results;
        },
        duplicate: function(items, atts, options) {
          var item, newItem, ret;
          if (atts == null) {
            atts = {};
          }
          if (!Array.isArray(items)) {
            items = [items];
          }
          ret = [];
          ret = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              newItem = item.dup(true).save(options);
              newItem.updateAttributes(atts, options);
              results.push(newItem);
            }
            return results;
          })();
          return ret;
        },
        successHandler: function(data, status, xhr) {},
        errorHandler: (function(_this) {
          return function(record, xhr, statusText, error) {
            var flash, status;
            status = xhr.status;
            if (status !== 200) {
              flash = (flash = Flash.first()) ? flash : new Flash;
              flash.status = xhr.status;
              flash.statusText = xhr.statusText;
              flash.save();
              return User.redirect('users/login');
            }
          };
        })(this),
        customErrorHandler: function(record, xhr) {
          var flash, status;
          status = xhr.status;
          if (status !== 200) {
            flash = new Flash({
              flash: '<strong style="color:red">Login failed</strong>',
              xhr: xhr
            });
            flash.save();
            return User.redirect('users/login');
          }
        },
        contains: function() {
          return [];
        },
        createJoinTables: function(arr) {
          var i, joinTables, key, len, results;
          if (!this.isArray(arr)) {
            return;
          }
          joinTables = this.joinTables();
          results = [];
          for (i = 0, len = joinTables.length; i < len; i++) {
            key = joinTables[i];
            results.push(Model[key].refresh(this.createJoins(arr, key), {
              clear: true
            }));
          }
          return results;
        },
        make: function(arr, key) {
          var i, len, obj, results;
          if (!Array.isArray(arr)) {
            return new this(arr);
          }
          results = [];
          for (i = 0, len = arr.length; i < len; i++) {
            obj = arr[i];
            results.push(new this(obj[key]));
          }
          return results;
        },
        activePhotos: function() {
          return Category.activePhotos();
        },
        joinTables: function() {
          var fModels, joinTables, key, value;
          fModels = this.foreignModels();
          joinTables = (function() {
            var results;
            results = [];
            for (key in fModels) {
              value = fModels[key];
              results.push(fModels[key]['joinTable']);
            }
            return results;
          })();
          return joinTables;
        },
        createJoins: function(json, tableName) {
          var i, introspect, len, obj, res;
          res = [];
          introspect = (function(_this) {
            return function(obj) {
              var i, item, j, key, len, len1, results, val;
              if (_this.isObject(obj)) {
                for (key in obj) {
                  val = obj[key];
                  if (key === tableName) {
                    for (i = 0, len = val.length; i < len; i++) {
                      item = val[i];
                      res.push(item);
                    }
                  } else {
                    introspect(obj[key]);
                  }
                }
              }
              if (_this.isArray(obj)) {
                results = [];
                for (j = 0, len1 = obj.length; j < len1; j++) {
                  val = obj[j];
                  results.push(introspect(val));
                }
                return results;
              }
            };
          })(this);
          for (i = 0, len = json.length; i < len; i++) {
            obj = json[i];
            introspect(obj);
          }
          return res;
        },
        isProtectedModel: function(model, query) {
          if (model == null) {
            model = this;
          }
          if (model["protected"][query]) {
            return true;
          }
          return false;
        }
      };
      Include = {
        trace: !Spine.isProduction,
        logPrefix: this.className + '::',
        n: function() {
          return this.constructor.n(this);
        },
        isInvalid: function() {
          return !this.isValid();
        },
        silentUpdate: function(atts) {
          var clone, key, records, value;
          for (key in atts) {
            value = atts[key];
            this[key] = value;
          }
          records = this.constructor.irecords;
          records[this.id].load(this.attributes());
          return clone = records[this.id].clone();
        },
        selectionList: function() {
          return this.constructor.selectionList(this.id);
        },
        selectionParentList: function() {
          var e, modelName;
          modelName = this.constructor['parent'];
          try {
            return Model[modelName].selectionList();
          } catch (error1) {
            e = error1;
            return [];
          }
        },
        updateSelectionID: function() {
          var i, idx, index, item, len, ref;
          ref = this.constructor.selection;
          for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
            item = ref[idx];
            if (item[this.cid]) {
              index = idx;
            }
          }
          if (index) {
            this.constructor.selection.splice(index, 1);
          }
          return this.init(this);
        },
        removeSelectionID: function() {
          var __itm, __key, __val, __x, _idx, _item, _x, i, j, len, len1, list, modelName, ref, results;
          ref = this.constructor.selection;
          for (_idx = i = 0, len = ref.length; i < len; _idx = ++i) {
            _item = ref[_idx];
            if (_item[this.id]) {
              _x = _idx;
            }
          }
          if (_x) {
            this.constructor.selection.splice(_x, 1);
          }
          modelName = this.constructor['parent'];
          if (!modelName) {
            return;
          }
          list = Model[modelName].selection;
          results = [];
          for (j = 0, len1 = list.length; j < len1; j++) {
            __itm = list[j];
            results.push((function() {
              var results1;
              results1 = [];
              for (__key in __itm) {
                __val = __itm[__key];
                if (!(__x = __val.indexOf(this.id) === -1)) {
                  results1.push(__val.splice(__x, 1));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }).call(this));
          }
          return results;
        },
        removeFromSelection: function(list, options) {
          list = this.constructor.removeFromSelection(this.id, list, options);
          return list;
        },
        updateSelection: function(list, options) {
          if (list == null) {
            list = [];
          }
          if (!this.constructor.isArray(list)) {
            list = [list];
          }
          return list = this.constructor.updateSelection(list, this.id, options);
        },
        emptySelection: function() {
          var list;
          return list = this.constructor.emptySelection(this.id);
        },
        addRemoveSelection: function(isMetaKey) {
          var originalList;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (isMetaKey) {
            this.addUnique(originalList);
          } else {
            this.toggleSelected(originalList);
          }
          return originalList;
        },
        addToSelection: function(isMetaKey) {
          var originalList, ref;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (isMetaKey) {
            this.addUnique(originalList);
          } else {
            if (ref = this.id, indexOf.call(originalList, ref) < 0) {
              originalList.unshift(this.id);
            }
          }
          return originalList;
        },
        shiftSelection: function() {
          var index, originalList, rm;
          originalList = this.constructor.selectionList(this.id);
          if (!originalList) {
            return;
          }
          if (index = originalList.indexOf(this.id) === 0) {
            return originalList;
          }
          rm = originalList.splice(0, 1, originalList[index]);
          originalList.splice(index, 1);
          originalList.push(rm[0]);
          index = originalList.indexOf(this.id);
          return originalList;
        },
        updateChangedAttributes: function(atts, options) {
          var invalid, key, origAtts, value;
          if (options == null) {
            options = {};
          }
          this.log('updateChangedAttributes');
          invalid = false;
          origAtts = this.selectAttributes();
          for (key in atts) {
            value = atts[key];
            if (origAtts[key] !== value) {
              invalid = true;
              this[key] = value;
            }
          }
          if (invalid) {
            return this.save(options);
          }
        },
        errorHandler: function() {
          var args, ref;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return (ref = this.constructor).errorHandler.apply(ref, [this].concat(slice.call(args)));
        },
        selectAttributes: function() {
          var attr, i, len, ref, result;
          result = {};
          ref = this.constructor.selectAttributes;
          for (i = 0, len = ref.length; i < len; i++) {
            attr = ref[i];
            result[attr] = this[attr];
          }
          return result;
        },
        isProtectedModel: function(model, query) {
          return this.constructor.isProtectedModel(model, query);
        },
        addUnique: function(list) {
          var ref;
          [].splice.apply(list, [0, list.length - 0].concat(ref = [this.id])), ref;
          return list;
        },
        toggleSelected: function(list) {
          var index, ref;
          if (ref = this.id, indexOf.call(list, ref) < 0) {
            list.unshift(this.id);
          } else {
            index = list.indexOf(this.id);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
          return list;
        },
        searchSelect: function(query) {
          var atts, key, value;
          query = query.toLowerCase();
          atts = this.selectAttributes.apply(this);
          for (key in atts) {
            value = atts[key];
            value = String(value).toLowerCase();
            if (!((value != null ? value.indexOf(query) : void 0) === -1)) {
              return true;
            }
          }
          return false;
        },
        idSelect: function(query) {
          var value;
          query = String(query).toLowerCase();
          value = this.id.toLowerCase();
          if (!((value != null ? value.indexOf(query) : void 0) === -1)) {
            return true;
          }
          return false;
        },
        idExcludeSelect: function(query) {
          if (query.indexOf(this.id) === -1) {
            return true;
          }
          return false;
        },
        defaultDetails: {
          iCount: 0,
          aCount: 0,
          sCount: 0,
          author: ''
        }
      };
      this.include(Log);
      this.extend(Log);
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Extender;
  }

}).call(this);
 },"extensions/model_test": function(exports, require, module) { (function() {
  var $, Log, Model, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Log = Spine.Log;

  Model.Model_Test = {
    extended: function() {
      var Extend;
      Extend = {
        print: function() {
          return alert('Hi, this is a Test');
        }
      };
      return this.extend(Extend);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Model_Test;
  }

}).call(this);
 },"extensions/mysql_ajax": function(exports, require, module) { (function() {
  var $, MysqlAjax, Spine;

  Spine = require("spine");

  $ = Spine.$;

  MysqlAjax = {
    extended: function() {
      var extend, include;
      extend = {
        send: function() {}
      };
      include = {
        mysql: function(action, options) {
          if (typeof (options != null ? options.done : void 0) === 'function') {
            this.doneResponse = options.done;
          }
          if (typeof (options != null ? options.fail : void 0) === 'function') {
            this.failResponse = options.fail;
          }
          return this.ajax(action);
        },
        ajax: function(action) {
          return $.ajax({
            url: '/mysql/' + action
          }).done(this.doneResponse).fail(this.failResponse);
        },
        doneResponse: function(xhr, t) {
          console.log(xhr);
          return console.log(t);
        },
        failResponse: function(e) {
          return console.log(e);
        }
      };
      this.extend(extend);
      return this.include(include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MysqlAjax;
  }

}).call(this);
 },"extensions/photo_extender": function(exports, require, module) { (function() {
  var $, Controller, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  require('extensions/controller_extender');

  Controller.PhotoExtender = {
    extended: function() {
      var Extend, Include;
      Extend = {
        empty: function() {
          this.log('empty');
          return this.constructor.apply(this, arguments);
        }
      };
      Include = {
        updateTemplate: function(item) {
          var active, css, el, hot, tb, tmplItem;
          el = this.children().forItem(item);
          tb = $('.thumbnail', el);
          css = tb.attr('style');
          active = el.hasClass('active');
          hot = el.hasClass('hot');
          tmplItem = el.tmplItem();
          tmplItem.data = item;
          tmplItem.update();
          el = this.children().forItem(item);
          tb = $('.thumbnail', el);
          tb.attr('style', css).addClass('show');
          el.toggleClass('active', active);
          el.toggleClass('hot', hot);
          this.el.sortable('destroy').sortable('photos');
          return tmplItem;
        },
        callback: function(json) {
          var i, jsn, key, len, res, result, results, ret, val;
          result = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = json.length; i < len; i++) {
              jsn = json[i];
              ret = (function() {
                var results1;
                results1 = [];
                for (key in jsn) {
                  val = jsn[key];
                  results1.push({
                    src: val.src,
                    id: key
                  });
                }
                return results1;
              })();
              results.push(ret[0]);
            }
            return results;
          })();
          results = [];
          for (i = 0, len = result.length; i < len; i++) {
            res = result[i];
            results.push(this.snap(res));
          }
          return results;
        },
        snap: function(res) {
          var el, img, thumb;
          el = $('#' + res.id, this.el);
          thumb = $('.thumbnail', el);
          img = this.createImage();
          img.element = el;
          img.thumb = thumb;
          img.me = this;
          img.res = res;
          img.onload = this.onLoad;
          img.onerror = this.onError;
          return img.src = res.src;
        },
        onLoad: function() {
          var css;
          this.me.log('image loaded');
          css = 'url(' + this.src + ')';
          this.thumb.css({
            'backgroundImage': css,
            'backgroundSize': '100% auto'
          });
          return this.thumb.addClass('show');
        },
        onError: function(e) {
          console.log('could not load image, trying again');
          this.onload = null;
          return this.onerror = null;
        },
        size: function(val, bg) {
          var thumb;
          if (bg == null) {
            bg = 'none';
          }
          thumb = $('.thumbnail', this.el);
          return thumb.css({
            'height': val + 'px',
            'width': val + 'px',
            'backgroundSize': bg
          });
        }
      };
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Controller.PhotoExtender;
  }

}).call(this);
 },"extensions/product_extender": function(exports, require, module) { (function() {
  var $, Controller, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Controller = Spine.Controller;

  require('extensions/controller_extender');

  Controller.ProductExtender = {
    extended: function() {
      var Extend, Include;
      Extend = {
        empty: function() {
          this.log('empty');
          return this.constructor.apply(this, arguments);
        }
      };
      Include = {
        renderBackgrounds: function(products) {
          var deferredProcess, i, len, product, results;
          if (products == null) {
            products = [];
          }
          this.log('renderBackgrounds');
          deferredProcess = (function(_this) {
            return function(product) {
              var args, deferred, n, photos, single;
              _this.log('deferredProcess');
              deferred = $.Deferred();
              photos = product.photos(4);
              n = (n = photos.length) === 1 ? n : 4;
              single = !!(n === 1);
              args = single ? [140, 140] : [68, 68];
              photos = photos.sort(Photo.sortByReverseOrder);
              product.single = single;
              _this.callDeferred(photos, _this.uriSettings.apply(_this, args), function(xhr) {
                return deferred.resolve(xhr, product);
              });
              return deferred.promise();
            };
          })(this);
          if (!Array.isArray(products)) {
            products = [products];
          }
          results = [];
          for (i = 0, len = products.length; i < len; i++) {
            product = products[i];
            results.push($.when(deferredProcess(product)).done((function(_this) {
              return function(xhr, rec) {
                return _this.callback(xhr, rec);
              };
            })(this)));
          }
          return results;
        },
        callback: function(json, product) {
          var c, css, cssdefault, el, i, j, jsn, key, len, len1, results, sources, src, thumb, val;
          el = $('[data-id=' + (product != null ? product.id : void 0) + ']', this.el);
          thumb = $('.thumbnail', el);
          sources = [];
          css = [];
          cssdefault = [];
          for (i = 0, len = json.length; i < len; i++) {
            jsn = json[i];
            for (key in jsn) {
              val = jsn[key];
              if (src = val.src) {
                sources.push(src);
              }
              css.push('url(' + src + ')');
              cssdefault.push('url(/img/ajax-loader-product-thumbs.gif)');
            }
          }
          if (sources.length) {
            thumb.addClass('load');
            thumb.css('backgroundImage', (function() {
              var j, len1, results;
              results = [];
              for (j = 0, len1 = cssdefault.length; j < len1; j++) {
                c = cssdefault[j];
                results.push(c);
              }
              return results;
            })());
            results = [];
            for (j = 0, len1 = sources.length; j < len1; j++) {
              src = sources[j];
              results.push(this.snap(product, thumb, src, css));
            }
            return results;
          } else {
            return thumb.css('backgroundImage', ['url(/img/drag_info.png)']);
          }
        },
        snap: function(rec, el, src, css) {
          var img;
          img = this.createImage();
          img.el = el;
          img.single = rec.single;
          img.me = this;
          img.css = css;
          img.src = src;
          img.onload = this.onLoad;
          return img.onerror = this.onError;
        },
        onLoad: function() {
          this.me.log('image loaded');
          this.el.removeClass('load');
          if (this.single) {
            this.el.addClass('single');
          }
          return this.el.css('backgroundImage', this.css);
        },
        onError: function(e) {
          return this.me.snap(this.res);
        },
        updateTemplate: function(item) {
          var active, hot, innerEl, itemEl, style, tmplItem;
          this.log('updateTemplate');
          if (!item || item.destroyed || item.deleted) {
            return;
          }
          item = this.mixinOne(item);
          itemEl = this.children().forItem(item);
          active = itemEl.hasClass('active');
          hot = itemEl.hasClass('hot');
          innerEl = $('.thumbnail', itemEl);
          style = innerEl.attr('style');
          tmplItem = itemEl.tmplItem();
          tmplItem.data = item;
          if (typeof tmplItem.update === "function") {
            tmplItem.update();
          }
          itemEl = this.children().forItem(item);
          itemEl.attr('id', item.id);
          itemEl.toggleClass('active', active);
          itemEl.toggleClass('hot', hot);
          itemEl.toggleClass('ignored', item.ignored);
          innerEl = $('.thumbnail', itemEl);
          innerEl.attr('style', style);
          return this.el.sortable();
        }
      };
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Controller.ProductExtender;
  }

}).call(this);
 },"extensions/selector": function(exports, require, module) { (function() {
  var $, Model, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Model.Selector = {
    extended: function() {
      var Extend, Include;
      Extend = {
        selections_: [
          {
            global: []
          }
        ],
        selectionsList: (function(_this) {
          return function(recordID) {
            var i, id, item, len, ref;
            id = recordID || 'global';
            if (!id) {
              return;
            }
            ref = _this.selections;
            for (i = 0, len = ref.length; i < len; i++) {
              item = ref[i];
              if (item[id]) {
                return item[id];
              }
            }
            throw 'record ' + id + ' is not configured ';
          };
        })(this),
        selection_: function(id) {
          var i, item, key, len, selected, val;
          this.log(this.parent);
          return;
          selected = this.selectionsList(id);
          if (!selected) {
            return;
          }
          for (i = 0, len = selected.length; i < len; i++) {
            item = selected[i];
            for (key in item) {
              val = item[key];
              if (item[url]) {
                return val[0];
              }
            }
          }
        },
        initSelection_: function(id) {
          var arr;
          arr = this.selections;
          arr.push(this.hash(id));
          return arr;
        },
        hash_: function(key) {
          var o;
          o = new Object();
          o[key] = [];
          return o;
        },
        add: function(item) {
          return this.log(item.parent());
        },
        hasCache_: function(url, id) {
          return !!(this.cache(url, id));
        },
        addToCache_: function(url, uris) {
          var i, item, itm, itm_url, key, len, results, uri, val;
          results = [];
          for (i = 0, len = uris.length; i < len; i++) {
            uri = uris[i];
            results.push((function() {
              var results1;
              results1 = [];
              for (key in uri) {
                val = uri[key];
                item = this.cacheList(key);
                if (!this.keyExists.call(item, url)) {
                  item.push(this.hash(url));
                }
                results1.push((function() {
                  var j, len1, ref, results2;
                  results2 = [];
                  for (j = 0, len1 = item.length; j < len1; j++) {
                    itm = item[j];
                    if (itm_url = itm[url]) {
                      [].splice.apply(itm_url, [0, itm_url.length - 0].concat(ref = [])), ref;
                      results2.push(itm_url.push(uri));
                    } else {
                      results2.push(void 0);
                    }
                  }
                  return results2;
                })());
              }
              return results1;
            }).call(this));
          }
          return results;
        },
        itemExists: function(item) {
          var i, key, len, ref, thisItem, val;
          for (key in item) {
            val = item[key];
            ref = this;
            for (i = 0, len = ref.length; i < len; i++) {
              thisItem = ref[i];
              if (thisItem[key]) {
                return thisItem;
              }
            }
          }
          return false;
        },
        keyExists: function(key) {
          var i, len, ref, thisItem;
          ref = this;
          for (i = 0, len = ref.length; i < len; i++) {
            thisItem = ref[i];
            if (thisItem[key]) {
              return thisItem;
            }
          }
          return false;
        },
        destroyCache: function(id) {
          var findIdFromObject, findItemsFromArray, i, idx, itm, len, list, results;
          list = this.cacheList();
          findIdFromObject = function(id, obj) {
            var arr, i, idx, itm, key, len, value;
            for (key in obj) {
              value = obj[key];
              arr = obj[key];
              for (idx = i = 0, len = arr.length; i < len; idx = ++i) {
                itm = arr[idx];
                if (itm[id]) {
                  return arr.splice(idx, 1);
                }
              }
            }
          };
          findItemsFromArray = function(items) {
            var i, itm, ix, len, results;
            results = [];
            for (ix = i = 0, len = items.length; i < len; ix = ++i) {
              itm = items[ix];
              results.push(findIdFromObject(id, itm));
            }
            return results;
          };
          results = [];
          for (idx = i = 0, len = list.length; i < len; idx = ++i) {
            itm = list[idx];
            if (itm[id]) {
              results.push(list.splice(idx, 1));
            } else {
              results.push(void 0);
            }
          }
          return results;
        },
        clearCache: function(id) {
          var originalList, ref;
          originalList = this.cacheList(id);
          [].splice.apply(originalList, [0, originalList.length - 0].concat(ref = [])), ref;
          return originalList;
        }
      };
      Include = {
        cache: function(url) {
          return this.constructor.cache(this, url);
        },
        addToCache: function(url, uri, mode) {
          return this.constructor.addToCache(this, url, uri, mode);
        },
        destroyCache: function() {
          return this.constructor.destroyCache(this.id);
        },
        clearCache: function() {
          var list;
          return list = this.constructor.clearCache(this.id);
        },
        add: function() {
          return this.constructor.add(this);
        }
      };
      this.extend(Extend);
      return this.include(Include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Selector;
  }

}).call(this);
 },"extensions/sortable": function(exports, require, module) { (function() {
  $.fn.sortable = function(type) {
    return $(this).Html5Sortable({
      type: type,
      drop: function(source, target) {
        return true;
      }
    });
  };

  $.Html5Sortable = function() {
    return $.Html5Sortable.s_currentID = Math.floor(Math.random() * 10000001);
  };

  $.Html5Sortable.DRAGANDDROP_DEFAULT_TYPE = "de.webpremiere.html5sortable";

  $.Html5Sortable.s_currentID = 0;

  $.Html5Sortable.defaultOptions = {
    dragTarget: function(source) {
      return $(source);
    },
    text: function(source) {
      return $('<div></div>').append($(source).clone(true)).html();
    },
    css: function(source) {
      var el;
      el = $(source);
      return {
        'height': el.css('height'),
        'padding-top': el.css('padding-top'),
        'padding-bottom': el.css('padding-bottom'),
        'margin-top': el.css('margin-top'),
        'margin-bottom': el.css('margin-bottom')
      };
    },
    klass: function(source) {
      return 'html5sortable-state-highlight';
    },
    splitter: function(source) {
      return ($($('li.' + this.klass())[0] || $('<li class="' + this.klass() + '"></li>'))).css(this.css(source));
    },
    type: $.Html5Sortable.DRAGANDDROP_DEFAULT_TYPE,
    drop: function(source, target) {
      return false;
    }
  };

  $.fn.Html5Sortable = function(opts) {
    var options;
    options = $.extend({}, $.Html5Sortable.defaultOptions, opts);
    $.Html5Sortable.s_currentID++;
    if (options.type === $.Html5Sortable.DRAGANDDROP_DEFAULT_TYPE) {
      options.type = options.type + '_' + $.Html5Sortable.s_currentID;
    }
    return this.each(function() {
      var that;
      that = $(this);
      that.init = function(el) {
        return options.dragTarget(el).attr('draggable', true).bind('dragstart', function(e) {
          var dt;
          dt = e.originalEvent.dataTransfer;
          dt.effectAllowed = 'move';
          dt.setData('Text', JSON.stringify({
            html: options.text(el),
            type: options.type
          }));
          Spine.sortItem = {
            el: el,
            data: el.data(),
            splitter: options.splitter(this),
            cond: null
          };
          $('._dragging').removeClass('_dragging');
          el.addClass('_dragging out');
          alert('clear');
          return this.log($('._dragging'));
        }).bind('dragend', function(e) {
          var ref;
          this.log('dragend');
          $('._dragging').removeClass('_dragging');
          if ((ref = Spine.sortItem.el) != null) {
            ref.addClass('show').removeClass('fade');
          }
          return Spine.sortItem.splitter.remove();
        }).bind('dragenter', function(e) {
          var cond;
          if (!Spine.sortItem) {
            return;
          }
          Spine.sortItem.cond = cond = (e.originalEvent.pageX - $(this).position().left) > ($(this).width());
          if (cond) {
            Spine.sortItem.splitter.insertAfter(this);
          } else {
            Spine.sortItem.splitter.insertBefore(this);
          }
          return false;
        }).bind('dragleave', function(e) {
          try {
            if (!(e.originalEvent.dataTransfer.getData('Text') && JSON.parse(e.originalEvent.dataTransfer.getData('Text')).type === options.type)) {
              return true;
            }
          } catch (error) {
            e = error;
            return true;
          }
          return false;
        }).bind('drop', function(e) {
          var cond, it, model, sourceEl;
          try {
            this.log('drop');
            cond = Spine.sortItem.cond;
            if (!(JSON.parse(e.originalEvent.dataTransfer.getData('Text')).type === options.type)) {
              return true;
            }
          } catch (error) {
            e = error;
            return true;
          }
          sourceEl = $('._dragging');
          if (!sourceEl.length) {
            alert('no element for sourceEl');
          }
          Spine.sortItem.splitter.remove();
          it = $(JSON.parse(e.originalEvent.dataTransfer.getData('Text')).html).addClass('out');
          it.data(Spine.sortItem.data);
          model = $(it).item().constructor.className;
          if (!options.drop(sourceEl.get(0), it.get(0))) {
            return it.remove();
          } else {
            if (cond) {
              it.insertAfter(this);
            } else {
              it.insertBefore(this);
            }
            sourceEl.remove();
            that.init(it);
            it.addClass('show');
            $('._dragging').removeClass('_dragging');
            it.removeClass('fade');
            return Spine.Model[model].trigger('sortupdate', e, it);
          }
        });
      };
      return that.children('li').each(function() {
        return that.init($(this));
      });
    });
  };

}).call(this);
 },"extensions/test": function(exports, require, module) { (function() {
  var $, Spine;

  Spine = require("spine");

  $ = Spine.$;

  Spine.Module.extend({
    isProduction: function(bool) {
      if (bool != null) {
        return Spine.isProduction = bool;
      } else {
        return Spine.isProduction;
      }
    }
  });

}).call(this);
 },"extensions/tmpl": function(exports, require, module) { (function() {
  var $;

  $ = typeof jQuery !== "undefined" && jQuery !== null ? jQuery : require("jqueryify");

  $.fn.item_ = function(keep) {
    var item;
    item = $(this).tmplItem().data;
    if (!keep) {
      return typeof item.reload === "function" ? item.reload() : void 0;
    } else {
      return item;
    }
  };

  $.fn.item = function() {
    var item;
    return item = $(this).tmplItem().data;
  };

  $.fn.forItem = function(item) {
    if (item == null) {
      item = {};
    }
    return this.filter(function() {
      var compare;
      compare = $(this).item();
      return (typeof item.eql === "function" ? item.eql(compare) : void 0) || item === compare;
    });
  };

  $.fn.serializeForm = function() {
    var result;
    result = {};
    $.each($(this).find('input,textarea').serializeArray(), function(i, item) {
      return result[item.name] = item.value;
    });
    return result;
  };

}).call(this);
 },"extensions/uri": function(exports, require, module) { (function() {
  var $, Ajax, Base, CategoriesProduct, Category, Model, Photo, Product, ProductsPhoto, Spine, URI, URICollection, Uri,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  CategoriesProduct = require('models/categories_product');

  Ajax = {
    enabled: true,
    cache: true,
    pending: false,
    requests: [],
    requestNext: function() {
      var next;
      next = this.requests.shift();
      if (next) {
        return this.request(next);
      } else {
        this.pending = false;
        return Spine.trigger('uri:alldone');
      }
    },
    request: function(callback) {
      return (callback()).done((function(_this) {
        return function() {
          return _this.requestNext();
        };
      })(this));
    },
    queue: function(callback) {
      if (!this.enabled) {
        return;
      }
      if (this.pending) {
        this.requests.push(callback);
      } else {
        this.pending = true;
        this.request(callback);
      }
      return callback;
    }
  };

  Base = (function() {
    function Base() {}

    Base.prototype.defaults = {
      contentType: 'application/json',
      processData: false,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      },
      dataType: 'json'
    };

    Base.prototype.ajax = function(params, defaults) {
      return $.ajax($.extend({}, this.defaults, defaults, params));
    };

    Base.prototype.ajaxQueue = function(callback) {
      return Ajax.queue(callback);
    };

    Base.prototype.get = function() {
      return this.ajaxQueue((function(_this) {
        return function() {
          return _this.ajax({
            type: "POST",
            url: base_url + 'photos/uri/' + _this.atts,
            data: JSON.stringify(_this.data)
          }).done(_this.recordResponse).fail(_this.failResponse);
        };
      })(this));
    };

    Base.prototype.uri = function(options) {
      return options.width + '/' + options.height + '/' + options.square + '/' + options.quality;
    };

    return Base;

  })();

  URI = (function(superClass) {
    extend(URI, superClass);

    function URI(model, params, callback1, data1) {
      var options;
      this.model = model;
      this.callback = callback1;
      this.data = data1 != null ? data1 : [];
      this.failResponse = bind(this.failResponse, this);
      this.recordResponse = bind(this.recordResponse, this);
      URI.__super__.constructor.apply(this, arguments);
      options = $.extend({}, this.settings, params);
      this.atts = this.uri(options);
      if (!this.data.length) {
        return;
      }
    }

    URI.prototype.settings = {
      square: 1,
      quality: 70
    };

    URI.prototype.init = function() {
      if (!this.cache()) {
        return this.get();
      }
    };

    URI.prototype.cache = function() {
      var data, i, idx, len, raw, ref, res;
      if (!Ajax.cache) {
        return;
      }
      res = [];
      ref = this.data;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        data = ref[idx];
        raw = this.model.cache(this.atts, data.id);
        if (raw) {
          res.push(raw);
        } else {
          return;
        }
      }
      this.callback(res);
      return true;
    };

    URI.prototype.recordResponse = function(uris) {
      this.model.addToCache(this.atts, uris);
      return this.callback(uris);
    };

    URI.prototype.failResponse = function(xhr, statusText, error) {
      return this.model.trigger('ajaxError', xhr, statusText, error);
    };

    return URI;

  })(Base);

  URICollection = (function(superClass) {
    extend(URICollection, superClass);

    function URICollection(record, params, mode, callback1, max) {
      var options, photos, type;
      this.record = record;
      this.callback = callback1;
      this.failResponse = bind(this.failResponse, this);
      this.recordResponse = bind(this.recordResponse, this);
      URICollection.__super__.constructor.apply(this, arguments);
      type = this.record.constructor.className;
      switch (type) {
        case 'Product':
          photos = ProductsPhoto.photos(this.record.id);
          max = max || photos.length;
          this.mode = mode;
          this.photos = photos.slice(0, max);
          break;
        case 'Photo':
          this.photos = [this.record];
      }
      options = $.extend({}, this.settings, params);
      this.atts = this.uri(options);
    }

    URICollection.prototype.settings = {
      width: 140,
      height: 140,
      square: 1,
      quality: 70
    };

    URICollection.prototype.init = function() {
      var cache;
      cache = this.record.cache(this.atts);
      if (cache != null ? cache.length : void 0) {
        return this.callback(cache, this.record);
      } else {
        return this.get();
      }
    };

    URICollection.prototype.all = function() {
      return this.ajaxQueue((function(_this) {
        return function() {
          return _this.ajax({
            type: "POST",
            url: base_url + 'photos/uri/' + _this.atts,
            data: JSON.stringify(_this.photos)
          }).done(_this.recordResponse).fail(_this.failResponse);
        };
      })(this));
    };

    URICollection.prototype.recordResponse = function(uris) {
      this.record.addToCache(this.atts, uris, this.mode);
      return this.callback(uris, this.record);
    };

    URICollection.prototype.failResponse = function(xhr, statusText, error) {
      return this.record.trigger('ajaxError', xhr, statusText, error);
    };

    return URICollection;

  })(Base);

  Uri = {
    extended: function() {
      var Extend, Include;
      Include = {
        uri: function(params, mode, callback, max) {
          return new URICollection(this, params, mode, callback, max).init();
        }
      };
      Extend = {
        uri: function(params, callback, data) {
          return new URI(this, params, callback, data).init();
        }
      };
      this.include(Include);
      return this.extend(Extend);
    }
  };

  Uri.Ajax = Ajax;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Uri = Uri;
  }

}).call(this);
 },"extensions/uri_helper": function(exports, require, module) { (function() {
  var $, Photo, Spine, UriHelper;

  Spine = require("spine");

  $ = Spine.$;

  Photo = require("models/photo");

  UriHelper = {
    extended: function() {
      var include;
      include = {
        callDeferred: function(items, options, cb) {
          if (items == null) {
            items = [];
          }
          options = $().extend(this.uriSettings(), options);
          if (!Array.isArray(items)) {
            items = [items];
          }
          return $.when(this.uriDeferred(items, options)).done((function(_this) {
            return function(xhr) {
              return cb(xhr);
            };
          })(this));
        },
        uriDeferred: function(items, options) {
          var deferred;
          deferred = $.Deferred();
          Photo.uri(options, (function(_this) {
            return function(xhr) {
              return deferred.resolve(xhr);
            };
          })(this), items);
          return deferred.promise();
        },
        cb: (function(_this) {
          return function() {};
        })(this),
        uriSettings: function(width, height, square, quality) {
          if (width == null) {
            width = 30;
          }
          if (height == null) {
            height = 10;
          }
          if (square == null) {
            square = 1;
          }
          if (quality == null) {
            quality = 70;
          }
          return {
            width: width,
            height: height,
            square: square,
            quality: quality
          };
        }
      };
      return this.include(include);
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = UriHelper;
  }

}).call(this);
 },"extensions/utils": function(exports, require, module) { (function() {
  var $;

  $ = typeof jQuery !== "undefined" && jQuery !== null ? jQuery : require("jqueryify");

  $.fn.brace = function(str) {
    if (str == null) {
      str = '';
    }
    str = str.toString();
    return '(' + str + ')';
  };

  $.fn.deselect = function() {
    var els;
    els = $(this).find('.item');
    return els.removeClass('active hot');
  };

  $.fn.name = function(str, l, repl) {
    var ret;
    if (str == null) {
      str = new String;
    }
    if (l == null) {
      l = 1000;
    }
    if (repl == null) {
      repl = '...';
    }
    str = str.toString();
    repl = repl.toString();
    ret = str.slice(0, l);
    if (str.length > l) {
      ret = ret + repl;
    }
    return ret;
  };

  $.extend(jQuery.tmpl.tag, {
    "for": {
      _default: {
        $2: "var i=1;i<=1;i++"
      },
      open: 'for ($2){',
      close: '};'
    }
  });

  $.fn.isFormElement = function(o) {
    var formElements, str;
    if (o == null) {
      o = [];
    }
    str = Object.prototype.toString.call(o[0]);
    formElements = ['[object HTMLInputElement]', '[object HTMLTextAreaElement]'];
    return formElements.indexOf(str) !== -1;
  };

  $.fn.state = function(state) {
    var d;
    d = 'disabled';
    return this.each(function() {
      var $this;
      $this = $(this);
      $this.html($this.data()[state]);
      if (state === 'loading') {
        return $this.addClass(d).attr(d, d);
      } else {
        return $this.removeClass(d).removeAttr(d);
      }
    });
  };

  $.fn.unparam = function(value) {
    var i, len, pair, params, piece, pieces;
    params = {};
    pieces = value.split('&');
    for (i = 0, len = pieces.length; i < len; i++) {
      piece = pieces[i];
      pair = piece.split('=', 2);
      params[decodeURIComponent(pair[0])] = pair.length === 2 ? decodeURIComponent(pair[1].replace(/\+|false/g, '')) : true;
    }
    return params;
  };

  $.fn.position = function(e) {
    var h, info_h, info_w, maxx, maxy, minx, parent, posx, posy, s, t, w, x_offset, y_offset;
    parent = this.parent();
    info_h = this.innerHeight();
    info_w = this.innerWidth();
    w = $(window).width();
    h = $(window).height();
    t = $(window).scrollTop();
    s = parent.scrollTop();
    x_offset = 30;
    y_offset = -20;
    posx = e.pageX + x_offset - parent.offset().left;
    posy = e.pageY + y_offset - parent.offset().top + s;
    maxx = posx + info_w;
    minx = posx - info_w;
    maxy = posy + info_h;
    if (maxx >= w) {
      posx = e.pageX - info_w - x_offset;
    }
    if (maxy >= (h + t)) {
      posy = e.pageY - info_h - y_offset;
    }
    return this.css({
      top: posy + 'px',
      left: posx + 'px'
    });
  };

}).call(this);
 },"home": function(exports, require, module) { (function() {
  var $, App, HomepageView, ModalSimpleView, RefreshView, Settings, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  ModalSimpleView = require("controllers/modal_simple_view");

  HomepageView = require("controllers/homepage_view");

  RefreshView = require('controllers/refresh_view');

  Settings = require("models/settings");

  User = require("models/user");

  App = (function(superClass) {
    extend(App, superClass);

    App.prototype.elements = {
      '#header': 'header',
      '#header .nav.items': 'navItems',
      '#header .nav-item': 'item',
      '#home': 'homeEl',
      '#outdoor': 'outdoorEl',
      '#specials': 'goodiesEl',
      '#fitness': 'outdoorEl',
      '#defense': 'defenseEl',
      '#nav': 'nav',
      '#stats': 'stats',
      '#menu-trigger': 'menutrigger',
      '.logo-1': 'logo1',
      '.logo-2': 'logo2',
      '.sidebar': 'sidebar',
      '#refresh': 'refreshEl',
      '.trustami-badge': 'trustami'
    };

    App.prototype.events = {
      'mouseenter .item-menu': 'background',
      'mouseenter .opt-sidebar': 'showSidebar',
      'mouseleave .opt-sidebar': 'hideSidebar',
      'mouseenter .opt-stats': 'showStats',
      'mousemove  .opt-stats': 'moveStats',
      'mouseleave .opt-stats': 'hideStats',
      'click .opt-hint': 'showWarning',
      'click .opt-agreed': 'agreed',
      'click .opt-close': 'closeSidebar',
      'click .opt-sidebar': 'toggleSidebar',
      'click .sidebar .td:first-child': 'toggleSidebar',
      'click .paypal': 'toggleView',
      'click .opt-del': 'showDelivery',
      'click .opt-agb': 'showAgb',
      'click .opt-imp': 'showImp',
      'click .opt-pay': 'showPay',
      'click .opt-reset': 'reset',
      'click [class^="logo-"], [class*=" logo-"]': 'redirectHome'
    };

    App.prototype.trustamiTemplate = function(item) {
      return $('#trustamiTemplate').tmpl(item);
    };

    function App() {
      var setting;
      App.__super__.constructor.apply(this, arguments);
      this.modal = {
        exists: false
      };
      setting = {
        hidden: false,
        agreed: false,
        sidebaropened: false
      };
      this.refreshView = new RefreshView({
        el: this.refreshEl
      });
      this.home = new HomepageView({
        el: this.homeEl,
        nav: this.navItems,
        categoryName: 'home',
        refreshView: this.refreshView
      });
      this.outdoor = new HomepageView({
        el: this.outdoorEl,
        nav: this.navItems,
        categoryName: 'outdoor',
        refreshView: this.refreshView
      });
      this.defense = new HomepageView({
        el: this.defenseEl,
        nav: this.navItems,
        categoryName: 'defense',
        refreshView: this.refreshView
      });
      this.fitness = new HomepageView({
        el: this.outdoorEl,
        nav: this.navItems,
        categoryName: 'fitness',
        refreshView: this.refreshView
      });
      this.specials = new HomepageView({
        el: this.goodiesEl,
        nav: this.navItems,
        categoryName: 'specials',
        refreshView: this.refreshView
      });
      this.manager = new Spine.Manager(this.home, this.outdoor, this.fitness, this.specials, this.defense);
      this.manager.bind('change', this.proxy(this.viewChanged));
      $(window).bind('hashchange', this.proxy(this.storeHash));
      this.setData();
      this.initSettings(setting);
      this.initSidebar();
      this.initLogos();
      this.initLocation();
      this.routes({
        '/outdoor/': function(params) {
          return this.outdoor.trigger('active');
        },
        '/defense/': function(params) {
          return this.defense.trigger('active');
        },
        '/fitness/': function(params) {
          return this.fitness.trigger('active');
        },
        '/specials/': function(params) {
          return this.specials.trigger('active');
        },
        '/home/': function(params) {
          return this.home.trigger('active');
        },
        '/*glob': function(params) {
          return this.navigate('/home', '');
        }
      });
    }

    App.prototype.checkWarning = function() {
      if (!this.isAgreed()) {
        return this.showWarning();
      }
    };

    App.prototype.initSettings = function(setting) {
      var i, ref, s;
      Settings.fetch();
      if (i = (ref = Settings.first()) != null ? ref.id : void 0) {
        return i;
      }
      s = new Settings(setting);
      s.save();
      return s.id;
    };

    App.prototype.initLocation = function() {
      var hash, settings;
      settings = Settings.loadSettings();
      hash = (hash = settings != null ? settings.hash : void 0) ? hash : '/home';
      return location.hash = hash;
    };

    App.prototype.initLogos = function() {
      var flag;
      flag = Settings.records[0].hidden;
      this.logo1.toggleClass('hide', !!flag);
      return this.logo2.toggleClass('hide', !!!flag);
    };

    App.prototype.getTrustami = function() {
      var callback, user;
      callback = (function(_this) {
        return function(json) {
          var tmi;
          tmi = $.parseJSON(json).tmi;
          return _this.renderTrustami(tmi);
        };
      })(this);
      this.user = !(user = this.user) ? user = new User : user;
      this.user.save();
      return this.user.getTmi(callback);
    };

    App.prototype.initSidebar = function() {
      var isOpen;
      isOpen = Settings.records[0].sidebaropened;
      return this.setSidebar(!isOpen, true);
    };

    App.prototype.storeHash = function() {
      var hash, settings;
      if (!(settings = Settings.loadSettings())) {
        return;
      }
      if (hash = location.hash) {
        settings.hash = hash;
        return settings.save();
      }
    };

    App.prototype.isAgreed = function() {
      var ref;
      return (ref = Settings.first()) != null ? ref.agreed : void 0;
    };

    App.prototype.viewChanged = function(c) {
      this.changeNavbar(c.categoryName);
      this.changeBackground(c.categoryName);
      if (c.categoryName === 'outdoor') {
        this.checkWarning();
      }
      this.refreshView.render();
      return this.getTrustami();
    };

    App.prototype.renderTrustami = function(tmi) {
      return this.trustami.html(this.trustamiTemplate({
        tmi: tmi
      }));
    };

    App.prototype.background = function(e) {
      var el, res, s;
      e.preventDefault();
      e.stopPropagation();
      el = $(e.currentTarget);
      s = el.attr('id');
      res = this.getData(s, this.arr);
      return this.changeBackground(res);
    };

    App.prototype.changeNavbar = function(cat) {
      $('.nav-item', this.navItems).removeClass('active');
      return $('.' + cat, this.navItems).addClass('active');
    };

    App.prototype.changeBackground = function(k) {
      var c, j, len, ref;
      ref = this.manager.controllers;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        this.el.removeClass(c.categoryName);
      }
      return this.el.addClass(k);
    };

    App.prototype.removeBackground = function(e) {
      var arr, c, j, len;
      e.preventDefault();
      e.stopPropagation();
      arr = this.arr;
      for (j = 0, len = arr.length; j < len; j++) {
        c = arr[j];
        this.el.removeClass(c);
      }
      return this.el.addClass('out');
    };

    App.prototype.showAgb = function(e) {
      var dialog, options;
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        }
      });
      options = {
        small: false,
        css: 'alert alert-warning',
        header: 'AGBs',
        body: function() {
          return require("views/agb")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showImp = function(e) {
      var dialog, options;
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        }
      });
      options = {
        small: true,
        css: 'alert alert-warning',
        header: 'Impressum',
        body: function() {
          return require("views/imp")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showPay = function(e) {
      var dialog, options;
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        }
      });
      options = {
        small: false,
        css: 'alert alert-warning',
        header: 'Zahlungsmglichkeiten',
        body: function() {
          return require("views/pay")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showWarning = function(e) {
      var agreed, dialog, options;
      agreed = this.isAgreed();
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        }
      });
      options = {
        small: false,
        css: 'alert alert-danger',
        header: 'Hinweis zum Versand von Pfeffer- und CS Gas-Sprays',
        body: function() {
          return require("views/warning")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        },
        footer: {
          footerButtonText: function() {
            if (!agreed) {
              return "Verstanden";
            }
          }
        }
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      return dialog.show(options);
    };

    App.prototype.showDelivery = function(e) {
      var dialog, options;
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        }
      });
      options = {
        small: false,
        css: 'alert alert-warning',
        header: 'Versand',
        body: function() {
          return require("views/delivery")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.hidemodal = function(e) {
      return this.log('hidemodal');
    };

    App.prototype.hiddenmodal = function(e) {
      this.log('hiddenmodal');
      return this.modal.exists = false;
    };

    App.prototype.showmodal = function(e) {
      this.log('showmodal');
      return this.modal.exists = true;
    };

    App.prototype.shownmodal = function(e) {
      return this.log('shownmodal');
    };

    App.prototype.redirectHome = function() {
      return location.href = '/';
    };

    App.prototype.toggleView = function(e) {
      e.preventDefault();
      return this.el.toggleClass('on');
    };

    App.prototype.toggleSidebar = function(e) {
      e.preventDefault();
      return this.setSidebar();
    };

    App.prototype.closeSidebar = function(e) {
      e.preventDefault();
      return this.setSidebar(true);
    };

    App.prototype.setSidebar = function(bol, notrans) {
      var isOpen;
      if (notrans == null) {
        notrans = false;
      }
      this.sidebar.toggleClass('notrans', notrans);
      this.sidebar.toggleClass('off', bol);
      isOpen = !this.sidebar.hasClass('off');
      return Settings.update(Settings.first().id, {
        sidebaropened: isOpen
      });
    };

    App.prototype.showSidebar = function(e) {
      e.preventDefault();
      return this.sidebar.addClass('glinch');
    };

    App.prototype.hideSidebar = function(e) {
      return;
      e.preventDefault();
      return this.sidebar.addClass('off');
    };

    App.prototype.showStats = function(e) {
      this.stats.attr('src', '/stat/counter.php').addClass('show').removeClass('fade');
      return e.preventDefault();
    };

    App.prototype.moveStats = function(e) {
      this.stats.position(e);
      return e.preventDefault();
    };

    App.prototype.hideStats = function(e) {
      this.stats.attr('src', '').removeClass('show').addClass('fade');
      return e.preventDefault();
    };

    App.prototype.reset = function() {
      return Settings.update(Settings.first().id, {
        hidden: false,
        agreed: false
      });
    };

    App.prototype.agreed = function() {
      return Settings.update(Settings.first().id, {
        agreed: true
      });
    };

    App.prototype.setData = function() {
      var c, j, len, ref, results;
      this.arr = [];
      ref = this.manager.controllers;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        results.push(this.arr.push(c.categoryName));
      }
      return results;
    };

    App.prototype.getData = function(s, arr) {
      var a, i, j, len, test;
      if (arr == null) {
        arr = [];
      }
      test = function(s, a) {
        var found, matcher;
        matcher = new RegExp(".*" + a + ".*", "g");
        return found = matcher.test(s);
      };
      for (i = j = 0, len = arr.length; j < len; i = ++j) {
        a = arr[i];
        if (test(s, a)) {
          return arr[i];
        }
      }
    };

    return App;

  })(Spine.Controller);

  module.exports = App;

}).call(this);
 },"index": function(exports, require, module) { (function() {
  var $, App, Extender, ModalSimpleView, RefreshView, Settings, Spine, UriHelper, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  require('lib/setup');

  Spine = require('spine');

  $ = Spine.$;

  ModalSimpleView = require("controllers/modal_simple_view");

  RefreshView = require('controllers/refresh_view');

  Extender = require('extensions/controller_extender');

  Settings = require("models/settings");

  User = require("models/user");

  UriHelper = require('extensions/uri_helper');

  App = (function(superClass) {
    extend(App, superClass);

    App.extend(Extender);

    App.extend(UriHelper);

    App.prototype.elements = {
      '#header': 'header',
      '#header .nav.items': 'items',
      '#header .nav-item': 'item',
      '#content': 'content',
      '#stats': 'stats',
      '#menu-trigger': 'menutrigger',
      '.menu-button': 'menuButton',
      '#stats': 'stats',
      '.logo-1': 'logo1',
      '.logo-2': 'logo2',
      '.sidebar': 'sidebar',
      '#refresh': 'refreshEl',
      '.trustami-badge': 'trustami',
      '.hb-badge': 'hb',
      '.favorite-badge': 'fv'
    };

    App.prototype.events = {
      'mouseenter #fitness-item-menu': 'changeBackground',
      'mouseenter #outdoor-item-menu': 'changeBackground',
      'mouseenter #tools-item-menu': 'changeBackground',
      'mouseenter #specials-item-menu': 'changeBackground',
      'mouseenter #defense-item-menu': 'changeBackground',
      'mouseenter .opt-stats': 'showStats',
      'mousemove  .opt-stats': 'moveStats',
      'mouseleave .opt-stats': 'hideStats',
      'click .opt-stats': 'noMethod',
      'click .opt-hint': 'showWarning',
      'click .opt-agreed': 'agreed',
      'click .opt-close': 'closeSidebar',
      'click .opt-sidebar': 'toggleSidebar',
      'click .sidebar .td:first-child': 'toggleSidebar',
      'click .paypal': 'toggleView',
      'click .opt-del': 'showDelivery',
      'click .opt-agb': 'showAgb',
      'click .opt-imp': 'showImp',
      'click .opt-privacy': 'showPrivacy',
      'click .opt-revocation': 'showRevocation',
      'click .opt-pay': 'showPay',
      'click .opt-reset': 'reset',
      'click [class^="logo-"], [class*=" logo-"]': 'redirectHome',
      'click .opt-favorite': 'showFavorite'
    };

    App.prototype.trustamiTemplate = function(item) {
      return $('#trustamiTemplate').tmpl(item);
    };

    App.prototype.hbTemplate = function() {
      return $('#hbTemplate').tmpl();
    };

    function App() {
      this.shownmodal = bind(this.shownmodal, this);
      this.showmodaldetails = bind(this.showmodaldetails, this);
      this.showmodal = bind(this.showmodal, this);
      this.hiddenmodal = bind(this.hiddenmodal, this);
      this.hidemodal = bind(this.hidemodal, this);
      var setting;
      App.__super__.constructor.apply(this, arguments);
      this.modal = {
        exists: false
      };
      this.arr = ['home', 'fitness', 'outdoor', 'tools', 'specials', 'defense', 'out'];
      setting = {
        hidden: false,
        agreed: false,
        sidebaropened: false
      };
      this.refreshView = new RefreshView({
        el: this.refreshEl
      });
      Spine.bind('active:category', this.proxy(this.initCategory));
      Spine.bind('refresh:done', this.proxy(this.renderRefreshView));
      Category.bind('refresh', this.proxy(this.renderFv));
      this.initSettings(setting);
      this.initSidebar();
      this.initLogos();
      this.exposeNav();
      this.renderRefreshView();
      this.getTrustami();
      this.renderHb();
      this.routes({
        '/item/:pid': function(params) {
          return this.showDetails(params.pid);
        },
        '/*glob': function(params) {}
      });
    }

    App.prototype.initCategory = function(cat) {
      this.initBackground(cat.name);
      return this.exposeNav(cat.name);
    };

    App.prototype.exposeNav = function(name) {
      if (name == null) {
        name = 'home';
      }
      name = this.getData(name, this.arr);
      $('.nav-item', this.items).removeClass('active');
      return $('.nav-item.' + name, this.items).addClass('active');
    };

    App.prototype.renderRefreshView = function() {
      return this.refreshView.render();
    };

    App.prototype.renderTrustami = function(tmi) {
      return this.trustami.html(this.trustamiTemplate({
        tmi: tmi
      }));
    };

    App.prototype.renderHb = function() {
      return this.hb.html(this.hbTemplate());
    };

    App.prototype.renderFv = function() {
      if (Product.getFavoriteUrl()) {
        return this.fv.addClass('badge2');
      } else {
        return this.fv.removeClass('badge2');
      }
    };

    App.prototype.toggleMenu = function() {
      if (this.swiper.previousIndex === 0) {
        return this.swiper.slidePrev();
      }
    };

    App.prototype.initSwipe = function() {
      var onInit, onSlideChangeEnd, onSlideChangeStart, swiper;
      onInit = (function(_this) {
        return function(slider) {
          return 'alert Init slider';
        };
      })(this);
      onSlideChangeStart = (function(_this) {
        return function(slider) {
          if (slider.activeIndex === 0) {
            return _this.menuButton.addClass('cross');
          } else {
            return _this.menuButton.removeClass('cross');
          }
        };
      })(this);
      onSlideChangeEnd = (function(_this) {
        return function(slider) {};
      })(this);
      this.swiper = swiper = new Swiper('.swiper-container', {
        slidesPerView: 'auto',
        initialSlide: 1,
        resistanceRatio: .00000000000001,
        slideToClickedSlide: true
      });
      swiper.on('slideChangeStart', onSlideChangeStart);
      return swiper.on('slideChangeEnd', onSlideChangeEnd);
    };

    App.prototype.getTrustami = function() {
      var callback, user;
      callback = (function(_this) {
        return function(json) {
          var tmi;
          tmi = $.parseJSON(json).tmi;
          return _this.renderTrustami(tmi);
        };
      })(this);
      User.fetch();
      if (!(user = User.first())) {
        return;
      }
      return user.getTmi(callback);
    };

    App.prototype.showFavorite = function(e) {
      var url;
      if (!(url = Product.getFavoriteUrl())) {
        return;
      }
      location.href = url;
      e.preventDefault();
      return e.stopPropagation();
    };

    App.prototype.checkWarning = function() {
      if (!this.isAgreed()) {
        return this.showWarning();
      }
    };

    App.prototype.initSettings = function(setting) {
      var i, ref, s;
      Settings.fetch();
      if (i = (ref = Settings.first()) != null ? ref.id : void 0) {
        return i;
      }
      s = new Settings(setting);
      s.save();
      return s.id;
    };

    App.prototype.initBackground = function(name) {
      if (name == null) {
        name = 'home';
      }
      this.log(name);
      return this.el.addClass(name);
    };

    App.prototype.initLogos = function() {
      var flag;
      flag = Settings.records[0].hidden;
      this.logo1.toggleClass('hide', !!flag);
      return this.logo2.toggleClass('hide', !!!flag);
    };

    App.prototype.initSidebar = function() {
      var isOpen;
      isOpen = Settings.records[0].sidebaropened;
      return this.setSidebar(!isOpen, true);
    };

    App.prototype.changeBackground = function(e) {
      var arr, c, el, j, len, res, s;
      e.preventDefault();
      e.stopPropagation();
      el = $(e.currentTarget);
      arr = this.arr;
      s = el.attr('id');
      res = this.getData(s, arr);
      for (j = 0, len = arr.length; j < len; j++) {
        c = arr[j];
        this.el.removeClass(c);
      }
      return this.el.addClass(res);
    };

    App.prototype.removeBackground = function(e) {
      var arr, c, j, len;
      e.preventDefault();
      e.stopPropagation();
      arr = this.arr;
      for (j = 0, len = arr.length; j < len; j++) {
        c = arr[j];
        this.el.removeClass(c);
      }
      return this.el.addClass('out');
    };

    App.prototype.showAgb = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'AGBs',
        body: function() {
          return require("views/agb")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false,
          backdrop: true
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showImp = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'Impressum',
        body: function() {
          return require("views/imp")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showPay = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'Zahlungs- mglichkeiten',
        body: function() {
          return require("views/pay")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show(options);
      return e.preventDefault();
    };

    App.prototype.showWarning = function(e) {
      var agreed, dialog, options;
      agreed = this.isAgreed();
      options = {
        small: false,
        css: 'alert alert-danger',
        header: 'Hinweis zum Versand von Pfeffer- und CS Gas-Sprays',
        body: function() {
          return require("views/warning")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        },
        footer: {
          footerButtonText: function() {
            if (!agreed) {
              return "Verstanden";
            }
          }
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      return dialog.show(options);
    };

    App.prototype.showDelivery = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'Versand',
        body: function() {
          return require("views/delivery")({
            copyright: 'Axel Nitzschner',
            spine_version: Spine.version,
            app_version: App.version,
            bs_version: '1.1.1'
          });
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show();
      return e.preventDefault();
    };

    App.prototype.showPrivacy = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'Datenschutz',
        body: function() {
          return require("views/privacy")();
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show();
      return e.preventDefault();
    };

    App.prototype.showRevocation = function(e) {
      var dialog, options;
      options = {
        small: false,
        css: 'default',
        header: 'Widerrufsrecht',
        body: function() {
          return require("views/revocation")();
        }
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodal));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      dialog.show();
      return e.preventDefault();
    };

    App.prototype.showDetails = function(id) {
      var dialog, options;
      this.product = Product.find(id);
      if (!this.product) {
        return;
      }
      options = {
        small: false,
        css: 'alert',
        header: this.product.title,
        body: (function(_this) {
          return function() {
            return $('#norbuPricingDetailsTemplate').tmpl(_this.product).html();
          };
        })(this)
      };
      dialog = new ModalSimpleView({
        modalOptions: {
          keyboard: true,
          show: false
        },
        renderOptions: options
      });
      dialog.el.one('hidden.bs.modal', this.proxy(this.hiddenmodal));
      dialog.el.one('hide.bs.modal', this.proxy(this.hidemodal));
      dialog.el.one('show.bs.modal', this.proxy(this.showmodaldetails));
      dialog.el.one('shown.bs.modal', this.proxy(this.shownmodal));
      return dialog.show();
    };

    App.prototype.hidemodal = function(e) {
      return this.navigate('/');
    };

    App.prototype.hiddenmodal = function(e) {
      return this.log('hiddenmodal');
    };

    App.prototype.showmodal = function(e) {
      return this.log('showmodal');
    };

    App.prototype.showmodaldetails = function(e) {
      var cb, p;
      this.log('showmodaldetails');
      cb = (function(_this) {
        return function(json, items) {
          var idx, j, jsn, key, len, onError, onLoad, res, result, results, ret, snap, val;
          result = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = json.length; j < len; j++) {
              jsn = json[j];
              ret = (function() {
                var results1;
                results1 = [];
                for (key in jsn) {
                  val = jsn[key];
                  results1.push({
                    src: val.src,
                    id: key
                  });
                }
                return results1;
              })();
              results.push(ret[0]);
            }
            return results;
          })();
          onError = function() {
            throw 'unable to load image (modal)';
          };
          onLoad = function() {
            this.imgEl.attr('src', this.src);
            if (this.i === 0) {
              this.imgEl.removeClass('load').addClass('show');
            }
            if (this.i === this.l - 1) {
              this.me.log('all loaded');
              if (this.l > 1) {
                return setTimeout(this.me.detailsSwiper = detailsSlider, 300);
              }
            }
          };
          snap = function(res, l, i) {
            var img, imgEl;
            imgEl = $('#' + res.id + ' img', _this.el);
            img = _this.createImage();
            img.imgEl = imgEl;
            img.l = l;
            img.i = i;
            img.me = _this;
            img.res = res;
            img.onload = onLoad;
            img.onerror = onError;
            return img.src = res.src;
          };
          results = [];
          for (idx = j = 0, len = result.length; j < len; idx = ++j) {
            res = result[idx];
            results.push(snap(res, result.length, idx));
          }
          return results;
        };
      })(this);
      return this.callDeferred(p = this.product.photos(), this.uriSettings(740, 740), cb);
    };

    App.prototype.shownmodal = function(e) {
      return this.log('shownmodal');
    };

    App.prototype.redirectHome = function() {
      return location.href = '/';
    };

    App.prototype.toggleView = function(e) {
      e.preventDefault();
      return this.el.toggleClass('on');
    };

    App.prototype.toggleSidebar = function(e) {
      e.preventDefault();
      return this.setSidebar();
    };

    App.prototype.closeSidebar = function(e) {
      e.preventDefault();
      return this.setSidebar(true);
    };

    App.prototype.setSidebar = function(bol, notrans) {
      var isOpen;
      if (notrans == null) {
        notrans = false;
      }
      this.sidebar.toggleClass('notrans', notrans);
      this.sidebar.toggleClass('off', bol);
      isOpen = !this.sidebar.hasClass('off');
      return Settings.update(Settings.first().id, {
        sidebaropened: isOpen
      });
    };

    App.prototype.showSidebar = function(e) {
      e.preventDefault();
      return this.sidebar.addClass('glinch');
    };

    App.prototype.hideSidebar = function(e) {
      return;
      e.preventDefault();
      return this.sidebar.addClass('off');
    };

    App.prototype.showStats = function(e) {
      this.stats.attr('src', '/stat/counter.php').addClass('show').removeClass('fade');
      return e.preventDefault();
    };

    App.prototype.moveStats = function(e) {
      this.stats.position(e);
      return e.preventDefault();
    };

    App.prototype.hideStats = function(e) {
      this.stats.attr('src', '').removeClass('show').addClass('fade');
      return e.preventDefault();
    };

    App.prototype.reset = function() {
      return Settings.update(Settings.first().id, {
        hidden: false,
        agreed: false
      });
    };

    App.prototype.agreed = function() {
      return Settings.update(Settings.first().id, {
        agreed: true
      });
    };

    App.prototype.isAgreed = function() {
      var ref;
      return (ref = Settings.first()) != null ? ref.agreed : void 0;
    };

    App.prototype.isAdmin = function() {
      return window.location.pathname.indexOf('admin') !== -1;
    };

    App.prototype.getData = function(s, arr) {
      var a, i, j, len, test;
      if (arr == null) {
        arr = [];
      }
      test = function(s, a) {
        var found, matcher;
        matcher = new RegExp(".*" + a + ".*", "g");
        return found = matcher.test(s);
      };
      for (i = j = 0, len = arr.length; j < len; i = ++j) {
        a = arr[i];
        if (test(s, a)) {
          return arr[i];
        }
      }
    };

    return App;

  })(Spine.Controller);

  module.exports = App;

}).call(this);
 },"lib/array": function(exports, require, module) { (function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Array.prototype.toId = function() {
    var i, id, item, len, ref, res;
    res = [];
    ref = this;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      id = typeof item === 'object' ? item.id : typeof item === 'string' ? item : void 0;
      if (id) {
        res.push(id);
      }
    }
    return res;
  };

  Array.prototype.removeFromList = function(list) {
    var i, id, idx, j, len, len1, ref, seq;
    if (list == null) {
      list = [];
    }
    seq = [];
    ref = this;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      id = ref[idx];
      if (indexOf.call(list, id) >= 0) {
        seq.push(idx);
      }
    }
    seq.reverse();
    for (j = 0, len1 = seq.length; j < len1; j++) {
      id = seq[j];
      this.splice(id, 1);
    }
    return this;
  };

  Array.prototype.last = function() {
    var lastIndex;
    lastIndex = this.length - 1;
    return this[lastIndex] || null;
  };

  Array.prototype.first = function() {
    return this[0] || null;
  };

  Array.prototype.filter = function(list) {
    var i, item, len, ref, ref1, res;
    list = list.toId();
    res = [];
    ref = this;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (ref1 = item.id, indexOf.call(list, ref1) >= 0) {
        res.push(item);
      }
    }
    return res;
  };

  Array.prototype.update = function(value) {
    if (Object.prototype.toString.call(value) !== '[object Array]') {
      throw new Error('passed value requires an array');
    }
    [].splice.apply(this, [0, this.length - 0].concat(value)), value;
    return this;
  };

  Array.prototype.addRemove = function(ids) {
    var i, id, len;
    if (!Array.isArray(ids)) {
      ids = [ids];
    }
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this.toggleSelected(id);
    }
    return this;
  };

  Array.prototype.add = function(id) {
    this.toggleSelected(id, true);
    return this;
  };

  Array.prototype.toggleSelected = function(id, addonly) {
    var index;
    if (!id) {
      return this;
    }
    if (indexOf.call(this, id) < 0) {
      this.unshift(id);
    } else if (!addonly) {
      index = this.indexOf(id);
      if (index !== -1) {
        this.splice(index, 1);
      }
    }
    return this;
  };

  Array.prototype.contains = function(string) {
    var Regex, i, len, ref, value;
    ref = this;
    for (i = 0, len = ref.length; i < len; i++) {
      value = ref[i];
      Regex = new RegExp(value);
      if (Regex.test(string)) {
        return true;
      }
    }
  };

}).call(this);
 },"lib/setup": function(exports, require, module) { (function() {
  require('lib/array');

  require('spine');

  require('spine/lib/local');

  require('spine/lib/manager');

  require('spine/lib/route');

}).call(this);
 },"login": function(exports, require, module) { (function() {
  var $, Flash, Login, Spine, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Flash = require("models/flash");

  User = require("models/user");

  Login = (function(superClass) {
    extend(Login, superClass);

    Login.prototype.elements = {
      'form': 'form',
      '.flash': 'flashEl',
      '.status': 'statusEl',
      '#UserPassword': 'passwordEl',
      '#UserUsername': 'usernameEl',
      '#login .dialogue-content': 'contentEl',
      '#loader': 'loader',
      '.guest': 'btnGuest'
    };

    Login.prototype.events = {
      'keypress': 'submitOnEnter',
      'click #guestLogin': 'guestLogin',
      'click #cancel': 'cancel'
    };

    Login.prototype.flashTemplate = function(item) {
      return $('#flashTemplate').tmpl(item);
    };

    Login.prototype.statusTemplate = function(item) {
      return $('#statusTemplate').tmpl(item);
    };

    function Login(form) {
      this.error = bind(this.error, this);
      this.success = bind(this.success, this);
      this.done = bind(this.done, this);
      this.submit = bind(this.submit, this);
      var flash;
      Login.__super__.constructor.apply(this, arguments);
      Flash.fetch();
      if (Flash.count()) {
        flash = Flash.first();
      }
      if (flash) {
        this.flash(flash);
      }
      Flash.destroyAll();
      this.renderGuestLogin();
    }

    Login.prototype.render = function(el, stuff) {
      el.html(stuff);
      return this.el;
    };

    Login.prototype.submit = function() {
      return $.ajax({
        data: this.form.serialize(),
        type: 'POST',
        success: this.success,
        error: this.error,
        done: this.done
      });
    };

    Login.prototype.done = function(xhr) {
      var json;
      json = xhr.responseText;
      this.passwordEl.val('');
      return this.usernameEl.val('').focus();
    };

    Login.prototype.success = function(json) {
      var fadeFunc, redirectFunc, user;
      json = $.parseJSON(json);
      User.fetch();
      User.destroyAll();
      user = new User(this.newAttributes(json));
      user.save();
      this.flash(json);
      fadeFunc = function() {
        return this.contentEl.addClass('fade');
      };
      redirectFunc = function() {
        this.log('redirect: admin' + location.hash);
        return User.redirect('admin' + location.hash);
      };
      this.delay(fadeFunc, 2000);
      return this.delay(redirectFunc, 2000);
    };

    Login.prototype.error = function(xhr, err) {
      var flash;
      flash = $.parseJSON(xhr.responseText);
      flash.status = xhr.status;
      flash.statusText = xhr.statusText;
      return this.flash(flash);
    };

    Login.prototype.flash = function(flash) {
      var delayedFunc;
      if (!this.oldMessage) {
        this.oldMessage = this.flashEl.html();
      }
      delayedFunc = function() {
        return this.flashEl.html(this.oldMessage);
      };
      this.render(this.flashEl, this.flashTemplate(flash));
      this.render(this.statusEl, this.statusTemplate(flash));
      return this.delay(delayedFunc, 2000);
    };

    Login.prototype.newAttributes = function(json) {
      return {
        id: json.id,
        username: json.username,
        name: json.name,
        groupname: json.groupname,
        sessionid: json.sessionid,
        redirect: location.hash
      };
    };

    Login.prototype.cancel = function(e) {
      User.redirect();
      return e.preventDefault();
    };

    Login.prototype.renderGuestLogin = function() {
      if (!Spine.isProduction) {
        return this.btnGuest.removeClass('hide');
      }
    };

    Login.prototype.guestLogin = function() {
      this.usernameEl.val('gast');
      this.passwordEl.val('guest');
      return this.submit();
    };

    Login.prototype.submitOnEnter = function(e) {
      if (e.keyCode !== 13) {
        return;
      }
      this.submit();
      return e.preventDefault();
    };

    return Login;

  })(Spine.Controller);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Login;
  }

}).call(this);
 },"models/categories_product": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Extender, Filter, Model, Photo, ProductsPhoto, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Filter = require("extensions/filter");

  Model.Category = require('models/category');

  Model.Product = require('models/product');

  Photo = require('models/photo');

  ProductsPhoto = require('models/products_photo');

  Extender = require("extensions/model_extender");

  require("spine/lib/ajax");

  CategoriesProduct = (function(superClass) {
    extend(CategoriesProduct, superClass);

    function CategoriesProduct() {
      this.allCategoryProducts = bind(this.allCategoryProducts, this);
      return CategoriesProduct.__super__.constructor.apply(this, arguments);
    }

    CategoriesProduct.configure("CategoriesProduct", 'id', 'cid', 'category_id', 'product_id', 'order', 'ignored');

    CategoriesProduct.extend(Model.Ajax);

    CategoriesProduct.extend(Filter);

    CategoriesProduct.extend(Extender);

    CategoriesProduct.url = 'categories_products';

    CategoriesProduct.mixinAttributes = ['ignored', 'order'];

    CategoriesProduct.productExists = function(aid, gid) {
      var gas;
      gas = this.filter(true, {
        product_id: aid,
        category_id: gid,
        func: 'selectUnique'
      });
      return gas.first() || !!gas.length;
    };

    CategoriesProduct.categories = function(aid) {
      return Category.filterRelated(aid, {
        model: 'Product',
        sort: 'sortByOrder'
      });
    };

    CategoriesProduct.products = function(gid) {
      return Product.filterRelated(gid, {
        model: 'Category',
        sort: 'sortByOrder'
      });
    };

    CategoriesProduct.publishedProducts = function(gid) {
      var ref;
      if (gid == null) {
        gid = (ref = Category.record) != null ? ref.id : void 0;
      }
      return this.filter(gid, {
        associationForeignKey: 'category_id',
        func: 'selectNotIgnored'
      });
    };

    CategoriesProduct.publishedProductsAll = function(gid) {
      var ref;
      if (gid == null) {
        gid = (ref = Category.record) != null ? ref.id : void 0;
      }
      return this.filter(gid, {
        associationForeignKey: 'category_id',
        func: 'selectNotIgnoredAll'
      });
    };

    CategoriesProduct.unpublishedProducts = function(gid) {
      var ref;
      if (gid == null) {
        gid = (ref = Category.record) != null ? ref.id : void 0;
      }
      return this.filter(gid, {
        associationForeignKey: 'category_id',
        func: 'selectIgnored'
      });
    };

    CategoriesProduct.otherProducts = function(gid) {
      var ref;
      if (gid == null) {
        gid = (ref = Category.record) != null ? ref.id : void 0;
      }
      return this.filter(gid, {
        associationForeignKey: 'category_id',
        func: 'selectOthers'
      });
    };

    CategoriesProduct.photos = function(id) {
      var i, j, len, len1, photo, photos, product, products, ret;
      ret = [];
      if (!id) {
        this.each((function(_this) {
          return function(item) {
            var i, len, photo, photos, results;
            photos = ProductsPhoto.productPhotos(item.product_id);
            results = [];
            for (i = 0, len = photos.length; i < len; i++) {
              photo = photos[i];
              results.push(ret.push(photo));
            }
            return results;
          };
        })(this));
      } else {
        products = this.products(id);
        for (i = 0, len = products.length; i < len; i++) {
          product = products[i];
          photos = ProductsPhoto.productPhotos(product.id);
          for (j = 0, len1 = photos.length; j < len1; j++) {
            photo = photos[j];
            ret.push(photo);
          }
        }
      }
      return ret;
    };

    CategoriesProduct.isActiveProduct = function(gid, aid) {
      var ga, gas, i, len, ret;
      ret = [];
      gas = this.filter(gid, {
        associationForeignKey: 'category_id',
        func: 'selectNotIgnored'
      });
      for (i = 0, len = gas.length; i < len; i++) {
        ga = gas[i];
        if ((ga.product_id === aid) && (!ga.ignored)) {
          ret.push(ga);
        }
      }
      return !!ret.length;
    };

    CategoriesProduct.c = 0;

    CategoriesProduct.prototype.validate = function() {
      var ret2, valid_1, valid_2;
      valid_1 = (Product.find(this.product_id)) && (Category.find(this.category_id));
      valid_2 = !(this.constructor.productExists(this.product_id, this.category_id) && this.isNew());
      if (!valid_1) {
        return 'Ungltige Aktion!';
      }
      ret2 = function(p) {
        return 'Produkt ' + p.title + ' existiert bereits in dieser Kategorie';
      };
      if (!valid_2) {
        return ret2(Product.find(this.product_id));
      }
      return false;
    };

    CategoriesProduct.prototype.mixinAttributes = function() {
      var attr, i, len, ref, result;
      result = {};
      ref = this.constructor.mixinAttributes;
      for (i = 0, len = ref.length; i < len; i++) {
        attr = ref[i];
        result[attr] = this[attr];
      }
      return result;
    };

    CategoriesProduct.prototype.categories = function() {
      return this.constructor.categories(this.product_id);
    };

    CategoriesProduct.prototype.products = function() {
      return this.constructor.products(this.category_id);
    };

    CategoriesProduct.prototype.allCategoryProducts = function() {
      var category, ga, gas, i, len, products;
      category = Category.record;
      if (!category) {
        return;
      }
      products = [];
      gas = this.constructor.filter(category.id, {
        associationForeignKey: 'category_id'
      });
      for (i = 0, len = gas.length; i < len; i++) {
        ga = gas[i];
        if (Product.exists(ga.product_id)) {
          products.push(Product.find(ga.product_id));
        }
      }
      return products;
    };

    CategoriesProduct.prototype.isActiveProduct = function(aid) {
      return this.constructor.isActiveProduct(this.category_id, aid);
    };

    CategoriesProduct.prototype.select = function(id, options) {
      if (this[options.associationForeignKey] === id) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectProduct = function(id, gid) {
      if (this.product_id === id && this.category_id === Category.record.id) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectUnique = function(query, options) {
      if ((this.product_id === options.product_id) && (this.category_id === options.category_id)) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectNotIgnored = function(id, opts) {
      if (!this.ignored && (this.category_id === id)) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectNotIgnoredAll = function(id) {
      var ref;
      if ((!this.ignored) && (this.isProtectedModel(Category, (ref = Category.find(this.category_id)) != null ? ref.name : void 0))) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectIgnored = function(id) {
      var ref;
      if (this.ignored && this.isProtectedModel(Category, (ref = Category.find(this.category_id)) != null ? ref.name : void 0)) {
        return true;
      }
    };

    CategoriesProduct.prototype.selectOthers = function(id) {
      var ref;
      if (!this.isProtectedModel(Category, (ref = Category.find(this.category_id)) != null ? ref.name : void 0)) {
        return true;
      }
    };

    return CategoriesProduct;

  })(Spine.Model);

  module.exports = Model.CategoriesProduct = CategoriesProduct;

}).call(this);
 },"models/category": function(exports, require, module) { (function() {
  var $, AjaxRelations, CategoriesProduct, Category, Extender, Filter, Model, Photo, ProductsPhoto, Spine, Uri, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  User = require('models/user');

  Photo = require('models/photo');

  CategoriesProduct = require('models/categories_product');

  ProductsPhoto = require('models/products_photo');

  Filter = require("extensions/filter");

  AjaxRelations = require("extensions/ajax_relations");

  Uri = require("extensions/uri");

  Extender = require("extensions/model_extender");

  require("spine/lib/ajax");

  Category = (function(superClass) {
    extend(Category, superClass);

    function Category() {
      this.details = bind(this.details, this);
      return Category.__super__.constructor.apply(this, arguments);
    }

    Category.configure('Category', 'id', 'cid', 'name', 'screenname', 'order', 'user_id', 'protected');

    Category.extend(Filter);

    Category.extend(Model.Ajax);

    Category.extend(AjaxRelations);

    Category.extend(Uri);

    Category.extend(Extender);

    Category.humanName = function() {
      return 'die Kategorie';
    };

    Category.humanNames = function() {
      return 'die Kategorien';
    };

    Category.selectAttributes = ['screenname'];

    Category.parent = 'Root';

    Category.childType = 'Product';

    Category.url = '' + base_url + 'categories';

    Category["protected"] = {
      'outdoor': {
        screenname: 'Outdoor'
      },
      'fitness': {
        screenname: 'Fitness'
      },
      'tools': {
        screenname: 'Tools'
      },
      'defense': {
        screenname: 'Defense'
      },
      'specials': {
        screenname: 'Specials'
      },
      'none': {
        screenname: 'ohne Kategorie'
      }
    };

    Category.fromJSON = function(objects) {
      var json, key;
      Category.__super__.constructor.fromJSON.apply(this, arguments);
      this.createJoinTables(objects);
      key = this.className;
      json = this.make(objects, key);
      return json;
    };

    Category.foreignModels = function() {
      return {
        'Product': {
          className: 'Product',
          joinTable: 'CategoriesProduct',
          foreignKey: 'category_id',
          associationForeignKey: 'product_id'
        }
      };
    };

    Category.contains = function(id) {
      if (id == null) {
        id = this.record.id;
      }
      if (!id) {
        return Model[this.childType].all();
      }
      return this.products(id);
    };

    Category.products = function(id) {
      var filterOptions;
      filterOptions = {
        model: 'Category',
        sort: 'sortByOrder'
      };
      return Model[this.childType].filterRelated(id, filterOptions);
    };

    Category.product = function(id, pid) {
      var filterOptions, i, len, pro, pros, res;
      filterOptions = {
        model: 'Category'
      };
      pros = this.products(id);
      res = [];
      for (i = 0, len = pros.length; i < len; i++) {
        pro = pros[i];
        if (pro.id === pid) {
          res.push(pro);
        }
      }
      return res[0];
    };

    Category.publishedProducts = function(id) {
      var cp, cps, filterOptions, i, len, ret;
      filterOptions = {
        func: 'selectNotIgnored'
      };
      ret = [];
      cps = CategoriesProduct.filterSortByOrder(id, filterOptions);
      for (i = 0, len = cps.length; i < len; i++) {
        cp = cps[i];
        ret.push(Product.find(cp.product_id));
      }
      return ret;
    };

    Category.selectedProductsHasPhotos = function() {
      var alb, i, len, products;
      products = Product.toRecords(this.selectionList());
      for (i = 0, len = products.length; i < len; i++) {
        alb = products[i];
        if (alb.contains()) {
          return true;
        }
      }
      return false;
    };

    Category.activePhotos = function(id) {
      var ga, gas, i, ids, j, len, len1, pho, photos, product, ref, ret, search;
      if (id == null) {
        id = (ref = this.record) != null ? ref.id : void 0;
      }
      ret = [];
      if (id) {
        gas = CategoriesProduct.filter(id, {
          associationForeignKey: 'category_id',
          func: 'selectNotIgnored'
        });
        search = 'product_id';
      } else {
        ids = Category.selectionList();
        gas = Product.toRecords(ids);
        search = 'id';
      }
      for (i = 0, len = gas.length; i < len; i++) {
        ga = gas[i];
        product = Product.find(ga = CategoriesProduct.find(search));
        if (!product) {
          break;
        }
        photos = product.photos() || [];
        for (j = 0, len1 = photos.length; j < len1; j++) {
          pho = photos[j];
          ret.push(pho);
        }
      }
      return ret;
    };

    Category.details = function() {
      var i, imagesCount, len, product, products;
      if (Category.record) {
        return Category.record.details();
      }
      products = Product.all();
      imagesCount = 0;
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        imagesCount += product.count = ProductsPhoto.filter(product.id, {
          associationForeignKey: 'product_id'
        }).length;
      }
      return $().extend(Category.defaultDetails, {
        gCount: Category.count(),
        iCount: imagesCount,
        aCount: products.length,
        sCount: Category.selectionList().length,
        author: User.first().name
      });
    };

    Category.findRelated = function(joins, joinid) {
      var i, join, len, record, results;
      if (joins == null) {
        joins = [];
      }
      if (joinid == null) {
        joinid = '';
      }
      results = [];
      for (i = 0, len = joins.length; i < len; i++) {
        join = joins[i];
        if ((record = this.find(join[joinid]))) {
          results.push(record);
        }
      }
      return results;
    };

    Category.renderBuffer = function(buffer) {
      var items;
      items = Category.filter();
      return this.buffer = items;
    };

    Category.prototype.init = function(instance) {
      var id, prot, s;
      if (!(id = instance.id)) {
        return;
      }
      prot = this.isProtectedModel(this.constructor, instance.name);
      instance["protected"] = prot;
      s = new Object();
      s[id] = [];
      this.constructor.selection.push(s);
      return instance;
    };

    Category.prototype.validate = function() {
      var valid;
      valid = !Category["protected"][this.name];
      if (!valid) {
        return 'Geschtzte Kategorie!';
      }
      return false;
    };

    Category.prototype.activePhotos = function() {
      return this.constructor.activePhotos(this.id);
    };

    Category.prototype.details = function() {
      var i, imagesCount, len, product, products, published;
      products = Category.products(this.id);
      published = CategoriesProduct.publishedProducts(this.id);
      imagesCount = 0;
      for (i = 0, len = products.length; i < len; i++) {
        product = products[i];
        imagesCount += product.count = ProductsPhoto.filter(product.id, {
          associationForeignKey: 'product_id'
        }).length;
      }
      return $().extend(this.defaultDetails, {
        name: this.name,
        screenname: this.screenname,
        iCount: imagesCount,
        aCount: products.length,
        pCount: published.length,
        sCount: Category.selectionList().length,
        author: User.first().name
      });
    };

    Category.prototype.count_ = function(inc) {
      var filterOptions;
      if (inc == null) {
        inc = 0;
      }
      filterOptions = {
        model: 'Category'
      };
      return Product.filterRelated(this.id, filterOptions).length + inc;
    };

    Category.prototype.contains = function(inc) {
      if (inc == null) {
        inc = 0;
      }
      return this.constructor.contains(this.id).length + inc;
    };

    Category.prototype.products = function() {
      return this.constructor.products(this.id);
    };

    Category.prototype.updateAttributes = function(atts, options) {
      if (options == null) {
        options = {};
      }
      this.load(atts);
      return this.save();
    };

    Category.prototype.updateAttribute = function(name, value, options) {
      if (options == null) {
        options = {};
      }
      this[name] = value;
      return this.save();
    };

    Category.prototype.select = function() {};

    return Category;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Category = Category;
  }

}).call(this);
 },"models/clipboard": function(exports, require, module) { (function() {
  var $, Clipboard, Model, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  require('spine/lib/local');

  Clipboard = (function(superClass) {
    extend(Clipboard, superClass);

    function Clipboard() {
      return Clipboard.__super__.constructor.apply(this, arguments);
    }

    Clipboard.configure('Clipboard', 'id', 'item', 'type', 'cut');

    Clipboard.extend(Model.Local);

    Clipboard.prototype.init = function(instance) {
      if (!instance) {

      }
    };

    return Clipboard;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Clipboard = Clipboard;
  }

}).call(this);
 },"models/config": function(exports, require, module) { (function() {
  var $, Config, Filter, Model, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Filter = require("extensions/filter");

  require('spine/lib/local');

  Config = (function(superClass) {
    extend(Config, superClass);

    function Config() {
      return Config.__super__.constructor.apply(this, arguments);
    }

    Config.configure('Config', 'id', 'key', 'value');

    Config.extend(Model.Local);

    Config.extend(Filter);

    Config.prototype.init = function(instance) {};

    Config.prototype.select = function(query) {
      if (this.key === query) {
        return true;
      }
      return false;
    };

    return Config;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Config;
  }

}).call(this);
 },"models/description": function(exports, require, module) { (function() {
  var $, AjaxRelations, Description, Extender, Filter, Model, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  AjaxRelations = require("extensions/ajax_relations");

  Filter = require("extensions/filter");

  Extender = require("extensions/model_extender");

  require("spine/lib/ajax");

  Description = (function(superClass) {
    extend(Description, superClass);

    function Description() {
      return Description.__super__.constructor.apply(this, arguments);
    }

    Description.configure('Description', 'id', 'cid', 'description', "product_id", 'user_id', 'order');

    Description.extend(Filter);

    Description.extend(Model.Ajax);

    Description.extend(AjaxRelations);

    Description.extend(Extender);

    Description.selectAttributes = ['description'];

    Description.url = 'descriptions';

    Description.fromJSON = function(objects) {
      var json, key;
      Description.__super__.constructor.fromJSON.apply(this, arguments);
      key = this.className;
      json = this.make(objects, key);
      return json;
    };

    Description.prototype.select = function(id) {
      if (this.product_id === id) {
        return true;
      }
    };

    return Description;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Description = Description;
  }

}).call(this);
 },"models/drag_item": function(exports, require, module) { (function() {
  var $, Model, Spine, SpineDragItem,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  SpineDragItem = (function(superClass) {
    extend(SpineDragItem, superClass);

    function SpineDragItem() {
      return SpineDragItem.__super__.constructor.apply(this, arguments);
    }

    SpineDragItem.configure('SpineDragItem', 'el', 'els', 'target', 'source', 'sourceModelName', 'sourceModelId', 'originModel', 'originModelName', 'originRecord', 'originRecordName', 'originRecordId', 'selection', 'selected', 'closest');

    SpineDragItem.prototype.init = function() {};

    return SpineDragItem;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.SpineDragItem = SpineDragItem;
  }

}).call(this);
 },"models/flash": function(exports, require, module) { (function() {
  var $, Flash, Model, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  require('spine/lib/local');

  Flash = (function(superClass) {
    extend(Flash, superClass);

    function Flash() {
      return Flash.__super__.constructor.apply(this, arguments);
    }

    Flash.configure('Flash', 'flash', 'record', 'status', 'statusText');

    Flash.extend(Model.Local);

    Flash.prototype.init = function() {};

    return Flash;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Flash;
  }

}).call(this);
 },"models/photo": function(exports, require, module) { (function() {
  var $, AjaxRelations, Cache, Category, Clipboard, Develop, Extender, Filter, Model, Photo, Product, ProductsPhoto, Spine, Uri,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Filter = require("extensions/filter");

  Category = require('models/category');

  Product = require('models/product');

  Clipboard = require('models/clipboard');

  ProductsPhoto = require('models/products_photo');

  Extender = require("extensions/model_extender");

  AjaxRelations = require("extensions/ajax_relations");

  Uri = require("extensions/uri");

  Develop = require("extensions/develop");

  Cache = require("extensions/cache");

  require("spine/lib/ajax");

  Photo = (function(superClass) {
    extend(Photo, superClass);

    function Photo() {
      this.details = bind(this.details, this);
      return Photo.__super__.constructor.apply(this, arguments);
    }

    Photo.configure("Photo", 'id', 'title', "photo", 'filesize', 'captured', 'exposure', "iso", 'longitude', 'aperture', 'software', 'model', 'order', 'user_id', 'active', 'src', 'selected', 'deleted');

    Photo.extend(Cache);

    Photo.extend(Model.Ajax);

    Photo.extend(Uri);

    Photo.extend(Develop);

    Photo.extend(AjaxRelations);

    Photo.extend(Filter);

    Photo.extend(Extender);

    Photo.humanName = function() {
      return 'das Foto';
    };

    Photo.humanNames = function() {
      return 'die Fotos';
    };

    Photo.selectAttributes = ['title', "photo", 'user_id', 'order'];

    Photo.parent = 'Product';

    Photo.foreignModels = function() {
      return {
        'Product': {
          className: 'Product',
          joinTable: 'ProductsPhoto',
          foreignKey: 'photo_id',
          associationForeignKey: 'product_id'
        }
      };
    };

    Photo.url = '' + base_url + Photo.className.toLowerCase() + 's';

    Photo.fromJSON = function(objects) {
      var json, key;
      Photo.__super__.constructor.fromJSON.apply(this, arguments);
      this.createJoinTables(objects);
      key = this.className;
      json = this.make(objects, key);
      return json;
    };

    Photo.nameSort = function(a, b) {
      var aa, bb, ref, ref1;
      aa = (ref = (a || '').name) != null ? ref.toLowerCase() : void 0;
      bb = (ref1 = (b || '').name) != null ? ref1.toLowerCase() : void 0;
      if (aa === bb) {
        return 0;
      } else if (aa < bb) {
        return -1;
      } else {
        return 1;
      }
    };

    Photo.renderBuffer = function(buffer) {
      var items, product;
      if (product = Product.record) {
        items = Product.photos(product.id);
      } else {
        items = Photo.filter(true);
      }
      return this.buffer = items;
    };

    Photo.defaults = {
      width: 140,
      height: 140,
      square: 1,
      quality: 70
    };

    Photo.success = function(uri) {
      Photo.log('success');
      return Photo.trigger('uri', uri);
    };

    Photo.error = function(json) {
      return Photo.trigger('ajaxError', json);
    };

    Photo.create = function(atts) {
      return this.__super__.constructor.create.call(this, atts);
    };

    Photo.refresh = function(values, options) {
      if (options == null) {
        options = {};
      }
      return this.__super__.constructor.refresh.call(this, values, options);
    };

    Photo.trashed = function() {
      var item, res;
      res = [];
      for (item in this.irecords) {
        if (!ProductsPhoto.find(item.id)) {
          res.push(item);
        }
      }
      return res;
    };

    Photo.inactive = function() {
      return this.findAllByAttribute('active', false);
    };

    Photo.activePhotos = function() {
      return [this.record];
    };

    Photo.createJoin = function(items, target, callback) {
      var ap, cb, isValid, item, ret, valid;
      if (items == null) {
        items = [];
      }
      if (!Array.isArray(items)) {
        items = [items];
      }
      if (!items.length) {
        return;
      }
      isValid = true;
      cb = (function(_this) {
        return function() {
          Product.trigger('change:collection', target);
          if (typeof callback === 'function') {
            return callback.call(_this);
          }
        };
      })(this);
      ret = (function() {
        var i, len, ref, results;
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          ap = new ProductsPhoto({
            product_id: target.id,
            photo_id: item.id,
            order: parseInt((ref = ProductsPhoto.photos(target.id).last()) != null ? ref.order : void 0) + 1 || 0
          });
          valid = ap.save({
            validate: true,
            ajax: false
          });
          if (!valid) {
            results.push(isValid = valid);
          } else {
            results.push(void 0);
          }
        }
        return results;
      })();
      if (isValid) {
        target.save({
          done: cb
        });
      } else {
        Spine.trigger('refresh:all');
      }
      return ret;
    };

    Photo.destroyJoin = function(items, target, cb) {
      var ap, aps, i, item, len;
      if (items == null) {
        items = [];
      }
      if (!Array.isArray(items)) {
        items = [items];
      }
      if (!(items.length && target)) {
        return;
      }
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        aps = ProductsPhoto.filter(item.id, {
          associationForeignKey: 'photo_id'
        });
        ap = ProductsPhoto.productPhotoExists(item.id, target.id);
        if (ap) {
          ap.destroy({
            done: cb
          });
        }
      }
      return Product.trigger('change:collection', target);
    };

    Photo.products = function(id) {
      var filterOptions;
      filterOptions = {
        model: 'Photo',
        sort: 'sortByOrder'
      };
      return Product.filterRelated(id, filterOptions);
    };

    Photo.findRelated_ = function(joins, joinid) {
      var i, join, len, record, results;
      if (joins == null) {
        joins = [];
      }
      if (joinid == null) {
        joinid = '';
      }
      results = [];
      for (i = 0, len = joins.length; i < len; i++) {
        join = joins[i];
        if ((record = this.find(join[joinid])) && !!typeof (record.order = join.order)) {
          results.push(record);
        }
      }
      return results;
    };

    Photo.findRelated = function(joins, joinid) {
      var i, join, len, record, res;
      if (joins == null) {
        joins = [];
      }
      if (joinid == null) {
        joinid = '';
      }
      res = [];
      for (i = 0, len = joins.length; i < len; i++) {
        join = joins[i];
        if (record = this.find(join[joinid])) {
          res.push(record.silentUpdate({
            'order': join.order
          }));
        }
      }
      return res;
    };

    Photo.unusedPhotos = function() {
      return this.filter(true, {
        func: 'selectUnused'
      });
    };

    Photo.prototype.init = function(instance) {
      if (!(instance != null ? instance.id : void 0)) {
        return;
      }
      return this.constructor.initCache(instance.id);
    };

    Photo.prototype.parent = function() {
      return this.constructor.parent;
    };

    Photo.prototype.createJoin = function(target) {
      return this.constructor.createJoin([this], target);
    };

    Photo.prototype.destroyJoin = function(target) {
      return this.constructor.destroyJoin([this], target);
    };

    Photo.prototype.products = function() {
      return this.constructor.products(this.id);
    };

    Photo.prototype.select_ = function(joinTableItems) {
      var i, len, record;
      for (i = 0, len = joinTableItems.length; i < len; i++) {
        record = joinTableItems[i];
        if (record.photo_id === this.id && ((this['order'] = parseInt(record.order)) != null)) {
          return true;
        }
      }
    };

    Photo.prototype.select = function() {
      if (!this.deleted) {
        return true;
      }
    };

    Photo.prototype.selectDeleted = function() {
      if (this.deleted) {
        return true;
      }
    };

    Photo.prototype.selectPhoto = function(id) {
      if (this.id === id) {
        return true;
      }
    };

    Photo.prototype.selectUnused = function(id) {
      if (!ProductsPhoto.findByAttribute('photo_id', this.id)) {
        return true;
      }
    };

    Photo.prototype.details = function() {
      return {
        category: Model.Category.record,
        product: Model.Product.record,
        photo: Model.Photo.record,
        author: User.first().name
      };
    };

    return Photo;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Photo = Photo;
  }

}).call(this);
 },"models/photos_trash": function(exports, require, module) { (function() {
  var $, Extender, Model, PhotosTrash, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Extender = require("extensions/model_extender");

  PhotosTrash = (function(superClass) {
    extend(PhotosTrash, superClass);

    function PhotosTrash() {
      return PhotosTrash.__super__.constructor.apply(this, arguments);
    }

    PhotosTrash.configure("PhotosTrash", 'id');

    PhotosTrash.extend(Extender);

    PhotosTrash.prototype.init = function(instance) {
      var id;
      if (!(id = instance.id)) {

      }
    };

    return PhotosTrash;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.PhotosTrash = PhotosTrash;
  }

}).call(this);
 },"models/product": function(exports, require, module) { (function() {
  var $, AjaxRelations, CategoriesProduct, Clipboard, Extender, Filter, Model, Product, Spine, Uri, Utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  CategoriesProduct = require('models/categories_product');

  Clipboard = require('models/clipboard');

  AjaxRelations = require("extensions/ajax_relations");

  Uri = require("extensions/uri");

  Utils = require("extensions/utils");

  Filter = require("extensions/filter");

  Extender = require("extensions/model_extender");

  require("extensions/cache");

  require("spine/lib/ajax");

  Product = (function(superClass) {
    extend(Product, superClass);

    function Product() {
      this.details = bind(this.details, this);
      this.descriptions = bind(this.descriptions, this);
      this.photos = bind(this.photos, this);
      this.contains = bind(this.contains, this);
      return Product.__super__.constructor.apply(this, arguments);
    }

    Product.configure("Product", 'id', 'cid', 'title', 'subtitle', 'link', 'notes', 'price', 'user_id', 'ignored', 'favorite', 'order', 'invalid', 'deleted', 'active', 'selected');

    Product.extend(Model.Cache);

    Product.extend(Model.Ajax);

    Product.extend(Uri);

    Product.extend(Utils);

    Product.extend(AjaxRelations);

    Product.extend(Filter);

    Product.extend(Extender);

    Product.humanName = function() {
      return 'das Produkt';
    };

    Product.humanNames = function() {
      return 'die Produkte';
    };

    Product.selectAttributes = ['title', 'subtitle', 'notes', 'price'];

    Product.parent = 'Category';

    Product.childType = 'Photo';

    Product.previousID = false;

    Product.url = '' + base_url + Product.className.toLowerCase() + 's';

    Product.fromJSON = function(objects) {
      var json, key;
      Product.__super__.constructor.fromJSON.apply(this, arguments);
      this.createJoinTables(objects);
      key = this.className;
      json = this.make(objects, key);
      return json;
    };

    Product.nameSort = function(a, b) {
      var aa, bb, ref, ref1;
      aa = (ref = (a || '').title) != null ? ref.toLowerCase() : void 0;
      bb = (ref1 = (b || '').title) != null ? ref1.toLowerCase() : void 0;
      if (aa === bb) {
        return 0;
      } else if (aa < bb) {
        return -1;
      } else {
        return 1;
      }
    };

    Product.foreignModels = function() {
      return {
        'Category': {
          className: 'Category',
          joinTable: 'CategoriesProduct',
          foreignKey: 'product_id',
          associationForeignKey: 'category_id'
        },
        'Photo': {
          className: 'Photo',
          joinTable: 'ProductsPhoto',
          foreignKey: 'product_id',
          associationForeignKey: 'photo_id'
        }
      };
    };

    Product.contains = function(id) {
      if (id == null) {
        id = this.record.id;
      }
      if (!id) {
        return Model[this.childType].all();
      }
      return this.photos(id);
    };

    Product.photos = function(id, max) {
      var filterOptions, photos, ret;
      max = max <= 0 ? 1 : max;
      filterOptions = {
        model: 'Product',
        sort: 'sortByReverseOrder'
      };
      photos = Photo.filterRelated(id, filterOptions);
      ret = photos.slice(0, max);
      return ret;
    };

    Product.getFavoriteUrl = function(isAdmin) {
      var cat, catId, catPro, cats, favorite, location;
      isAdmin = App.isAdmin();
      favorite = Product.findByAttribute('favorite', true);
      if (!favorite) {
        App.confirm('NO_FAVORITE_FOUND', {
          mode: 'alert'
        });
        return;
      }
      cats = CategoriesProduct.categories(favorite.id);
      catPro = CategoriesProduct.findByAttribute('product_id', favorite.id);
      if (!catPro) {
        if (App.confirm('FAVORITE_IN_TRASH')) {
          if (isAdmin) {
            window.location.href = '#/trash/products/';
            return;
          }
        } else {
          return;
        }
      }
      catId = catPro.category_id;
      cat = Category.find(catId);
      if (isAdmin) {
        location = '/category/' + catId + '/pid/' + favorite.id;
      } else {
        if (catPro.ignored || !Category["protected"][cat.name]) {
          return;
        }
        location = '/pages/' + cat.name + '#/item/' + favorite.id;
      }
      return location;
    };

    Product.descriptions = function(id) {
      return Description.filterSortByOrder(id);
    };

    Product.activePhotos = function() {
      var id;
      if (id = this.record.id) {
        return this.photos(id);
      }
      return this.contains();
    };

    Product.inactive = function() {
      return this.findAllByAttribute('active', false);
    };

    Product.createJoin = function(items, target, callback) {
      var cb, ga, isValid, item, ret, valid;
      if (items == null) {
        items = [];
      }
      this.log('createJoin');
      if (!Array.isArray(items)) {
        items = [items];
      }
      if (!(items.length && target)) {
        return;
      }
      isValid = true;
      cb = function() {
        Category.trigger('change:collection', target);
        if (typeof callback === 'function') {
          return callback.call(this);
        }
      };
      ret = (function() {
        var i, len, ref, results;
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          if (item.deleted) {
            item.deleted = false;
            item.save();
          }
          ga = new CategoriesProduct({
            category_id: target.id,
            product_id: item.id,
            ignored: true,
            order: parseInt((ref = CategoriesProduct.products(target.id).last()) != null ? ref.order : void 0) + 1 || 0
          });
          valid = ga.save({
            validate: true,
            ajax: false
          });
          if (!valid) {
            results.push(isValid = valid);
          } else {
            results.push(void 0);
          }
        }
        return results;
      })();
      if (isValid) {
        target.save({
          validate: false,
          done: cb
        });
      } else {
        Spine.trigger('refresh:all');
      }
      return ret;
    };

    Product.destroyJoin = function(items, target, callback) {
      var cb, e, ga, gas, i, item, len;
      if (items == null) {
        items = [];
      }
      if (!Array.isArray(items)) {
        items = [items];
      }
      cb = function() {};
      if (!target) {
        return;
      }
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        gas = CategoriesProduct.filter(item.id, {
          associationForeignKey: 'product_id'
        });
        ga = CategoriesProduct.productExists(item.id, target.id);
        try {
          if (ga != null) {
            ga.destroy({
              done: cb
            });
          }
        } catch (error) {
          e = error;
          alert(e);
        }
      }
      return Category.trigger('change:collection', target);
    };

    Product.throwWarning = function() {};

    Product.categorySelectionList = function() {
      var productId;
      if (Category.record && Product.record) {
        productId = Category.selectionList()[0];
        return Product.selectionList(productId);
      } else {
        return [];
      }
    };

    Product.details = function() {
      if (Product.record) {
        return Product.record.details();
      }
      return $().extend(Product.defaultDetails, {
        iCount: Photo.count(),
        sCount: Product.selectionList().length
      });
    };

    Product.findEmpties = function() {
      var ret;
      ret = [];
      this.each(function(item) {
        if (!item.photos().length) {
          return ret.push(item);
        }
      });
      return ret;
    };

    Product.findRelated_ = function(joins, joinid) {
      var i, join, len, record, results;
      if (joins == null) {
        joins = [];
      }
      if (joinid == null) {
        joinid = '';
      }
      results = [];
      for (i = 0, len = joins.length; i < len; i++) {
        join = joins[i];
        if ((record = this.find(join[joinid])) && !!(typeof (record.order = join.order) && !!typeof (record.ignored = join.ignored))) {
          results.push(record);
        }
      }
      return results;
    };

    Product.findRelated = function(joins, joinid) {
      var i, join, len, record, res;
      if (joins == null) {
        joins = [];
      }
      if (joinid == null) {
        joinid = '';
      }
      res = [];
      for (i = 0, len = joins.length; i < len; i++) {
        join = joins[i];
        if (record = this.find(join[joinid])) {
          res.push(record.silentUpdate({
            'order': join.order,
            'ignored': join.ignored
          }));
        }
      }
      return res;
    };

    Product.unusedProducts = function() {
      return this.filter(true, {
        func: 'selectUnused'
      });
    };

    Product.isUsedProduct = function(id) {
      var cp, ret;
      ret = (cp = CategoriesProduct.findByAttribute('product_id', id));
      return !!ret;
    };

    Product.validUrl = function(me) {
      if (/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)/.test(me.link)) {
        return true;
      }
      return false;
    };

    Product.renderBuffer = function(buffer) {
      var category, filterOptions, items;
      filterOptions = {
        model: 'Category',
        sort: 'sortByOrder'
      };
      if ((category = Category.record) || buffer) {
        items = Category.products(category.id, filterOptions);
      } else {
        items = Product.filter(true);
      }
      return this.buffer = items;
    };

    Product.prototype.init = function(instance) {
      var id, s;
      if (!(id = instance.id)) {
        return;
      }
      s = new Object();
      s[id] = [];
      return this.constructor.selection.push(s);
    };

    Product.prototype.parent = function() {
      return this.constructor.parent;
    };

    Product.prototype.isIgnored = function(cid) {
      if (cid == null) {
        cid = '';
      }
      return CategoriesProduct.isActiveProduct(cid, this.id);
    };

    Product.prototype.selChange = function(list) {};

    Product.prototype.createJoin = function(target) {
      return this.constructor.createJoin([this], target);
    };

    Product.prototype.destroyJoin = function(target) {
      return this.constructor.destroyJoin([this], target);
    };

    Product.prototype.contains = function(inc) {
      if (inc == null) {
        inc = 0;
      }
      return this.constructor.contains(this.id).length + inc;
    };

    Product.prototype.photos = function(max) {
      return this.constructor.photos(this.id, max);
    };

    Product.prototype.descriptions = function() {
      return this.constructor.descriptions(this.id);
    };

    Product.prototype.validUrl = function() {
      return this.constructor.validUrl(this);
    };

    Product.prototype.details = function() {
      return $().extend(this.defaultDetails, {
        iCount: this.photos().length,
        sCount: Product.selectionList().length,
        product: Product.record,
        category: Category.record
      });
    };

    Product.prototype.select_ = function(joinTableItems) {
      var i, len, record, ret;
      if (this.deleted) {
        return false;
      }
      ret = [];
      for (i = 0, len = joinTableItems.length; i < len; i++) {
        record = joinTableItems[i];
        if (record.product_id === this.id) {
          ret.push(record);
        }
      }
      return !!ret.length;
    };

    Product.prototype.select = function() {
      if (!this.deleted) {
        return true;
      }
    };

    Product.prototype.selectDeleted = function() {
      if (this.deleted) {
        return true;
      }
    };

    Product.prototype.selectProduct = function(id) {
      if (this.id === id) {
        return true;
      }
    };

    Product.prototype.selectUnused = function(id) {
      if (!CategoriesProduct.findByAttribute('product_id', this.id)) {
        return true;
      }
    };

    return Product;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Product = Product;
  }

}).call(this);
 },"models/products_photo": function(exports, require, module) { (function() {
  var $, CategoriesProduct, Category, Extender, Filter, Model, ProductsPhoto, Selector, Spine,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Filter = require("extensions/filter");

  Category = require('models/category');

  Model.Product = require('models/product');

  Model.Photo = require('models/photo');

  CategoriesProduct = require('models/categories_product');

  Selector = require("extensions/selector");

  Extender = require("extensions/model_extender");

  require("spine/lib/ajax");

  ProductsPhoto = (function(superClass) {
    extend(ProductsPhoto, superClass);

    function ProductsPhoto() {
      this.allProductPhotos = bind(this.allProductPhotos, this);
      return ProductsPhoto.__super__.constructor.apply(this, arguments);
    }

    ProductsPhoto.configure("ProductsPhoto", 'id', 'cid', 'product_id', 'photo_id', 'order');

    ProductsPhoto.extend(Model.Ajax);

    ProductsPhoto.extend(Filter);

    ProductsPhoto.extend(Selector);

    ProductsPhoto.extend(Extender);

    ProductsPhoto.url = 'products_photos';

    ProductsPhoto.productPhotoExists = function(pid, aid) {
      var aps;
      aps = this.filter('placeholder', {
        photo_id: pid,
        product_id: aid,
        func: 'selectUnique'
      });
      return aps[0] || false;
    };

    ProductsPhoto.productsPhotos = function(aid) {
      var aps;
      return aps = this.filter(aid, {
        associationForeignKey: 'product_id'
      });
    };

    ProductsPhoto.productPhotos = function(aid) {
      var ret;
      ret = [];
      this.each(function(item) {
        var photo;
        if (item['product_id'] === aid && (photo = Photo.find(item['photo_id']))) {
          return ret.push(photo);
        }
      });
      return ret;
    };

    ProductsPhoto.fromPhotoId = function(photo_id) {
      return (this.filter(photo_id, {
        func: 'selectByPhotoId'
      }))[0] || [];
    };

    ProductsPhoto.photos = function(aid, max) {
      var func;
      return func = Photo.filterRelated(aid, {
        model: 'Product',
        sort: 'sortByOrder'
      }).slice(0, max);
    };

    ProductsPhoto.products = function(pid, max) {
      return Product.filterRelated(pid, {
        model: 'Photo',
        sort: 'sortByOrder'
      }).slice(0, max);
    };

    ProductsPhoto.c = 0;

    ProductsPhoto.prototype.validate = function() {
      var ap, valid_1, valid_2;
      valid_1 = (Product.find(this.product_id)) && (Photo.find(this.photo_id));
      valid_2 = !(ap = this.constructor.productPhotoExists(this.photo_id, this.product_id) && this.isNew());
      if (!valid_1) {
        return 'Ungltige Aktion!';
      }
      if (!valid_2) {
        return 'Produkt existiert bereits in dieser Kategorie';
      }
      return false;
    };

    ProductsPhoto.prototype.products = function() {
      return this.constructor.products(this.photo_id);
    };

    ProductsPhoto.prototype.photos = function(id) {
      return this.constructor.photos(this.product_id);
    };

    ProductsPhoto.prototype.allProductPhotos = function() {
      var ap, aps, i, len, photos, product;
      product = Product.record;
      if (!product) {
        return;
      }
      photos = [];
      aps = ProductsPhoto.filter(product.id, {
        associationForeignKey: 'product_id'
      });
      for (i = 0, len = aps.length; i < len; i++) {
        ap = aps[i];
        if (Photo.exists(ap.product_id)) {
          photos.push(Photo.find(ap.product_id));
        }
      }
      return photos;
    };

    ProductsPhoto.prototype.select = function(id, options) {
      if (this[options.associationForeignKey] === id) {
        return true;
      }
    };

    ProductsPhoto.prototype.selectByPhotoId = function(id) {
      if (this.photo_id === id && this.product_id === Product.record.id) {
        return true;
      }
    };

    ProductsPhoto.prototype.selectUnique = function(empty, options) {
      if (this.photo_id === options.photo_id && this.product_id === options.product_id) {
        return true;
      }
    };

    return ProductsPhoto;

  })(Spine.Model);

  module.exports = Model.ProductsPhoto = ProductsPhoto;

}).call(this);
 },"models/products_trash": function(exports, require, module) { (function() {
  var $, Extender, Model, ProductsTrash, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Extender = require("extensions/model_extender");

  ProductsTrash = (function(superClass) {
    extend(ProductsTrash, superClass);

    function ProductsTrash() {
      return ProductsTrash.__super__.constructor.apply(this, arguments);
    }

    ProductsTrash.configure("ProductsTrash", 'id', 'location');

    ProductsTrash.extend(Extender);

    ProductsTrash.childType = 'Products';

    ProductsTrash.prototype.init = function(instance) {
      var id;
      if (!(id = instance.id)) {

      }
    };

    return ProductsTrash;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.ProductsTrash = ProductsTrash;
  }

}).call(this);
 },"models/recent": function(exports, require, module) { (function() {
  var $, Model, Photo, Recent, Spine, User,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Photo = require("models/photo");

  User = require("models/user");

  require('spine/lib/local');

  Recent = (function(superClass) {
    extend(Recent, superClass);

    function Recent() {
      return Recent.__super__.constructor.apply(this, arguments);
    }

    Recent.configure('Recent', 'id');

    Recent.extend(Model.Local);

    Recent.logout = function() {
      this.destroyAll();
      return this.redirect('logout');
    };

    Recent.redirect = function(url) {
      return location.href = base_url + url;
    };

    Recent.prototype.init = function(instance) {
      if (!instance) {

      }
    };

    Recent.loadRecent = function(max, callback) {
      if (max == null) {
        max = 100;
      }
      return $.ajax({
        contentType: 'application/json',
        dataType: 'json',
        processData: false,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        },
        url: base_url + 'photos/recent/' + max,
        type: 'GET',
        success: function(json) {
          return callback.call(this, json);
        },
        error: this.proxy(this.error)
      });
    };

    Recent.success = function(json) {};

    Recent.error = function(xhr) {
      this.logout();
      return this.redirect('users/login');
    };

    return Recent;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Recent = Recent;
  }

}).call(this);
 },"models/root": function(exports, require, module) { (function() {
  var $, Category, Extender, Filter, Model, Root, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Filter = require("extensions/filter");

  Extender = require("extensions/model_extender");

  Root = (function(superClass) {
    extend(Root, superClass);

    function Root() {
      return Root.__super__.constructor.apply(this, arguments);
    }

    Root.configure("Root", 'id');

    Root.extend(Extender);

    Root.childType = 'Category';

    Root.contains = function(id) {
      if (id == null) {
        id = this.record.id;
      }
      return Model[this.childType].all();
    };

    Root.prototype.init = function(instance) {};

    Root.prototype.contains = function(inc) {
      if (inc == null) {
        inc = 0;
      }
      return this.constructor.contains(this.id).length + inc;
    };

    return Root;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.Root = Root;
  }

}).call(this);
 },"models/settings": function(exports, require, module) { (function() {
  var $, Extender, Log, Model, Settings, Spine,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  Log = Spine.Log;

  Extender = require("extensions/model_extender");

  require('spine/lib/local');

  Settings = (function(superClass) {
    extend(Settings, superClass);

    function Settings() {
      return Settings.__super__.constructor.apply(this, arguments);
    }

    Settings.configure('Settings', 'hidden', 'agreed', 'sidebaropened', 'user_id', 'autoupload', 'hash', 'previousHash', 'intro');

    Settings.extend(Model.Local);

    Settings.extend(Extender);

    Settings.include(Log);

    Settings.prototype.init = function(instance) {};

    Settings.loadSettings = function() {
      var setting, user;
      if (user = User.first()) {
        setting = this.findByAttribute('user_id', user.id);
      } else {
        setting = this.first();
      }
      return setting;
    };

    Settings.isAutoUpload = function() {
      var setting;
      setting = this.loadSettings();
      return !!(setting != null ? setting.autoupload : void 0);
    };

    Settings.isIntroQuatsch = function() {
      var setting;
      setting = this.loadSettings();
      return !!(setting != null ? setting.intro : void 0);
    };

    Settings.findLogoSettings = function() {};

    return Settings;

  })(Spine.Model);

  module.exports = Model.Settings = Settings;

}).call(this);
 },"models/toolbar": function(exports, require, module) { (function() {
  var $, Category, Clipboard, Filter, Model, Product, Settings, Spine, Toolbar,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Spine = require("spine");

  $ = Spine.$;

  Model = Spine.Model;

  Category = require('models/category');

  Product = require('models/product');

  Clipboard = require('models/clipboard');

  Settings = require('models/settings');

  Filter = require("extensions/filter");

  Toolbar = (function(superClass) {
    extend(Toolbar, superClass);

    function Toolbar() {
      return Toolbar.__super__.constructor.apply(this, arguments);
    }

    Toolbar.configure('Toolbar', 'id', 'name', 'content');

    Toolbar.extend(Filter);

    Toolbar.load = function() {
      return this.refresh(this.tools(), {
        clear: true
      });
    };

    Toolbar.tools = function() {
      var key, ref, results, val;
      ref = this.data;
      results = [];
      for (key in ref) {
        val = ref[key];
        results.push(val);
      }
      return results;
    };

    Toolbar.dropdownGroups = {
      group_help: {
        name: 'Hilfe',
        icon: 'question-sign',
        content: [
          {
            name: 'Tastaturbefehle',
            klass: 'opt-Help ',
            disabled: function() {
              return true;
            }
          }, {
            name: 'ber',
            klass: 'opt-Version '
          }
        ]
      },
      group0: {
        name: 'Ansicht',
        content: [
          {
            name: function() {
              return 'bersicht';
            },
            klass: 'opt-ShowOverview',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            devider: true
          }, {
            name: function() {
              return 'Kategorien';
            },
            klass: 'opt-ShowCategories',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            name: function() {
              return 'Produkte-Katalog';
            },
            klass: 'opt-ShowAllProducts',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            name: function() {
              return 'Foto-Katalog';
            },
            klass: 'opt-ShowAllPhotos',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            devider: true
          }, {
            name: 'Vollbild Aus/Ein',
            klass: 'opt-FullScreen',
            icon: 'fullscreen',
            iconcolor: 'black'
          }, {
            name: 'Seitenleiste Ein/Aus',
            klass: 'opt-Sidebar',
            shortcut: '->|'
          }
        ]
      },
      group1: {
        name: 'Kategorie',
        content: [
          {
            name: 'Neu',
            icon: 'asterisk',
            klass: 'opt-CreateCategory'
          }, {
            devider: true
          }, {
            name: 'Bearbeiten',
            icon: 'pencil',
            klass: 'opt-Category',
            disabled: function() {}
          }, {
            name: 'Lschen',
            icon: 'bin',
            klass: 'opt-DeleteCategory',
            disabled: function() {
              var base, ret;
              return ret = !(typeof (base = Category.record).isValid === "function" ? base.isValid() : void 0);
            },
            shortcut: '<-'
          }, {
            devider: true
          }, {
            name: function() {
              return 'Kategorien';
            },
            klass: 'opt-ShowCategories',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }
        ]
      },
      group2: {
        name: 'Produkt',
        content: [
          {
            name: 'Neu',
            icon: 'asterisk',
            klass: 'opt-CreateProduct'
          }, {
            name: 'Aus Katalog hinzufgen',
            icon: 'plus',
            klass: 'opt-AddProducts',
            disabled: function() {
              return !Category.record;
            }
          }, {
            name: 'Dupizieren',
            icon: 'certificate',
            klass: 'opt-DuplicateProducts hide',
            disabled: function() {
              return !Product.record;
            }
          }, {
            devider: true
          }, {
            name: 'Bearbeiten',
            icon: 'pencil',
            klass: 'opt-Product',
            disabled: function() {}
          }, {
            name: function() {
              var len, model, modelName, type;
              len = 0;
              model = App.showView.current.model;
              modelName = App.showView.current.model.className;
              if (modelName === 'ProductsTrash') {
                type = 'Lschen';
                len = model.selectionList().length;
              } else {
                type = 'Entfernen';
                len = Category.selectionList().length;
              }
              return type + ' (' + len + ')';
            },
            icon: 'bin',
            klass: 'opt-DeleteProduct',
            disabled: function() {
              var len, model, modelName;
              len = 0;
              model = App.showView.current.model;
              modelName = App.showView.current.model.className;
              if (modelName === 'ProductsTrash') {
                len = model.selectionList().length;
              } else {
                len = Category.selectionList().length;
              }
              return !len;
            },
            shortcut: '<-'
          }, {
            devider: true
          }, {
            name: function() {
              var a, b;
              a = 'Verffentlichen';
              b = ' (' + Category.selectionList().length + ')<br>(Ein/Aus)';
              if (Category.record) {
                return a + b;
              } else {
                return a;
              }
            },
            icon: 'eye-open',
            klass: 'opt-ToggleVisible',
            shortcut: 'Ctrl-M',
            disabled: function() {
              return !Category.selectionList().length || !Category.record;
            }
          }, {
            devider: true
          }, {
            name: 'Kopieren',
            icon: '',
            klass: 'opt-CopyProduct',
            disabled: function() {
              return !Category.selectionList().length;
            },
            shortcut: 'Ctrl+C'
          }, {
            name: 'Auschneiden',
            icon: '',
            klass: 'opt-CutProduct',
            disabled: function() {
              return !Category.selectionList().length;
            },
            shortcut: 'Ctrl+X'
          }, {
            name: 'Einfgen',
            icon: '',
            klass: 'opt-PasteProduct',
            disabled: function() {
              return !Clipboard.findAllByAttribute('type', 'copy').length || !Category.record;
            },
            shortcut: 'Ctrl+V'
          }, {
            devider: true
          }, {
            name: function() {
              return 'Produkte-Katalog';
            },
            klass: 'opt-ShowAllProducts',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            name: function() {
              return 'zeige Produkt des Tages';
            },
            klass: 'opt-ShowFavorite',
            icon: 'star',
            disabled: function() {}
          }, {
            devider: true
          }, {
            name: function() {
              return 'Papierkorb';
            },
            klass: 'opt-ShowProductsTrash',
            icon: 'bin',
            disabled: function() {
              return false;
            }
          }
        ]
      },
      group3: {
        name: 'Foto',
        content: [
          {
            name: 'Upload',
            icon: 'upload',
            klass: 'opt-UploadDialogue'
          }, {
            name: 'Foto aus Katalog hinzufgen',
            icon: 'plus',
            klass: 'opt-AddPhotos',
            disabled: function() {
              return !Product.record;
            }
          }, {
            devider: true
          }, {
            name: function() {
              return 'Rotieren (' + Product.selectionList().length + ')';
            },
            header: true,
            disabled: true
          }, {
            name: 'Im Uhrzeiger',
            klass: 'opt-Rotate-cw',
            shortcut: 'Ctrl+R',
            icon: 'circle-arrow-right',
            disabled: function() {
              return !Product.selectionList().length;
            }
          }, {
            name: 'Gegen Uhrzeiger',
            klass: 'opt-Rotate-ccw',
            icon: 'circle-arrow-left',
            disabled: function() {
              return !Product.selectionList().length;
            }
          }, {
            devider: true
          }, {
            name: 'Bearbeiten',
            icon: 'pencil',
            klass: 'opt-Photo',
            disabled: function() {}
          }, {
            name: function() {
              var len, model, modelName, type;
              len = 0;
              model = App.showView.current.model;
              modelName = App.showView.current.model.className;
              if (modelName === 'PhotosTrash') {
                type = 'Lschen';
                len = model.selectionList().length;
              } else {
                type = 'Entfernen';
                len = Product.selectionList().length;
              }
              return type + ' (' + len + ')';
            },
            shortcut: '<-',
            icon: 'bin',
            klass: 'opt-DeletePhoto',
            disabled: function() {
              var len, model, modelName;
              len = 0;
              model = App.showView.current.model;
              modelName = App.showView.current.model.className;
              if (modelName === 'PhotosTrash') {
                len = model.selectionList().length;
              } else {
                len = Product.selectionList().length;
              }
              return !len;
            }
          }, {
            devider: true
          }, {
            name: 'Kopieren',
            icon: '',
            klass: 'opt-CopyPhoto',
            disabled: function() {
              return !Product.selectionList().length && App.showView.current.model.className.toLowerCase().indexOf('trash') >= 0;
            },
            shortcut: 'Ctrl+C'
          }, {
            name: 'Ausschneiden',
            icon: '',
            klass: 'opt-CutPhoto',
            disabled: function() {
              return !Product.selectionList().length && App.showView.current.model.className.toLowerCase().indexOf('trash') >= 0;
            },
            shortcut: 'Ctrl+X'
          }, {
            name: 'Einfgen',
            icon: '',
            klass: 'opt-PastePhoto',
            disabled: function() {
              return !Clipboard.findAllByAttribute('type', 'copy').length || !Product.record && App.showView.current.model.className.toLowerCase().indexOf('trash') >= 0;
            },
            shortcut: 'Ctrl+V'
          }, {
            devider: true
          }, {
            name: function() {
              return 'Foto-Katalog';
            },
            klass: 'opt-ShowAllPhotos',
            icon: 'book',
            disabled: function() {
              return false;
            }
          }, {
            devider: true
          }, {
            name: function() {
              return 'Papierkorb';
            },
            klass: 'opt-ShowPhotosTrash',
            icon: 'bin',
            disabled: function() {
              return false;
            }
          }, {
            devider: true
          }, {
            name: 'Auto Upload',
            icon: function() {
              if (Model.Settings.isAutoUpload()) {
                return 'ok';
              } else {
                return '';
              }
            },
            klass: 'opt-AutoUpload',
            disabled: function() {
              return true;
            }
          }
        ]
      },
      group31: {
        name: function() {
          return 'Extras';
        },
        content: [
          {
            name: function() {
              return 'Datensicherung anlegen';
            },
            klass: 'opt-MysqlDump',
            icon: 'floppy-open',
            disabled: function() {
              return false;
            }
          }, {
            name: 'Gesicherte Daten wiederherstellen',
            klass: 'opt-MysqlRestore',
            icon: 'floppy-save',
            disabled: function() {
              return false;
            }
          }, {
            name: 'Intro-Quatsch',
            klass: 'opt-IntroQuatsch',
            icon: function() {
              if (Model.Settings.isIntroQuatsch()) {
                return 'ok';
              } else {
                return '';
              }
            },
            disabled: function() {
              return true;
            }
          }
        ]
      },
      group4: {
        name: function() {
          var len;
          len = App.activePhotos().length;
          return 'Slideshow  <span class="badge">' + len + '</span>';
        },
        content: [
          {
            name: function() {
              return 'Preview';
            },
            klass: 'opt-SlideshowPreview',
            icon: 'picture',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }, {
            name: 'Start',
            klass: 'opt-SlideshowPlay',
            shortcut: 'Space',
            icon: 'play',
            dataToggle: 'modal-category',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }
        ]
      },
      group5: {
        name: function() {
          var len;
          len = App.activePhotos().length;
          return 'Slideshow  <span class="badge">' + len + '</span>';
        },
        content: [
          {
            name: function() {
              return 'Preview';
            },
            klass: 'opt-SlideshowPreview',
            icon: 'picture',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }, {
            name: 'Start',
            klass: 'opt-SlideshowPlay',
            shortcut: 'Space',
            icon: 'play',
            dataToggle: 'modal-category',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }
        ]
      }
    };

    Toolbar.data = {
      package_00: {
        name: 'Empty',
        content: []
      },
      package_01: {
        name: 'Default',
        content: [
          {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group_help
          }, {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group0
          }, {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group1
          }, {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group2
          }, {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group3
          }, {
            dropdown: true,
            itemGroup: Toolbar.dropdownGroups.group31
          }
        ]
      },
      package_02: {
        name: 'Close',
        content: [
          {
            name: '&times;',
            klass: 'opt opt-Previous',
            innerklass: 'close white',
            type: 'button'
          }
        ]
      },
      package_10: {
        name: 'Back_',
        locked: true,
        content: [
          {
            name: '&times;',
            klass: 'opt-Previous',
            type: 'span',
            icon: 'arrow-left',
            outerstyle: 'float: right;'
          }
        ]
      },
      package_11: {
        name: 'Chromeless',
        locked: true,
        content: [
          {
            name: 'Chromeless',
            klass: function() {
              return 'opt-FullScreen';
            },
            icon: '',
            dataToggle: 'button',
            outerstyle: ''
          }, {
            name: function() {
              return '';
            },
            klass: 'opt-SlideshowPlay',
            icon: 'play',
            iconcolor: 'white',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }
        ]
      },
      package_12: {
        name: 'Slider',
        content: [
          {
            name: '<span class="slider" style=""></span>',
            klass: 'opt-Thumbsize ',
            type: 'div',
            innerstyle: 'width: 190px; position: relative;'
          }
        ]
      },
      package_13: {
        name: 'SlideshowPackage',
        content: [
          {
            name: 'Fullscreen',
            klass: function() {
              return 'opt-FullScreen' + (App.showView.slideshowView.fullScreenEnabled() ? ' active' : '');
            },
            icon: 'fullscreen',
            dataToggle: 'button',
            outerstyle: ''
          }, {
            name: 'Start',
            klass: 'opt-SlideshowPlay',
            innerklass: 'symbol',
            icon: 'play',
            iconcolor: '',
            disabled: function() {
              return !App.activePhotos().length;
            }
          }, {
            name: '<span class="slider" style=""></span>',
            klass: 'opt-Thumbsize ',
            type: 'div',
            innerstyle: 'width: 190px; position: relative;'
          }
        ]
      },
      package_14: {
        name: 'FlickrRecent',
        content: [
          {
            name: function() {
              var details;
              details = App.flickrView.details('recent');
              return 'Recent Photos (' + details.from + '-' + details.to + ')';
            },
            klass: 'opt',
            innerklass: 'symbol',
            icon: 'picture',
            type: 'span'
          }, {
            name: '',
            klass: 'opt opt-Prev',
            icon: 'chevron-left',
            disabled: function() {}
          }, {
            name: '',
            klass: 'opt opt-Next',
            icon: 'chevron-right',
            disabled: function() {}
          }
        ]
      },
      package_15: {
        name: 'FlickrInter',
        content: [
          {
            name: function() {
              var details;
              details = App.flickrView.details('inter');
              return 'Interesting Stuff (' + details.from + '-' + details.to + ')';
            },
            icon: 'picture',
            klass: 'opt',
            type: 'span'
          }, {
            name: '',
            klass: 'opt opt-Prev',
            icon: 'chevron-left',
            disabled: function() {}
          }, {
            name: '',
            klass: 'opt opt-Next',
            icon: 'chevron-right',
            disabled: function() {}
          }
        ]
      },
      package_16: {
        name: 'Speichern',
        content: [
          {
            icon: 'arrow-left',
            klass: 'opt opt-Previous',
            type: 'span'
          }
        ]
      },
      package_17: {
        name: 'Trustami',
        content: [
          {
            name: '<span><button type="submit" class="btn left dark glyphicon glyphicon-chevron-up"></button><button type="submit" class="btn right dark glyphicon glyphicon-chevron-down"></button></span><input class="tmi" type="text" value=""></input>',
            klass: 'opt opt-SaveTrustami trustami-badge',
            type: 'span'
          }
        ]
      }
    };

    Toolbar.prototype.init = function(ins) {};

    Toolbar.prototype.select = function(list) {
      var ref;
      return ref = this.name, indexOf.call(list, ref) >= 0;
    };

    return Toolbar;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Toolbar;
  }

}).call(this);
 },"models/user": function(exports, require, module) { (function() {
  var $, Clipboard, Extender, Flash, Log, Model, Settings, Spine, User,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Spine = require("spine");

  $ = Spine.$;

  Log = Spine.Log;

  Model = Spine.Model;

  Flash = require("models/flash");

  Settings = require("models/settings");

  Clipboard = require("models/clipboard");

  Extender = require("extensions/model_extender");

  require('spine/lib/local');

  User = (function(superClass) {
    extend(User, superClass);

    function User() {
      this.success = bind(this.success, this);
      return User.__super__.constructor.apply(this, arguments);
    }

    User.configure('User', 'id', 'username', 'name', 'tmi', 'groupname', 'sessionid', 'hash', 'redirect');

    User.extend(Extender);

    User.extend(Model.Local);

    User.include(Log);

    User.trace = true;

    User.ping = function() {
      var user;
      this.fetch();
      if (user = this.first()) {
        return user.confirm();
      } else {
        alert('Authorisierung fehlgeschlagen.\nBitte melden Sie sich erneut an.');
        return this.redirect('users/login');
      }
    };

    User.logout = function() {
      if (this.user != null) {
        this.user.logout();
      }
      this.destroyAll();
      Clipboard.destroyAll();
      return $(window).off();
    };

    User.test = function() {
      return alert('test');
    };

    User.redirect = function(url, hash) {
      if (url == null) {
        url = '';
      }
      if (hash == null) {
        hash = '';
      }
      return location.href = base_url + url + hash;
    };

    User.prototype.init = function(instance) {};

    User.prototype.logout = function() {
      return $.ajax({
        url: base_url + 'users/logout',
        data: JSON.stringify(this),
        type: 'POST',
        success: this.logoutRedirect,
        error: this.errorHandler
      });
    };

    User.prototype.logoutRedirect = function(json) {
      var flash;
      json = $.parseJSON(json);
      Flash.fetch();
      flash = Flash.first() || new Flash;
      flash.updateAttributes(json);
      return User.redirect('logout');
    };

    User.prototype.confirm = function() {
      return $.ajax({
        url: base_url + 'users/ping',
        data: JSON.stringify(this),
        type: 'POST',
        success: this.success,
        error: this.proxy(this.errorHandler)
      });
    };

    User.prototype.getTmi = function(callback) {
      return $.ajax({
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        },
        url: base_url + 'users/getTmi',
        type: 'GET',
        processData: false,
        success: function(json) {
          return callback.call(this, json);
        },
        error: this.proxy(this.errorHandler)
      });
    };

    User.prototype.setTmi = function(callback) {
      return $.ajax({
        url: base_url + 'users/setTmi',
        data: JSON.stringify(this),
        type: 'POST',
        success: callback,
        error: this.proxy(this.errorHandler)
      });
    };

    User.prototype.isValid = function(callback) {
      return $.ajax({
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        },
        url: base_url + 'users/isValid',
        type: 'GET',
        processData: false,
        success: function(json) {
          return callback.call(this, json);
        },
        error: this.proxy(this.errorHandler)
      });
    };

    User.prototype.success = function(json) {
      return this.constructor.trigger('pinger', this, $.parseJSON(json));
    };

    return User;

  })(Spine.Model);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Model.User = User;
  }

}).call(this);
 },"scratch": function(exports, require, module) { (function() {


}).call(this);
 },"views/agb": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">I. Allgemeine Geschftsbedingungen</h3><h3 class=\"h3\"> 1 Grundlegende Bestimmungen</h3><p>(1) Die nachstehenden Geschftsbedingungen gelten fr alle Vertrge, die Sie mit uns als Anbieter (Angela Lehmann) ber die Internetseite www.ha-lehmann.at schlieen. Soweit nicht anders vereinbart, wird der Einbeziehung gegebenenfalls von Ihnen verwendeter eigener Bedingungen widersprochen.</p><p>(2) Verbraucher im Sinne der nachstehenden Regelungen ist jede natrliche Person, die ein Rechtsgeschft zu Zwecken abschliet, die berwiegend weder ihrer gewerblichen noch ihrer selbstndigen beruflichen Ttigkeit zugerechnet werden kann. Unternehmer ist jede natrliche oder juristische Person oder eine rechtsfhige Personengesellschaft, die bei Abschluss eines Rechtsgeschfts in Ausbung ihrer selbstndigen beruflichen oder gewerblichen Ttigkeit handelt.</p><h3 class=\"h3\"> 2 Zustandekommen des Vertrages</h3><p>(1) Gegenstand des Vertrages ist der Verkauf von Waren.</p><p>Unsere Angebote im Internet sind unverbindlich und kein verbindliches Angebot zum Abschluss eines Vertrages.</p><p>(2) Sie knnen ein verbindliches Kaufangebot (Bestellung) ber das Online-Warenkorbsystem abgeben. Dabei werden die zum Kauf beabsichtigten Waren im Warenkorb\" abgelegt. ber die entsprechende Schaltflche in der Navigationsleiste knnen Sie den Warenkorb\" aufrufen und dort jederzeit nderungen vornehmen. Nach Aufrufen der Seite Kasse\" und der Eingabe der persnlichen Daten sowie der Zahlungs- und Versandbedingungen werden abschlieend nochmals alle Bestelldaten auf der Bestellbersichtsseite angezeigt. Soweit Sie das Bezahl-System \"amazon-payments\" durch Anklicken der im Shopsystem integrierten Schaltflche \"Bezahlen ber amazon\" nutzen, werden Sie auf die Log-In Seite von amazon.de weitergeleitet. Nach erfolgreicher Anmeldung werden Ihre bei amazon.de hinterlegten Versandadressen und Zahlungsarten angezeigt. Sie whlen Versandadresse und Zahlungsart aus und werden ber die Schaltflche \"weiter\" zurck in unseren Online-Shop geleitet. Vor Absenden der Bestellung haben Sie die Mglichkeit, hier smtliche Angaben nochmals zu berprfen, zu ndern (auch ber die Funktion zurck\" des Internetbrowsers) bzw. den Kauf abzubrechen. Mit dem Absenden der Bestellung ber die Schaltflche \"zahlungspflichtig bestellen\" geben Sie ein verbindliches Angebot bei uns ab. Sie erhalten zunchst eine automatische E-Mail ber den Eingang Ihrer Bestellung, die noch nicht zum Vertragsschluss fhrt. Bei Zahlung ber \"amazon payments\" erhalten Sie diese Besttigungs-E-Mail von amazon.de.</p><p>(3) Die Annahme des Angebots (und damit der Vertragsabschluss) erfolgt innerhalb von 2 Tagen durchBesttigung in Textform (z.B. E-Mail), in welcher Ihnen die Ausfhrung der Bestellung oder Auslieferung der Ware besttigt wird (Auftragsbesttigung). Soweit Sie das Bezahl-System \"amazon-payments\" gewhlt haben, erfolgt die Angebotsannahme (Vertragsschluss) innerhalb von 2 Tagen durch Besttigung per E-Mail seitens amazon.de, in welcher Ihnen die Auslieferung der Ware mitgeteilt wird. Sollten Sie keine entsprechende Nachricht erhalten haben, sind Sie nicht mehr an Ihre Bestellung gebunden. Gegebenenfalls bereits erbrachte Leistungen werden in diesem Fall unverzglich zurckerstattet.</p><p>(4) Die Abwicklung der Bestellung und bermittlung aller im Zusammenhang mit dem Vertragsschlusserforderlichen Informationen erfolgt per E-Mail zum Teil automatisiert. Sie haben deshalb sicherzustellen, dass die von Ihnen bei uns hinterlegte E-Mail-Adresse zutreffend ist, der Empfang der E-Mails technisch sichergestellt und insbesondere nicht durch SPAM-Filter verhindert wird.</p><h3 class=\"h3\"> 3 Zurckbehaltungsrecht, Eigentumsvorbehalt</h3><p>(1) Ein Zurckbehaltungsrecht knnen Sie nur ausben, soweit es sich um Forderungen aus dem selben Vertragsverhltnis handelt.</p><p>(2) Die Ware bleibt bis zur vollstndigen Zahlung des Kaufpreises unser Eigentum.</p><h3 class=\"h3\"> 4 Haftung</h3><p>(1) Wir haften jeweils uneingeschrnkt fr Schden aus der Verletzung des Lebens, des Krpers oder der Gesundheit. Weiter haften wir ohne Einschrnkung in allen Fllen des Vorsatzes und grober Fahrlssigkeit, bei arglistigem Verschweigen eines Mangels, bei bernahme der Garantie fr die Beschaffenheit des Kaufgegenstandes und in allen anderen gesetzlich geregelten Fllen.</p><p>(2) Die Haftung fr Mngel im Rahmen der gesetzlichen Gewhrleistung richtet sich nach der entsprechenden Regelung in unseren Kundeninformationen (Teil II).</p><p>(3) Sofern wesentliche Vertragspflichten betroffen sind, ist unsere Haftung bei leichter Fahrlssigkeit auf den vertragstypischen, vorhersehbaren Schaden beschrnkt. Wesentliche Vertragspflichten sind wesentliche Pflichten, die sich aus der Natur des Vertrages ergeben und deren Verletzung die Erreichung des Vertragszweckes gefhrden wrde sowie Pflichten, die der Vertrag uns nach seinem Inhalt zur Erreichung des Vertragszwecks auferlegt, deren Erfllung die ordnungsgeme Durchfhrung des Vertrags berhaupt erst mglich machen und auf deren Einhaltung Sie regelmig vertrauen drfen.</p><p>(4) Bei der Verletzung unwesentlicher Vertragspflichten ist die Haftung bei leicht fahrlssigen Pflichtverletzungen ausgeschlossen.</p><p>(5) Die Datenkommunikation ber das Internet kann nach dem derzeitigen Stand der Technik nicht fehlerfrei und/oder jederzeit verfgbar gewhrleistet werden. Wir haften insoweit weder fr die stndige noch ununterbrochene Verfgbarkeit der Webseite und der dort angebotenen Dienstleistung.</p><h3 class=\"h3\"> 5 Rechtswahl</h3><p>(1) Es gilt deutsches Recht. Bei Verbrauchern gilt diese Rechtswahl nur, soweit hierdurch der durch zwingende Bestimmungen des Rechts des Staates des gewhnlichen Aufenthaltes des Verbrauchers gewhrte Schutz nicht entzogen wird (Gnstigkeitsprinzip).</p><p>(2) Die Bestimmungen des UN-Kaufrechts finden ausdrcklich keine Anwendung.</p><h3 class=\"h3\"> 6 Jugendschutz</h3><p>(1) Beim Verkauf von Ware, die den Regelungen des Jugendschutzgesetzes unterfllt, gehen wir nur Vertragsbeziehungen mit Kunden ein, die das gesetzlich vorgeschriebene Mindestalter erreicht haben. Auf bestehende Altersbeschrnkungen wird in der jeweiligen Artikelbeschreibung hingewiesen.</p><p>(2) Sie versichern mit Absenden Ihrer Bestellung, das gesetzlich vorgeschriebene Mindestalter erreicht zu haben und dass Ihre Angaben bezglich Ihres Namens und Ihrer Adresse richtig sind. Sie sind verpflichtet, dafr Sorge zu tragen, dass nur Sie selbst oder solche von Ihnen zur Entgegennahme der Lieferung ermchtigte Personen, die das gesetzlich vorgeschriebene Mindestalter erreicht haben, die Ware in Empfang nehmen.</p><p>(3) Soweit wir aufgrund der gesetzlichen Bestimmungen verpflichtet sind, eine Alterskontrolle vorzunehmen,weisen wir den mit der Lieferung beauftragten Logistikdienstleister an, die Lieferung nur an Personen zu bergeben, die das gesetzlich vorgeschriebene Mindestalter erreicht haben, und sich im Zweifelsfall den Personalausweis der die Ware in Empfang nehmenden Person zur Alterskontrolle vorzeigen zu lassen.</p><p>(4) Soweit wir ber das gesetzlich vorgeschriebene Mindestalter hinausgehend in der jeweiligen Artikelbeschreibung ausweisen, dass Sie fr den Kauf der Ware das 18. Lebensjahr vollendet haben mssen, gelten vorstehende Abstze 1-3 mit der Magabe, dass anstelle des gesetzlich vorgeschriebenen Mindestalters Volljhrigkeit vorliegen muss.</p><h3 class=\"h3\">II. Kundeninformationen</h3><h3 class=\"h3\">1. Identitt des Verkufers</h3><p>Angela Lehmann</p><p>Dornachgasse 15</p><p>6850 Dornbirn</p><p>sterreich</p><p>Telefon: 00436641306372</p><p>E-Mail: ha-lehmann@gmx.at</p><p></p><p>Die Europische Kommission stellt eine Plattform fr die auergerichtliche Online-Streitbeilegung (OS-Plattform) bereit, aufrufbar unter http://ec.europa.eu/odr.</p><h3 class=\"h3\">2. Informationen zum Zustandekommen des Vertrages</h3><p>Die technischen Schritte zum Vertragsschluss, der Vertragsschluss selbst und die Korrekturmglichkeiten erfolgen nach Magabe des  2 unserer Allgemeinen Geschftsbedingungen (Teil I.).</p><h3 class=\"h3\">3. Vertragssprache, Vertragstextspeicherung</h3><p>3.1. Vertragssprache ist deutsch.</p><p>3.2. Der vollstndige Vertragstext wird von uns nicht gespeichert. Vor Absenden der Bestellung ber das Online Warenkorbsystem  knnen die Vertragsdaten ber die Druckfunktion des Browsers ausgedruckt oder elektronisch gesichert werden. Nach Zugang der Bestellung bei uns werden die Bestelldaten, die gesetzlich vorgeschriebenen Informationen bei Fernabsatzvertrgen und die Allgemeinen Geschftsbedingungen nochmals per E-Mail an Sie bersandt.</p><h3 class=\"h3\">4. Wesentliche Merkmale der Ware oder Dienstleistung</h3><p>Die wesentlichen Merkmale der Ware und/oder Dienstleistung finden sich im jeweiligen Angebot.</p><h3 class=\"h3\">5. Preise und Zahlungsmodalitten</h3><p>5.1. Die in den jeweiligen Angeboten angefhrten Preise sowie die Versandkosten stellen Gesamtpreise dar. Sie beinhalten alle Preisbestandteile einschlielich aller anfallenden Steuern.</p><p>5.2. Die anfallenden Versandkosten sind nicht im Kaufpreis enthalten. Sie sind ber eine entsprechend bezeichnete Schaltflche auf unserer Internetprsenz oder im jeweiligen Angebot aufrufbar, werden im Laufe des Bestellvorganges gesondert ausgewiesen und sind von Ihnen zustzlich zu tragen, soweit nicht die versandkostenfreie Lieferung zugesagt ist.</p><p>5.3. Die Ihnen zur Verfgung stehenden Zahlungsarten sind unter einer entsprechend bezeichneten Schaltflche auf unserer Internetprsenz oder im jeweiligen Angebot ausgewiesen.</p><p>5.4. Soweit bei den einzelnen Zahlungsarten nicht anders angegeben, sind die Zahlungsansprche aus dem geschlossenen Vertrag sofort zur Zahlung fllig.</p><h3 class=\"h3\">6. Lieferbedingungen</h3><p>6.1. Die Lieferbedingungen, der Liefertermin sowie gegebenenfalls bestehende Lieferbeschrnkungen finden sich unter einer entsprechend bezeichneten Schaltflche auf unserer Internetprsenz oder im jeweiligen Angebot.</p><p>6.2. Soweit Sie Verbraucher sind ist gesetzlich geregelt, dass die Gefahr des zuflligen Untergangs und der zuflligen Verschlechterung der verkauften Sache whrend der Versendung erst mit der bergabe der Ware an Sie bergeht, unabhngig davon, ob die Versendung versichert oder unversichert erfolgt. Dies gilt nicht, wenn Sie eigenstndig ein nicht vom Unternehmer benanntes Transportunternehmen oder eine sonst zur Ausfhrung der Versendung bestimmte Person beauftragt haben. </p><h3 class=\"h3\">7. Gesetzliches Mngelhaftungsrecht</h3><p>7.1. Es bestehen die gesetzlichen Mngelhaftungsrechte.</p><p>7.2. Als Verbraucher werden Sie gebeten, die Ware bei Lieferung umgehend auf Vollstndigkeit, offensichtliche Mngel und Transportschden zu berprfen und uns sowie dem Spediteur Beanstandungen schnellstmglich mitzuteilen. Kommen Sie dem nicht nach, hat dies keine Auswirkung auf Ihre gesetzlichen Gewhrleistungsansprche. Diese AGB und Kundeninformationen wurden von den auf IT-Recht spezialisierten Juristen des Hndlerbundes erstellt und werden permanent auf Rechtskonformitt geprft. Die Hndlerbund Management AG garantiert fr die Rechtssicherheit der Texte und haftet im Falle von Abmahnungen. Nhere Informationen dazu finden Sie unter: http://www.haendlerbund.de/agb-service.</p><p></p><h3 class=\"h3\">Hinweise zur Batterieentsorgung</h3><p>Im Zusammenhang mit dem Vertrieb von Batterien oder mit der Lieferung von Gerten, die Batterien enthalten, sind wir verpflichtet, Sie auf folgendes hinzuweisen:</p><p>Sie sind zur Rckgabe gebrauchter Batterien als Endnutzer gesetzlich verpflichtet. Sie knnen Altbatterien, die wir als Neubatterien im Sortiment fhren oder gefhrt haben, unentgeltlich an unserem Versandlager (Handelsagentur Lehmann, Dornachgasse 15, 6850 Dornbirn, sterreich) zurckgeben.</p><p>Die auf den Batterien abgebildeten Symbole haben folgende Bedeutung:</p><p> </p><p>Das Symbol der durchgekreuzten Mlltonne bedeutet, dass die Batterie nicht in den Hausmll gegeben werden darf.</p><p>Pb = Batterie enthlt mehr als 0,004 Masseprozent Blei</p><p>Cd = Batterie enthlt mehr als 0,002 Masseprozent Cadmium</p><p>Hg = Batterie enthlt mehr als 0,0005 Masseprozent Quecksilber.</p><p>letzte Aktualisierung: 28.09.2016</p>");;return buf.join("");
}; },"views/agb_1": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\"><div>Allgemeine Geschftsbedingungen</div></h3><h5 class=\"h5\">Geltungsbereich</h5><p>Fr alle Bestellungen ber unseren Online-Shop gelten die nachfolgenden AGB.</p><h5 class=\"h5\">Selbstabholung</h5><p>Nach Terminvereinbarung mglich.</p><h5 class=\"h5\">Packstation</h5><p>Wir liefern nicht an Packstationen.</p><h5 class=\"h5\">Eigentumsvorbehalt </h5><p>Die Ware bleibt bis zur vollstndigen Bezahlung unser Eigentum.</p><h5 class=\"h5\">Transportschden</h5><p>Werden Waren mit offensichtlichen Transportschden angeliefert, so reklamieren Sie solche Fehler bitte mglichst sofort beim Zusteller und nehmen Sie bitte unverzglich Kontakt zu uns auf. Die Versumung einer Reklamation oder Kontaktaufnahme hat fr Ihre gesetzlichen Ansprche und deren Durchsetzung, insbesondere Ihre Gewhrleistungsrechte keinerlei Konsequenzen. Sie helfen uns aber, unsere eigenen Ansprche gegenber dem Frachtfhrer bzw. Transportversicherung geltend machen zu knnen.</p><h5 class=\"h5\">Vertragssprache</h5><p>Die fr den Vertragsschluss zur Verfgung stehende Sprache ist Deutsch.</p><h5 class=\"h5\">Jugendschutz</h5><p>Bestimmte Artikel unseres Sortiments gehren ausschlielich in die Hnde von Erwachsenen. Wir behalten uns fr diese in den Produktbeschreibungen jeweils speziell gekennzeichnete Artikel vor, diese nur an volljhrige, unbeschrnkt geschftsfhige natrliche Personen auszuliefern und dabei entsprechende Altersnachweise zu verlangen. Die fr die Bestellung erforderlichen Daten wie Name, Anschrift usw. sind vollstndig und wahrheitsgem anzugeben.  </p><h5 class=\"h5\">Widerrufsbelehrung</h5><p>Sie haben das Recht, binnen vierzehn Tagen ohne Angabe von Grnden diesen Vertrag zu widerrufen. Die Widerrufsfrist betrgt vierzehn Tage ab dem Tag an dem Sie oder ein von Ihnen benannter Dritter, der nicht der Befrderer ist, die letzte Ware in Besitz genommen haben bzw. hat. Um Ihr Widerrufsrecht auszuben, mssen Sie uns (Handelsagentur Lehmann, Angela Lehmann, Dornachgasse 15, 6850 Dornbirn, sterreich, Telefon 0043-664-1306372, eMail: ha-lehmann@gmx.at) mittels einer eindeutigen Erklrung (z.B. ein mit der Post versandter Brief, Telefax oder E-Mail) ber Ihren Entschluss, diesen Vertrag zu widerrufen, informieren. Sie knnen dafr das beigefgte Muster-Widerrufsformular verwenden, das jedoch nicht vorgeschrieben ist. Zur Wahrung der Widerrufsfrist reicht es aus, dass Sie die Mitteilung ber die Ausbung des Widerrufsrechts vor Ablauf der Widerrufsfrist absenden.</p><h5 class=\"h5\">Folgen des Widerrufs</h5><p>Wenn Sie diesen Vertrag widerrufen, haben wir Ihnen alle Zahlungen, die wir von Ihnen erhalten haben, einschlielich der Lieferkosten (mit Ausnahme der zustzlichen Kosten, die sich daraus ergeben, dass Sie eine andere Art der Lieferung als die von uns angebotene, gnstigste Standardlieferung gewhlt haben), unverzglich und sptestens binnen vierzehn Tagen ab dem Tag zurckzuzahlen, an dem die Mitteilung ber Ihren Widerruf dieses Vertrags bei uns eingegangen ist. Fr diese Rckzahlung verwenden wir dasselbe Zahlungsmittel, das Sie bei der ursprnglichen Transaktion eingesetzt haben, es sei denn, mit Ihnen wurde ausdrcklich etwas anderes vereinbart; in keinem Fall werden Ihnen wegen dieser Rckzahlung Entgelte berechnet. Wir knnen die Rckzahlung verweigern, bis wir die Waren wieder zurckerhalten haben oder bis Sie den Nachweis erbracht haben, dass Sie die Waren zurckgesandt haben, je nachdem, welches der frhere Zeitpunkt ist. Sie haben die Waren unverzglich und in jedem Fall sptestens binnen vierzehn Tagen ab dem Tag, an dem Sie uns ber den Widerruf dieses Vertrags unterrichten, an uns zurckzusenden oder zu bergeben. Die Frist ist gewahrt, wenn Sie die Waren vor Ablauf der Frist von vierzehn Tagen absenden. Sie tragen die unmittelbaren Kosten der Rcksendung der Waren. Sie mssen fr einen etwaigen Wertverlust der Waren nur aufkommen, wenn dieser Wertverlust auf einen zur Prfung der Beschaffenheit, Eigenschaften und Funktionsweise der Waren nicht notwendigen Umgang mit ihnen zurckzufhren ist.</p><h5 class=\"h5\">Widerrufsformular</h5><iframe src=\"https://docs.google.com/forms/d/e/1FAIpQLSdKP-t3e19dPw1xbsJmaJqCzfTNMWQQ_Knyqr-F5Cfrlej7Jw/viewform?embedded=true\" width=\"100%\" height=\"1350\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\"><div>Wird geladen...</div></iframe>");;return buf.join("");
}; },"views/carousel": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (id, slides, undefined) {
buf.push("<div tabindex=\"3\" data-ride=\"\"" + (jade.attr("id", id, true, false)) + " style=\"min-height: 330px;\" class=\"carousel slide\"> <div class=\"carousel-inner\">");
// iterate slides
;(function(){
  var $$obj = slides;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var vals = $$obj[index];

buf.push("<div" + (jade.cls(['item',index==0 ? 'active' : ''], [null,true])) + ">");
if ( vals.items)
{
buf.push("<ul class=\"liststyle\">");
// iterate vals.items
;(function(){
  var $$obj = vals.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var val = $$obj[index];

if ( val.items)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val.items[0]) ? "" : jade_interp)) + "<ul>");
// iterate val.items
;(function(){
  var $$obj = val.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul></li>");
}
else
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var val = $$obj[index];

if ( val.items)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val.items[0]) ? "" : jade_interp)) + "<ul>");
// iterate val.items
;(function(){
  var $$obj = val.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul></li>");
}
else
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul>");
}
else if ( vals.img)
{
buf.push("<img" + (jade.attr("src", vals.img, true, false)) + (jade.attr("width", vals.width, true, false)) + "/>");
}
buf.push("</div>");
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var vals = $$obj[index];

buf.push("<div" + (jade.cls(['item',index==0 ? 'active' : ''], [null,true])) + ">");
if ( vals.items)
{
buf.push("<ul class=\"liststyle\">");
// iterate vals.items
;(function(){
  var $$obj = vals.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var val = $$obj[index];

if ( val.items)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val.items[0]) ? "" : jade_interp)) + "<ul>");
// iterate val.items
;(function(){
  var $$obj = val.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul></li>");
}
else
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var val = $$obj[index];

if ( val.items)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val.items[0]) ? "" : jade_interp)) + "<ul>");
// iterate val.items
;(function(){
  var $$obj = val.items;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var subval = $$obj[index];

if ( index != 0)
{
buf.push("<li>" + (jade.escape(null == (jade_interp = subval) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul></li>");
}
else
{
buf.push("<li>" + (jade.escape(null == (jade_interp = val) ? "" : jade_interp)) + "</li>");
}
    }

  }
}).call(this);

buf.push("</ul>");
}
else if ( vals.img)
{
buf.push("<img" + (jade.attr("src", vals.img, true, false)) + (jade.attr("width", vals.width, true, false)) + "/>");
}
buf.push("</div>");
    }

  }
}).call(this);

buf.push("</div><a" + (jade.attr("href", '#'+id, true, false)) + " data-slide=\"prev\" class=\"left carousel-control\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a><a" + (jade.attr("href", '#'+id, true, false)) + " data-slide=\"next\" class=\"right carousel-control\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a><ol class=\"carousel-indicators top\">");
// iterate slides
;(function(){
  var $$obj = slides;
  if ('number' == typeof $$obj.length) {

    for (var index = 0, $$l = $$obj.length; index < $$l; index++) {
      var val = $$obj[index];

buf.push("<li" + (jade.attr("data-target", '#'+id, true, false)) + (jade.attr("data-slide-to", index, true, false)) + (jade.cls([index==0 ? 'active' : ''], [true])) + "></li>");
    }

  } else {
    var $$l = 0;
    for (var index in $$obj) {
      $$l++;      var val = $$obj[index];

buf.push("<li" + (jade.attr("data-target", '#'+id, true, false)) + (jade.attr("data-slide-to", index, true, false)) + (jade.cls([index==0 ? 'active' : ''], [true])) + "></li>");
    }

  }
}).call(this);

buf.push("</ol></div>");}.call(this,"id" in locals_for_with?locals_for_with.id:typeof id!=="undefined"?id:undefined,"slides" in locals_for_with?locals_for_with.slides:typeof slides!=="undefined"?slides:undefined,"undefined" in locals_for_with?locals_for_with.undefined:typeof undefined!=="undefined"?undefined:undefined));;return buf.join("");
}; },"views/delivery": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">Versandkosten</h3><p>Kosten des Versandes nach sterreich: 3,90 Euro</p><p>Kosten des Versandes nach Deuschland (ausser Inseln): 5,90 Euro</p><p>Ab einem Bestellwert von 50,00 Euro liefern wir innerhalb sterreich versandkostenfrei!!</p><p>Wir versenden mit den Paketdiensten DPD und DHL.</p><hr/><p>Sollten Sie DPD im Abwesenheitsfall, per Benachrichtigungskarte oder telefonisch, eine neue Lieferadresse mitteilen, fallen noch einmal Portokosten in Hhe von  3,90 (sterreich) bzw.  5,90 (Deutschland) an.</p><h3 class=\"h3\">Lieferfristen</h3><p>Soweit im jeweiligen Angebot keine andere Frist angegeben ist, erfolgt die Lieferung der Ware in sterreich innerhalb von 2-4 Tagen, bei Auslandslieferungen innerhalb von 2-5 Tagen nach Vertragsschluss (bei vereinbarter Vorauszahlung nach dem Zeitpunkt Ihrer Zahlungsanweisung).</p><p>Beachten Sie, dass an Sonn- und Feiertagen keine Zustellung erfolgt.</p><p>Haben Sie Artikel mit unterschiedlichen Lieferzeiten bestellt, versenden wir die Ware in einer gemeinsamen Sendung, sofern wir keine abweichenden Vereinbarungen mit Ihnen getroffen haben. Die Lieferzeit bestimmt sich in diesem Fall nach dem Artikel mit der lngsten Lieferzeit den Sie bestellt haben.</p><p>Bei Selbstabholung informieren wir Sie per E-Mail ber die Bereitstellung der Ware und die Abholmglichkeiten. In diesem Fall werden keine Versandkosten berechnet.</p><hr/><h3 class=\"h3\">Zahlungsbedingungen</h3><p>Bei Lieferungen innerhalb sterreichs haben Sie folgende Zahlungsmglichkeiten:</p><p>-  Barzahlung bei Abholung</p><p>-  Vorkasse per berweisung</p><p>-  Zahlung per Nachnahme </p><p>-  Zahlung per PayPal</p><p>-  Zahlung per amazon payments</p><p>Bei Lieferungen ins Ausland haben Sie folgende Zahlungsmglichkeiten:</p><p>-  Barzahlung bei Abholung</p><p>-  Vorkasse per berweisung</p><p>-  Zahlung per Lastschrift (Bankeinzug)</p><p>-  Zahlung per PayPal</p><p>-  Zahlung per amazon payments</p><p> </p><p>Bei Zahlung per Lastschrift (Bankeinzug) ermchtigen Sie uns widerruflich, den Rechnungsbetrag vom angegebenen Konto einzuziehen.</p><p> </p><p>Unsere Bankverbindung:</p><p>IBAN: AT482060200000347112</p><p>BIC: DOSPAT2DXXX</p>");;return buf.join("");
}; },"views/imp": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">Gesetzliche Anbieterkennung</h3><p>Handelsagentur Lehmann</p><p>Angela Lehmann</p><p>Dornachgasse 15</p><p>6850 Dornbirn</p><p>Vorarlberg -  sterreich</p><hr/><p>Telefon: +43 664-1306372</p><p>Telefax: +43 5572-422498</p><p>Email  : ha-lehmann@gmx.at</p><p>USt-IdNr.: ATU71224409</p><p>Wi-ID-Nr.: 8206629</p><p> </p><p>Unternehmensgegenstand: Online-Handel mit Outdoor, Fitness und Restposten</p><p>Mitgliedschaften: Hndlerbund</p><p>Berufsrecht: Gewerbeordnung: http://www.ris.bka.gv.at</p><p>Aufsichtsbehrde: Bezirkshauptmannschaft Dornbirn</p><p> </p><hr/><p>Die Europische Kommission stellt eine Plattform fr die auergerichtliche Online-Streitbeilegung (OS-Plattform) bereit, aufrufbar unter . http://ec.europa.eu/odr</p><p>Wir sind seit 01.12.2016 Mitglied der Initiative \"FairCommerce\". Nhere Informationen hierzu finden Sie unter www.fair-commerce.de.</p><hr/><p><div><a href=\"https://www.haendlerbund.de/faircommerce\" target=\"_blank\"><img src=\"/img/fc_logo.gif\"/></a></div></p>");;return buf.join("");
}; },"views/notify": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (text) {
buf.push("<p><div>" + (((jade_interp = text) == null ? '' : jade_interp)) + "</div></p>");}.call(this,"text" in locals_for_with?locals_for_with.text:typeof text!=="undefined"?text:undefined));;return buf.join("");
}; },"views/pay": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">Paypal</h3><p>Profitieren Sie von dieser einfachen und schnellen Zahlungsabwicklung</p><p>Sie sind ber den PayPal-Verkuferschutz abgesichert</p><h3 class=\"h3\">Vorkasse</h3><p>Sie berweisen den Rechnungsbetrag per Vorkasse auf unser Konto. Sofort nach Geldeingang erfolgt die Lieferung an Sie! Vermerken Sie bei Ihrer berweisung bitte unbedingt Ihren Namen und, falls bekannt, Ihre Kundennummer und die Bestellnummer! Dies beschleunigt den Versand an Sie!</p><h3 class=\"h3\">Bei Abholung</h3><p>Nach Terminabsprache erhalten Sie den gewnschten Artikel gegen Barzahlung.</p>");;return buf.join("");
}; },"views/privacy": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">Herzlich Willkommen auf unserer Webseite!</h3><p></p><p>Wir legen grten Wert auf den Schutz Ihrer Daten und die Wahrung Ihrer Privatsphre. Nachstehend informieren wir Sie deshalb ber die Erhebung und Verwendung persnlicher Daten bei Nutzung unserer Webseite. Anonyme Datenerhebung Sie knnen unsere Webseiten besuchen, ohne Angaben zu Ihrer Person zu machen. Wir speichern in diesem Zusammenhang keinerlei persnliche Daten. Um unser Angebot zu verbessern, werten wir lediglich statistische Daten aus, die keinen Rckschluss auf Ihre Person erlauben. Erhebung, Verarbeitung und Nutzung personenbezogener Daten Wir erheben personenbezogene Daten (Einzelangaben ber persnliche oder sachliche Verhltnisse einer bestimmten oder bestimmbaren natrlichen Person) nur in dem von Ihnen zur Verfgung gestellten Umfang. Die Verarbeitung und Nutzung Ihrer personenbezogenen Daten erfolgt zur Erfllung und Abwicklung Ihrer Bestellung sowie zur Bearbeitung Ihrer Anfragen. Nach vollstndiger Vertragsabwicklung werden alle personenbezogenen Daten zunchst unter Bercksichtigung steuer- und handelsrechtlicher Aufbewahrungsfristen gespeichert und dann nach Fristablauf gelscht, sofern Sie der weitergehenden Verarbeitung und Nutzung nicht zugestimmt haben. Zustzlich weisen wir auf Folgendes hin: Wir verwenden das . Nach Ihrer Bestellung mchten wir Sie bitten, Ihren Kauf Kufersiegel-Bewertungssystem bei uns zu bewerten und zu kommentieren. Zu diesem Zweck werden Sie von uns im Rahmen der Vertragsabwicklung angeschrieben, wobei wir uns hierbei des technischen Systems des Anbieters des Kufersiegel-Bewertungstools, der Hndlerbund Management AG,  Leipzig, im Torgauer Strae 233 B, 04347 Rahmen einer Auftragsdatenverarbeitung bedienen. Ihre E-Mail-Adresse wird dabei nur zu diesem Zweck und insbesondere nicht zu weitergehender Werbung benutzt und auch nicht an sonstige Dritte weitergegeben. Die in diesem Zusammenhang im technischen System des Kufersiegel-Bewertungstools gespeicherten personenbezogenen Daten werden 3 Monate nach der zur Bewertung erfassten Warenlieferung gelscht. Weitergabe personenbezogener Daten Eine Weitergabe Ihrer Daten an Dritte ohne Ihre ausdrckliche Einwilligung erfolgt nicht. Ausgenommen hiervon sind lediglich unsere Dienstleistungspartner, die wir zur Abwicklung des Vertragsverhltnisses bentigen. In diesen Fllen beachten wir strikt die Vorgaben des Bundesdatenschutzgesetzes. Der Umfang der Datenbermittlung beschrnkt sich auf ein Mindestma. Cookies Unsere Internetseiten verwenden an mehreren Stellen so genannte Cookies. Cookies sind kleine Textdateien, die auf Ihrem Rechner abgelegt werden und die Ihr Browser speichert. Sie dienen dazu, unser Angebot nutzerfreundlicher, effektiver und sicherer zu machen. Des Weiteren ermglichen Cookies unseren Systemen, Ihren Browser zu erkennen und Ihnen Services anzubieten. Cookies enthalten keine personenbezogenen Daten. Auskunft, Berichtigung, Sperrung und Lschung von Daten Sie haben jederzeit das Recht auf unentgeltliche Auskunft ber Ihre gespeicherten Daten sowie das Recht auf Berichtigung, Lschung bzw. Sperrung. Kontaktieren Sie uns auf Wunsch. Die Kontaktdaten finden Sie in unserem Impressum.</p><p></p><p>letzte Aktualisierung: 03.12.2015</p>");;return buf.join("");
}; },"views/product": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<li><h5 class=\"h5\">Paypal</h5><p>Profitieren Sie von dieser einfachen und schnellen Zahlungsabwicklung</p><p>Sie sind ber den PayPal-Verkuferschutz abgesichert</p></li><li><h5 class=\"h5\">Vorkasse</h5><p>Sie berweisen den Rechnungsbetrag per Vorkasse auf unser Konto. Sofort nach Geldeingang erfolgt die Lieferung an Sie! Vermerken Sie bei Ihrer berweisung bitte unbedingt Ihren Namen und, falls bekannt, Ihre Kundennummer und die Bestellnummer! Dies beschleunigt den Versand an Sie!</p></li><li><h5 class=\"h5\">Bei Abholung</h5><p>Nach Terminabsprache erhalten Sie den gewnschten Artikel gegen Barzahlung.</p></li>");;return buf.join("");
}; },"views/revocation": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<h3 class=\"h3\">Widerrufsrecht fr Verbraucher</h3><p>(Verbraucher ist jede natrliche Person, die ein Rechtsgeschft zu Zwecken abschliet, die berwiegend weder ihrer gewerblichen noch ihrer selbststndigen beruflichen Ttigkeit zugerechnet werden kann.)</p><h3 class=\"h3\">Widerrufsbelehrung</h3><p>Widerrufsrecht Sie haben das Recht, binnen vierzehn Tagen ohne Angabe von Grnden diesen Vertrag zu widerrufen. Die Widerrufsfrist betrgt vierzehn Tage ab dem Tag,</p><p>- an dem Sie oder ein von Ihnen benannter Dritter, der nicht der Befrderer ist, die Waren in Besitz genommen haben bzw. hat, sofern Sie eine oder mehrere Waren im Rahmen einer einheitlichen Bestellung bestellt haben; und diese einheitlich geliefert wird bzw. werden</p><p>- an dem Sie oder ein von Ihnen benannter Dritter, der nicht der Befrderer ist, die letzte Ware in Besitz genommen haben bzw. hat, sofern Sie mehrere Waren im Rahmen einer einheitlichen Bestellung bestellt haben; und diese getrennt geliefert werden</p><p>Um Ihr Widerrufsrecht auszuben, mssen Sie uns (Angela Lehmann, Dornachgasse 15, 6850 Dornbirn, Telefonnummer: +43 664-1306372, Telefaxnummer: +43 5572-422498, E-Mail-Adresse: mittels einer eindeutigen Erklrung (z.B. ein mit der Post versandter Brief, Telefax oder ha-lehmann@gmx.at) E-Mail) ber Ihren Entschluss, diesen Vertrag zu widerrufen, informieren. Sie knnen dafr das beigefgte Muster-Widerrufsformular verwenden, das jedoch nicht vorgeschrieben ist.</p><p>Zur Wahrung der Widerrufsfrist reicht es aus, dass Sie die Mitteilung ber die Ausbung des Widerrufsrechts vor Ablauf der Widerrufsfrist absenden.</p><h3 class=\"h3\">Folgen des Widerrufs</h3><p>Wenn Sie diesen Vertrag widerrufen, haben wir Ihnen alle Zahlungen, die wir von Ihnen erhalten haben, einschlielich der Lieferkosten (mit Ausnahme der zustzlichen Kosten, die sich daraus ergeben, dass Sie eine andere Art der Lieferung als die von uns angebotene, gnstigste Standardlieferung gewhlt haben), unverzglich und sptestens binnen ab dem Tag zurckzuzahlen, an dem die Mitteilung ber Ihren Widerruf vierzehn Tagen dieses Vertrags bei uns eingegangen ist. Fr diese Rckzahlung verwenden wir dasselbe Zahlungsmittel, das Sie bei der ursprnglichen Transaktion eingesetzt haben, es sei denn, mit Ihnen wurde ausdrcklich etwas anderes vereinbart; in keinem Fall werden Ihnen wegen dieser Rckzahlung Entgelte berechnet.</p><p>Wir knnen die Rckzahlung verweigern, bis wir die Waren wieder zurckerhalten haben oder bis Sie den Nachweis erbracht haben, dass Sie die Waren zurckgesandt haben, je nachdem, welches der frhere Zeitpunkt ist.</p><p>Sie haben die Waren unverzglich und in jedem Fall sptestens binnen ab dem Tag, an dem Sie vierzehn Tagen uns ber den Widerruf dieses Vertrags unterrichten, an uns zurckzusenden oder zu bergeben. Die Frist ist gewahrt, wenn Sie die Waren vor Ablauf der Frist von absenden. vierzehn Tagen</p><p>Sie tragen die unmittelbaren Kosten der Rcksendung der Waren.</p><p>Sie mssen fr einen etwaigen Wertverlust der Waren nur aufkommen, wenn dieser Wertverlust auf einen zur Prfung der Beschaffenheit, Eigenschaften und Funktionsweise der Waren nicht notwendigen Umgang mit ihnen zurckzufhren ist.</p><h3 class=\"h3\">Ausschluss- bzw. Erlschensgrnde</h3><p>Das Widerrufsrecht besteht nicht bei Vertrgen</p><p>- zur Lieferung von Waren, die nicht vorgefertigt sind und fr deren Herstellung eine individuelle Auswahl oder Bestimmung durch den Verbraucher mageblich ist oder die eindeutig auf die persnlichen Bedrfnisse des Verbrauchers zugeschnitten sind; - zur Lieferung von Waren, die schnell verderben knnen oder deren Verfallsdatum schnell berschritten wrde; - zur Lieferung alkoholischer Getrnke, deren Preis bei Vertragsschluss vereinbart wurde, die aber frhestens 30 Tage nach Vertragsschluss geliefert werden knnen und deren aktueller Wert von Schwankungen auf dem Markt abhngt, auf die der Unternehmer keinen Einfluss hat; - zur Lieferung von Zeitungen, Zeitschriften oder Illustrierten mit Ausnahme von Abonnement-Vertrgen.</p><p>Das Widerrufsrecht erlischt vorzeitig bei Vertrgen</p><p>- zur Lieferung versiegelter Waren, die aus Grnden des Gesundheitsschutzes oder der Hygiene nicht zur Rckgabe geeignet sind, wenn ihre Versiegelung nach der Lieferung entfernt wurde; - zur Lieferung von Waren, wenn diese nach der Lieferung aufgrund ihrer Beschaffenheit untrennbar mit anderen Gtern vermischt wurden; - zur Lieferung von Ton- oder Videoaufnahmen oder Computersoftware in einer versiegelten Packung, wenn die Versiegelung nach der Lieferung entfernt wurde. </p><h3 class=\"h3\">Widerrufsformular</h3><iframe src=\"https://docs.google.com/forms/d/e/1FAIpQLSdKP-t3e19dPw1xbsJmaJqCzfTNMWQQ_Knyqr-F5Cfrlej7Jw/viewform?embedded=true\" width=\"100%\" height=\"1350\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\"><div>Wird geladen...</div></iframe>");;return buf.join("");
}; },"views/sample": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (version) {
buf.push("<h2>Made with Spine.js version " + (jade.escape((jade_interp = version) == null ? '' : jade_interp)) + "</h2><p>Time to get busy with this magic!</p>");}.call(this,"version" in locals_for_with?locals_for_with.version:typeof version!=="undefined"?version:undefined));;return buf.join("");
}; },"views/temp": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<div><p>Unser hochwirksames Pfefferspray (Markenqualitt Made in Germany) enthlt das konzentrierte</p><p>Extrakt (je nach Produkt zwischen 3 und 13,2%) Oleoresin Capsicum (des Cayenne-Pfeffers).</p><p>Pfefferspray macht jeden Angreifer innerhalb weniger Sekundenbruchteile kampf- und handlungsunfhig.</p><p>Die Augen, Haut und Schleimhute brennen wie Feuer und der Angreifer ringt nach Luft.</p><p>Die Wirkung hlt je nach Sprhdauer bis zu einigen Stunden an.</p><p></p><p class=\"bs-warning\"><strong>Zur Beachtung: </strong>  Pfefferspray darf in Deutschland nur zur Abwehr von angreifenden und aggressiven Tierenverwendet und verkauft werden.</p></div>");;return buf.join("");
}; },"views/version": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;
;var locals_for_with = (locals || {});(function (app_version, bs_version, copyright, spine_version) {
buf.push("<p><div>Copyright " + (jade.escape((jade_interp = copyright) == null ? '' : jade_interp)) + "</div><div>App v." + (jade.escape((jade_interp = app_version) == null ? '' : jade_interp)) + "</div><div>Spine v." + (jade.escape((jade_interp = spine_version) == null ? '' : jade_interp)) + "</div><div>Bootstrap v." + (jade.escape((jade_interp = bs_version) == null ? '' : jade_interp)) + "</div></p>");}.call(this,"app_version" in locals_for_with?locals_for_with.app_version:typeof app_version!=="undefined"?app_version:undefined,"bs_version" in locals_for_with?locals_for_with.bs_version:typeof bs_version!=="undefined"?bs_version:undefined,"copyright" in locals_for_with?locals_for_with.copyright:typeof copyright!=="undefined"?copyright:undefined,"spine_version" in locals_for_with?locals_for_with.spine_version:typeof spine_version!=="undefined"?spine_version:undefined));;return buf.join("");
}; },"views/warning": function(exports, require, module) { module.exports = function template(locals) {
var buf = [];
var jade_mixins = {};
var jade_interp;

buf.push("<div class=\"danger alert\"><p>Der Versand von Pfeffer- und CS Gas-Sprays erfolgt ausschlielich an Personen ber <strong>18 Jahre</strong> mit Altersnachweis</p><p>Dazu bitte ein Scan oder Foto des Nachweises per Mail an ha-lehmann@gmx.at senden.</p><p>Dieser FSK 18 Artikel kann gem. einer Richlinie von PayPal nicht mit PayPal bezahlt werden.</p></div>");;return buf.join("");
}; }
});


